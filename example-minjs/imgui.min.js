// =====================================================================================================================
// nav.js BEGIN
// =====================================================================================================================

// ImguiNav is a subset of ImguiPrivate that has been migrated into
// this virtual class because that file is too large/unwieldy.
// We assume/require that ImguiPrivate be extended by us and reference
// ImguiPrivate's private parts conspicuously.

const NavWinHighlightDelay = .2; // time before highlight an and screen dimming
const NavWinAppearDelay = .15;

class NavMoveResult
{
    constructor()
    {
        this.Clear();
    }

    Clear()
    {
        this.ID = 0; // Best candiate
        this.SelectScopeId = 0; // Best candidate window current selectable groupID
        this.Window = null; // Best candidate window
        this.DistBox = Number.MAX_VALUE; // dist to current NavId
        this.DistCenter = Number.MAX_VALUE; // center dist to current NavId
        this.DistAxial = Number.MAX_VALUE;
        this.RectRel = null; // best candidate bbox in window-relative coords
    }
}

var ImguiNavMixin =
{
    isNavInputPressed(n, mode) { return this.getNavInputAmount(n, mode) > 0; },

    isNavInputPressedAnyOfTwo(n1, n2, mode)
    {
        let sum = this.getNavInputAmount(n1, mode) +
                  this.getNavInputAmount(n2, mode);
        return sum > 0;
    },

    isNavInputDown(n)
    {
        return this.guictx.IO.NavInputs[n] > 0;
    },

    navInitWindow(win, forceReinit)
    {
        let g = this.guictx;
        console.assert(win == g.NavWindow);
        let init_for_nav = false;
        if (!(win.Flags & WindowFlags.NoNavInputs))
        {
            if (!(win.Flags & WindowFlags.ChildWindow) ||
                    (win.Flags & WindowFlags.Popup) ||
                    (win.NavLastIds[0] == 0) || forceReinit)
                init_for_nav = true;
        }
        if (init_for_nav)
        {
            this.setNavID(0, g.NavLayer);
            g.NavInitRequest = true;
            g.NavInitRequestFromMove = false;
            g.NavInitResultId = 0;
            g.NavInitResultRectRel = new Rect();
            this.navUpdateAnyRequestFlag();
        }
        else
        {
            g.NavId = win.NavLastIds[0];
        }
    },

    navMapKey(g, k, navinput)
    {
        if (this.IsKeyDown(g.IO.KeyMap[k]))
        {
            g.IO.NavInputs[navinput] = 1;
            g.NavInputSource = InputSource.NavKeyboard;
        }
    },

    navUpdate()
    {
        let g = this.guictx;
        g.IO.WantSetMousePos = false;

        // Set input source as Gamepad when buttons are pressed before we map
        // Keyboard (some features differs when used with Gamepad vs Keyboard)
        let nav_keyboard_active = (g.IO.ConfigFlags & ConfigFlags.NavEnableKeyboard) != 0;
        let nav_gamepad_active = (g.IO.ConfigFlags & ConfigFlags.NavEnableGamepad) != 0 &&
                                    (g.IO.BackendFlags & BackendFlags.HasGamepad) != 0;
        if (nav_gamepad_active)
        {
            if (g.IO.NavInputs[NavInput.Activate] > 0 ||
                g.IO.NavInputs[NavInput.Input] > 0 ||
                g.IO.NavInputs[NavInput.Cancel] > 0 ||
                g.IO.NavInputs[NavInput.Menu] > 0)
            {
                g.NavInputSource = InputSource.NavGamepad;
            }
        }

        // Update Keyboard->Nav inputs mapping
        if (nav_keyboard_active)
        {
            this.navMapKey(g, Key.Space, NavInput.Activate);
            this.navMapKey(g, Key.Enter, NavInput.Input);
            this.navMapKey(g, Key.Escape, NavInput.Cancel);
            this.navMapKey(g, Key.LeftArrow, NavInput.KeyLeft_);
            this.navMapKey(g, Key.RightArrow,NavInput.KeyRight_);
            this.navMapKey(g, Key.UpArrow, NavInput.KeyUp_);
            this.navMapKey(g, Key.DownArrow, NavInput.KeyDown_);
            this.navMapKey(g, Key.Tab, NavInput.KeyTab_);
            if (g.IO.KeyCtrl)
                g.IO.NavInputs[NavInput.TweakSlow] = 1;
            if (g.IO.KeyShift)
                g.IO.NavInputs[NavInput.TweakFast] = 1;
            if (g.IO.KeyAlt && !g.IO.KeyCtrl) // AltGR is Alt+Ctrl, also even on keyboards without AltGR we don't want Alt+Ctrl to open menu.
                g.IO.NavInputs[NavInput.KeyMenu_]  = 1;
        }
        g.IO.NavInputsDownDurationPrev = g.IO.NavInputsDownDuration.slice(); // copy
        for (let i = 0; i < g.IO.NavInputs.length; i++)
        {
            g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0) ?
                        (g.IO.NavInputsDownDuration[i] < 0 ? 0 :
                            g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1;
        }

        // Process navigation init request (select first/default focus)
        if (g.NavInitResultId != 0 &&
            (!g.NavDisableHighlight || g.NavInitRequestFromMove))
        {
            // Apply result from previous navigation init request (will typically
            // select the first item, unless SetItemDefaultFocus() has been called)
            console.assert(g.NavWindow);
            if (g.NavInitRequestFromMove)
                this.setNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);
            else
                this.setNavID(g.NavInitResultId, g.NavLayer);
            g.NavWindow.NavRectRel[g.NavLayer] = g.NavInitResultRectRel;
        }
        g.NavInitRequest = false;
        g.NavInitRequestFromMove = false;
        g.NavInitResultId = 0;
        g.NavJustMovedToId = 0;

        // Process navigation move request
        if (g.NavMoveRequest)
            this.navUpdateMoveResult();

        // When a forwarded move request failed, we restore the highlight that
        // we disabled during the forward frame
        if (g.NavMoveRequestForward == NavForward.ForwardActive)
        {
            console.assert(g.NavMoveRequest);
            if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
                g.NavDisableHighlight = false;
            g.NavMoveRequestForward = NavForward.None;
        }

        // Apply application mouse position movement, after we had a chance to
        // process move request result.
        if (g.NavMousePosDirty && g.NavIdIsAlive)
        {
            // Set mouse position given our knowledge of the navigated item
            // position from last frame
            if ((g.IO.ConfigFlags & ConfigFlags.NavEnableSetMousePos) &&
                (g.IO.BackendFlags & BackendFlags.HasSetMousePos))
            {
                if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
                {
                    g.IO.MousePos = this.navCalcPreferredRefPos();
                    g.IO.MousePosPrev = g.IO.MousePos.Clone();
                    g.IO.WantSetMousePos = true;
                }
            }
            g.NavMousePosDirty = false;
        }
        g.NavIdIsAlive = false;
        g.NavJustTabbedId = 0;
        console.assert(g.NavLayer == 0 || g.NavLayer == 1);

        // Store our return window (for returning from Layer 1 to Layer 0) and
        // clear it as soon as we step back in our own Layer 0
        if (g.NavWindow)
            this.navSaveLastChildNavWindowIntoParent(g.NavWindow);
        if (g.NavWindow && g.NavWindow.NavLastChildNavWindow != null && g.NavLayer == 0)
            g.NavWindow.NavLastChildNavWindow = null;

        // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
        this.navUpdateWindowing();

        // Set output flags for user application
        g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) &&
                g.NavWindow && !(g.NavWindow.Flags & WindowFlags.NoNavInputs);
        g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight)
                        || (g.NavWindowingTarget != null);

        // Process NavCancel input (to close a popup, get back to parent,
        // clear focus)
        if (this.isNavInputPressed(NavInput.Cancel, InputReadMode.Pressed))
        {
            if (g.ActiveId != 0)
            {
                if (!(g.ActiveIdBlockNavInputFlags & (1 << NavInput.Cancel)))
                    this.clearActiveID();
            }
            else
            if (g.NavWindow &&
                (g.NavWindow.Flags & WindowFlags.ChildWindow) &&
                 !(g.NavWindow.Flags & WindowFlags.Popup) &&
                g.NavWindow.ParentWindow)
            {
                // Exit child window
                let child_window = g.NavWindow;
                let parent_window = g.NavWindow.ParentWindow;
                console.assert(child_window.ChildId != 0);
                this.FocusWindow(parent_window);
                this.setNavID(child_window.ChildId, 0);
                g.NavIdIsAlive = false;
                if (g.NavDisableMouseHover)
                    g.NavMousePosDirty = true;
            }
            else
            if (g.OpenPopupStack.length > 0)
            {
                // Close open popup/menu
                let p = g.OpenPopupStack[g.OpenPopupStack.length-1];
                if (!(p.Window.Flags & WindowFlags.Modal))
                    this.closePopupToLevel(g.OpenPopupStack.length - 1, true);
            }
            else
            if (g.NavLayer != 0)
            {
                // Leave the "menu" layer
                this.navRestoreLayer(NavLayer.Main);
            }
            else
            {
                // Clear NavLastId for popups but keep it for regular child
                // window so we can leave one and come back where we were
                if (g.NavWindow &&
                    ((g.NavWindow.Flags & WindowFlags.Popup) ||
                     !(g.NavWindow.Flags & WindowFlags.ChildWindow)))
                {
                    g.NavWindow.NavLastIds[0] = 0;
                }
                g.NavId = 0;
            }
        }

        // Process manual activation request
        g.NavActivateId = g.NavActivateDownId = 0;
        g.NavActivatePressedId = g.NavInputId = 0;
        if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget &&
            g.NavWindow && !(g.NavWindow.Flags & WindowFlags.NoNavInputs))
        {
            let activate_down = this.isNavInputDown(NavInput.Activate);
            let activate_pressed = activate_down &&
                this.isNavInputPressed(NavInput.Activate, InputReadMode.Pressed);
            if (g.ActiveId == 0 && activate_pressed)
                g.NavActivateId = g.NavId;
            if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
                g.NavActivateDownId = g.NavId;
            if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
                g.NavActivatePressedId = g.NavId;
            if ((g.ActiveId == 0 || g.ActiveId == g.NavId) &&
                this.isNavInputPressed(NavInput.Input, InputReadMode.Pressed))
                g.NavInputId = g.NavId;
        }
        if (g.NavWindow && (g.NavWindow.Flags & WindowFlags.NoNavInputs))
            g.NavDisableHighlight = true;
        if (g.NavActivateId != 0)
            console.assert(g.NavActivateDownId == g.NavActivateId);
        g.NavMoveRequest = false;

        // Process programmatic activation request
        if (g.NavNextActivateId != 0)
        {
            g.NavActivateId = g.NavActivateDownId =
            g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;
        }
        g.NavNextActivateId = 0;

        // Initiate directional inputs request
        const allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;
        if (g.NavMoveRequestForward == NavForward.None)
        {
            g.NavMoveDir = Dir.None;
            g.NavMoveRequestFlags = NavMoveFlags.None;
            if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags &&
                !(g.NavWindow.Flags & WindowFlags.NoNavInputs))
            {
                if ((allowed_dir_flags & (1<<Dir.Left))  &&
                    this.isNavInputPressedAnyOfTwo(NavInput.DpadLeft, NavInput.KeyLeft_,
                                                   InputReadMode.Repeat))
                {
                    g.NavMoveDir = Dir.Left;
                }
                if ((allowed_dir_flags & (1<<Dir.Right)) &&
                    this.isNavInputPressedAnyOfTwo(NavInput.DpadRight, NavInput.KeyRight_,
                                                   InputReadMode.Repeat))
                {
                    g.NavMoveDir = Dir.Right;
                }
                if ((allowed_dir_flags & (1<<Dir.Up)) &&
                    this.isNavInputPressedAnyOfTwo(NavInput.DpadUp, NavInput.KeyUp_,
                                                   InputReadMode.Repeat))
                {
                    g.NavMoveDir = Dir.Up;
                }
                if ((allowed_dir_flags & (1<<Dir.Down)) &&
                    this.isNavInputPressedAnyOfTwo(NavInput.DpadDown, NavInput.KeyDown_,
                                                   InputReadMode.Repeat))
                {
                    g.NavMoveDir = Dir.Down;
                }
            }
            g.NavMoveClipDir = g.NavMoveDir;
        }
        else
        {
            // Forwarding previous request (which has been modified, e.g. wrap
            // around menus rewrite the requests with a starting rectangle at
            // the other side of the window)
            // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set
            // by the navMoveRequestForward() function)
            console.assert(g.NavMoveDir != Dir.None && g.NavMoveClipDir != Dir.None);
            console.assert(g.NavMoveRequestForward == NavForward.ForwardQueued);
            g.NavMoveRequestForward = NavForward.ForwardActive;
        }

        // Update PageUp/PageDown scroll
        let nav_scoring_rect_offset_y = 0;
        if (nav_keyboard_active)
            nav_scoring_rect_offset_y = this.navUpdatePageUpPageDown(allowed_dir_flags);

        // If we initiate a movement request and have no current NavId, we
        // initiate a InitDefautRequest that will be used as a fallback if
        // the direction fails to find a match
        if (g.NavMoveDir != Dir.None)
        {
            g.NavMoveRequest = true;
            g.NavMoveDirLast = g.NavMoveDir;
        }
        if (g.NavMoveRequest && g.NavId == 0)
        {
            g.NavInitRequest = g.NavInitRequestFromMove = true;
            g.NavInitResultId = 0;
            g.NavDisableHighlight = false;
        }
        this.navUpdateAnyRequestFlag();

        // Scrolling
        if (g.NavWindow && !(g.NavWindow.Flags & WindowFlags.NoNavInputs)
            && !g.NavWindowingTarget)
        {
            // *Fallback* manual-scroll with Nav directional keys when window
            // has no navigable item
            let win = g.NavWindow;
            // We need round the scrolling speed because sub-pixel scroll isn't
            // reliably supported.
            const scroll_speed = Math.floor(win.CalcLineHeight()*100*g.IO.DeltaTime + 0.5);
            if (win.DC.NavLayerActiveMask == 0x00 &&
                win.DC.NavHasScroll && g.NavMoveRequest)
            {
                if (g.NavMoveDir == Dir.Left || g.NavMoveDir == Dir.Right)
                {
                    win.SetWindowScrollX(Math.floor(win.Scroll.x +
                            ((g.NavMoveDir == Dir.Left) ? -1 : 1) * scroll_speed));
                }
                if (g.NavMoveDir == Dir.Up || g.NavMoveDir == Dir.Down)
                {
                    win.SetWindowScrollY(Math.floor(win.Scroll.y +
                             ((g.NavMoveDir == Dir.Up) ? -1 : 1) * scroll_speed));
                }
            }

            // *Normal* Manual scroll with NavScrollXXX keys
            // Next movement request will clamp the NavId reference rectangle
            // to the visible area, so navigation will resume within those bounds.
            let scroll_dir = this.getNavInputAmount2d(NavDirSourceFlags.PadLStick,
                                        InputReadMode.Down, 1.0/10.0, 10.0);
            if (scroll_dir.x != 0 && win.ScrollbarX)
            {
                win.SetWindowScrollX(Math.floor(win.Scroll.x + scroll_dir.x * scroll_speed));
                g.NavMoveFromClampedRefRect = true;
            }
            if (scroll_dir.y != 0)
            {
                win.SetWindowScrollY(Math.floor(win.Scroll.y + scroll_dir.y * scroll_speed));
                g.NavMoveFromClampedRefRect = true;
            }
        }
        // Reset search results
        g.NavMoveResultLocal.Clear();
        g.NavMoveResultLocalVisibleSet.Clear();
        g.NavMoveResultOther.Clear();

        // When we have manually scrolled (without using navigation) and
        // NavId becomes out of bounds, we project its bounding box to the
        // visible area to restart navigation within visible items
        if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)
        {
            let win = g.NavWindow;
            let window_rect_rel = new Rect(
                    Vec2.SubtractXY(Vec2.Subtract(win.InnerMainRect.Min, win.Pos),1,1),
                    Vec2.AddXY(Vec2.Subtract(win.InnerMainRect.Max, win.Pos),1,1));
            if (!window_rect_rel.Contains(win.NavRectRel[g.NavLayer]))
            {
                // Terrible approximation for the intent of starting navigation
                // from first fully visible item
                let pad = win.CalcLineHeight() * .5;
                window_rect_rel.expandXY(-Math.min(window_rect_rel.GetWidth(), pad),
                                        -Math.min(window_rect_rel.GetHeight(), pad));
                win.NavRectRel[g.NavLayer].ClipWith(window_rect_rel);
                g.NavId = 0;
            }
            g.NavMoveFromClampedRefRect = false;
        }

        // For scoring we use a single segment on the left side our current
        // item bounding box (not touching the edge to avoid box overlap with
        // zero-spaced items)
        let nav_rect_rel;
        if(g.NavWindow && !g.NavWindow.NavRectRel[g.NavLayer].IsInverted())
            nav_rect_rel = g.NavWindow.NavRectRel[g.NavLayer];
        else
            nav_rect_rel = Rect.FromXY(0,0,0,0);
        if(g.NavWindow)
        {
            g.NavScoringRectScreen = new Rect(
                                Vec2.Add(g.NavWindow.Pos, nav_rect_rel.Min),
                                Vec2.Add(g.NavWindow.Pos, nav_rect_rel.Max));
        }
        else
        {
            g.NavScoringRectScreen = this.getViewportRect().Clone();
        }
        g.NavScoringRectScreen.TranslateY(nav_scoring_rect_offset_y);
        g.NavScoringRectScreen.Min.x = Math.min(g.NavScoringRectScreen.Min.x+1,
                                                g.NavScoringRectScreen.Max.x);
        g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;
        // Ensure if we have a finite, non-inverted bounding box here will
        // allows us to remove extraneous ImFabs() calls in NavScoreItem().
        console.assert(!g.NavScoringRectScreen.IsInverted());
        //GetForegroundDrawList()->AddRect(g.NavScoringRectScreen.Min,
        // g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
        g.NavScoringCount = 0;

        if(false) // DEBUG_NAV_RECTS
        {
            if (g.NavWindow)
            {
                let draw_list = this.GetForegroundDrawList(g.NavWindow);
                for (let layer = 0; layer < 2; layer++)
                {
                    draw_list.AddRect(g.NavWindow.Pos + g.NavWindow.NavRectRel[layer].Min,
                                      g.NavWindow.Pos + g.NavWindow.NavRectRel[layer].Max,
                                      g.Style.GetColor("_DEBUG1"));
                } // [DEBUG]
                let col = (!g.NavWindow.Hidden) ? g.Style.GetColor("_DEBUG2") :
                                g.Style.GetColor("_DEBUG3");
                let p = this.navCalcPreferredRefPos();
                let  buf = g.NavLayer.toFixed(0);
                draw_list.AddCircleFilled(p, 3., col);
                draw_list.AddText(buf, Vec2.AddXY(p, 8,-4), g.Font, g.FontLineHeight, col);
            }
        }
    }, // end navUpdate

    // We get here when either NavId == id, or when g.NavAnyRequest is set
    // (which is updated by NavUpdateAnyRequestFlag above)
    navProcessItem(win, nav_bb, id)
    {
        let g = this.guictx;

        // if (!g.IO.NavActive)
        //    return;
        // [2017/10/06] Removed this possibly redundant test but I am not sure
        // of all the side-effects yet. Some of the feature here will need to work
        // regardless of using a _NoNavInputs flag.

        let item_flags = win.DC.ItemFlags;
        let nav_bb_rel = new Rect(Vec2.Subtract(nav_bb.Min, win.Pos),
                                    Vec2.Subtract(nav_bb.Max, win.Pos));

        // Process Init Request
        if (g.NavInitRequest && g.NavLayer == win.DC.NavLayerCurrent)
        {
            // Even if 'ItemFlags.NoNavDefaultFocus' is on (typically
            // collapse/close button) we record the first ResultId so they
            // can be used as a fallback
            if (!(item_flags & ItemFlags.NoNavDefaultFocus) ||
                g.NavInitResultId == 0)
            {
                g.NavInitResultId = id;
                g.NavInitResultRectRel = nav_bb_rel;
            }
            if (!(item_flags & ItemFlags.NoNavDefaultFocus))
            {
                g.NavInitRequest = false; // Found a match, clear request
                this.navUpdateAnyRequestFlag();
            }
        }

        // Process Move Request (scoring for navigation)
        // FIXME-NAV: Consider policy for double scoring (scoring from
        // NavScoringRectScreen + scoring from a rect wrapped according to
        // current wrapping policy)
        if ((g.NavId != id ||
            (g.NavMoveRequestFlags & NavMoveFlags.AllowCurrentNavId)) &&
            !(item_flags & (ItemFlags.Disabled|ItemFlags.NoNav)))
        {
            let result = (win == g.NavWindow) ? g.NavMoveResultLocal : g.NavMoveResultOther;
            let new_best = g.NavMoveRequest && this.navScoreItem(result, nav_bb);
            if (new_best)
            {
                result.ID = id;
                result.SelectScopeId = g.MultiSelectScopeId;
                result.Window = win;
                result.RectRel = nav_bb_rel;
            }

            const VISIBLE_RATIO = 0.7;
            if ((g.NavMoveRequestFlags & NavMoveFlags.AlsoScoreVisibleSet) &&
                win.ClipRect.Overlaps(nav_bb))
            {
                if (Vec1.Clamp(nav_bb.Max.y, win.ClipRect.Min.y, win.ClipRect.Max.y) -
                    Vec1.Clamp(nav_bb.Min.y, win.ClipRect.Min.y, win.ClipRect.Max.y) >=
                    (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
                {
                    if (this.navScoreItem(g.NavMoveResultLocalVisibleSet, nav_bb))
                    {
                        result = g.NavMoveResultLocalVisibleSet;
                        result.ID = id;
                        result.SelectScopeId = g.MultiSelectScopeId;
                        result.Window = win;
                        result.RectRel = nav_bb_rel;
                    }
                }
            }
        }

        // Update window-relative bounding box of navigated item
        if (g.NavId == id)
        {
            // Always refresh g.NavWindow, because some operations such as
            // focusItem() don't have a window.
            console.assert(win);
            g.NavWindow = win;
            g.NavLayer = win.DC.NavLayerCurrent;
            g.NavIdIsAlive = true;
            g.NavIdTabCounter = win.DC.FocusCounterTab;
            // Store item bounding box (relative to window position)
            win.NavRectRel[win.DC.NavLayerCurrent] = nav_bb_rel;
        }
    },

    navMoveRequestButNoResultYet()
    {
        let g = this.guictx;
        return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 &&
                g.NavMoveResultOther.ID == 0;
    },

    navMoveRequestCancel()
    {
        let g = this.guictx;
        g.NavMoveRequest = false;
        this.navUpdateAnyRequestFlag();
    },

    navMoveRequestForward(move_dir, clip_dir, bb_rel, move_flags)
    {
        let g = this.guictx;
        console.assert(g.NavMoveRequestForward == NavForward.None);
        this.navMoveRequestCancel();
        g.NavMoveDir = move_dir;
        g.NavMoveClipDir = clip_dir;
        g.NavMoveRequestForward = NavForward.ForwardQueued;
        g.NavMoveRequestFlags = move_flags;
        g.NavWindow.NavRectRel[g.NavLayer] = bb_rel.Clone();
    },

    navMoveRequestTryWrapping(win, move_flags)
    {
        let g = this.guictx;
        if (g.NavWindow != win ||
            !this.navMoveRequestButNoResultYet() ||
            g.NavMoveRequestForward != NavForward.None || g.NavLayer != 0)
        {
            return;
        }
        console.assert(move_flags != 0); // No points calling this with no wrapping
        let bb_rel = win.NavRectRel[0].Clone();
        let clip_dir = g.NavMoveDir;
        if (g.NavMoveDir == Dir.Left &&
            (move_flags & (NavMoveFlags.WrapX | NavMoveFlags.LoopX)))
        {
            bb_rel.Min.x = bb_rel.Max.x =
                Math.max(win.SizeFull.x, win.SizeContents.x) - win.Scroll.x;
            if (move_flags & NavMoveFlags.WrapX)
            {
                bb_rel.TranslateY(-bb_rel.GetHeight());
                clip_dir = Dir.Up;
            }
            this.navMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
        }
        if (g.NavMoveDir == Dir.Right &&
            (move_flags & (NavMoveFlags.WrapX | NavMoveFlags.LoopX)))
        {
            bb_rel.Min.x = bb_rel.Max.x = -win.Scroll.x;
            if (move_flags & NavMoveFlags.WrapX)
            {
                bb_rel.TranslateY(+bb_rel.GetHeight());
                clip_dir = Dir.Down;
            }
            this.navMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
        }
        if (g.NavMoveDir == Dir.Up &&
            (move_flags & (NavMoveFlags.WrapY | NavMoveFlags.LoopY)))
        {
            bb_rel.Min.y = bb_rel.Max.y =
                Math.max(win.SizeFull.y, win.SizeContents.y) - win.Scroll.y;
            if (move_flags & NavMoveFlags.WrapY)
            {
                bb_rel.TranslateX(-bb_rel.GetWidth());
                clip_dir = Dir.Left;
            }
            this.navMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
        }
        if (g.NavMoveDir == Dir.Down &&
            (move_flags & (NavMoveFlags.WrapY | NavMoveFlags.LoopY)))
        {
            bb_rel.Min.y = bb_rel.Max.y = -win.Scroll.y;
            if (move_flags & NavMoveFlags.WrapY)
            {
                bb_rel.wranslateX(+bb_rel.GetWidth());
                clip_dir = Dir.Right;
            }
            this.navMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
        }
    },

    getNavInputAmount(n, mode)
    {
        let g = this.guictx;
        // Instant, read analog input (0.0f..1., as provided by user)
        if (mode == InputReadMode.Down)
            return g.IO.NavInputs[n];
        const t = g.IO.NavInputsDownDuration[n];
        // Return 1 when just released, no repeat, ignore analog input.
        if (t < 0 && mode == InputReadMode.Released)
            return (g.IO.NavInputsDownDurationPrev[n] >= 0 ? 1 : 0);
        if (t < 0) return 0;

        // Return 1.0f when just pressed, no repeat, ignore analog input.
        if (mode == InputReadMode.Pressed)
            return (t == 0) ? 1 : 0;
        if (mode == InputReadMode.Repeat)
            return this.calcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime,
                        g.IO.KeyRepeatDelay*0.8, g.IO.KeyRepeatRate*0.8);
        if (mode == InputReadMode.RepeatSlow)
            return this.calcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime,
                        g.IO.KeyRepeatDelay*1, g.IO.KeyRepeatRate*2);
        if (mode == InputReadMode.RepeatFast)
            return this.calcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime,
                        g.IO.KeyRepeatDelay*0.8, g.IO.KeyRepeatRate*0.3);
        return 0;
    },

    getNavInputAmount2d(dir_sources, mode, slow_factor, fast_factor)
    {
        let delta = Vec2.Zero().Clone();
        if (dir_sources & NavDirSourceFlags.Keyboard)
        {
            delta.AddXY(this.getNavInputAmount(NavInput.KeyRight_, mode) -
                        this.getNavInputAmount(NavInput.KeyLeft_, mode),
                        this.getNavInputAmount(NavInput.KeyDown_, mode) -
                        this.getNavInputAmount(NavInput.KeyUp_, mode));
        }
        if (dir_sources & NavDirSourceFlags.PadDPad)
        {
            delta.AddXY(this.getNavInputAmount(NavInput.DpadRight, mode) -
                        this.getNavInputAmount(NavInput.DpadLeft, mode),
                        this.getNavInputAmount(NavInput.DpadDown, mode) -
                        this.getNavInputAmount(NavInput.DpadUp,mode));
        }
        if (dir_sources & NavDirSourceFlags.PadLStick)
        {
            delta.AddXY(this.getNavInputAmount(NavInput.LStickRight, mode) -
                        this.getNavInputAmount(NavInput.LStickLeft, mode),
                        this.getNavInputAmount(NavInput.LStickDown, mode) -
                        this.getNavInputAmount(NavInput.LStickUp, mode));
        }
        if (slow_factor != 0 && this.isNavInputDown(NavInput.TweakSlow))
            delta.Mult(slow_factor);
        if (fast_factor != 0 && this.isNavInputDown(NavInput.TweakFast))
            delta.Mult(fast_factor);
        return delta;
    },

    calcTypematicPressedRepeatAmount(t, t_prev, repeat_delay, repeat_rate)
    {
        if (t == 0) return 1;
        if (t <= repeat_delay || repeat_rate <= 0) return 0;
        const count = Math.floor((t-repeat_delay)/repeat_rate) -
                        Math.floor((t_prev-repeat_delay)/repeat_rate);
        return (count > 0) ? count : 0;
    },

    activateItem(id) // remotely activate a button, checkbox, ..
    {
        this.guictx.NavNextActivateId = id;
    },

    setNavID(id, nav_layer)
    {
        let g = this.guictx;
        console.assert(g.NavWindow);
        console.assert(nav_layer == 0 || nav_layer == 1);
        g.NavId = id;
        g.NavWindow.NavLastIds[nav_layer] = id;
    },

    setNavIDWithRectRel(id, nav_layer, rect_rel)
    {
        let g = this.guictx;
        this.setNavID(id, nav_layer);
        g.NavWindow.NavRectRel[nav_layer] = rect_rel;
        g.NavMousePosDirty = true;
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
    },

    // Windowing management mode
    // Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
    // Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square
    //   (toggle menu layer)
    navUpdateWindowing()
    {
        let g = this.guictx;
        let modal_window = this.getFrontMostPopupModal();
        if (modal_window != null)
        {
            g.NavWindowingTarget = null;
            return;
        }
        let apply_focus_window = null;
        let apply_toggle_layer = false;

        // Fade out
        if (g.NavWindowingTargetAnim && g.NavWindowingTarget == null)
        {
            g.NavWindowingHighlightAlpha =
                Math.max(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10, 0);
            if (g.DimBgRatio <= 0 && g.NavWindowingHighlightAlpha <= 0)
                g.NavWindowingTargetAnim = null;
        }

        // Start CTRL-TAB or Square+L/R window selection
        let start_windowing_with_gamepad = !g.NavWindowingTarget &&
                    this.isNavInputPressed(NavInput.Menu, InputReadMode.Pressed);
        let start_windowing_with_keyboard = !g.NavWindowingTarget &&
                g.IO.KeyCtrl && this.isKeyPressedMap(Key.Tab) &&
                (g.IO.ConfigFlags& ConfigFlags.NavEnableKeyboard);

        if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        {
            let window = g.NavWindow ? g.NavWindow :
                this.findWindowNavFocusable(g.WindowsFocusOrder.Size-1,
                                            -Number.MAX_SAFE_INTEGER, -1);
            if (window != null)
            {
                g.NavWindowingTarget = g.NavWindowingTargetAnim = window;
                g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0;
                g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;
                g.NavInputSource = start_windowing_with_keyboard ?
                            InputSource.NavKeyboard : InputSource.NavGamepad;
            }
        }

        // Gamepad update
        g.NavWindowingTimer += g.IO.DeltaTime;
        if (g.NavWindowingTarget &&
            g.NavInputSource == InputSource.NavGamepad)
        {
            // Highlight only appears after a brief time holding the button,
            // so that a fast tap on PadMenu (to toggle NavLayer) doesn't add
            // visual noise
            g.NavWindowingHighlightAlpha = Math.max(g.NavWindowingHighlightAlpha,
                Vec1.Saturate((g.NavWindowingTimer-NavWinHighlightDelay)/.05));

            // Select window to focus
            const focus_change_dir =
                Math.floor(this.isNavInputPressed(NavInput.FocusPrev, InputReadMode.RepeatSlow))
                - Math.floor(this.isNavInputPressed(NavInput.FocusNext, InputReadMode.RepeatSlow));
            if (focus_change_dir != 0)
            {
                this.navUpdateWindowingHighlightWindow(focus_change_dir);
                g.NavWindowingHighlightAlpha = 1;
            }

            // Single press toggles NavLayer, long press with L/R apply actual
            // focus on release (until then the window was merely rendered front-most)
            if (!this.sNavInputDown(NavInput.Menu))
            {
                // Once button was held long enough we don't consider it a
                //  tap-to-toggle-layer press anymore.
                g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1);
                if (g.NavWindowingToggleLayer && g.NavWindow)
                    apply_toggle_layer = true;
                else
                if (!g.NavWindowingToggleLayer)
                    apply_focus_window = g.NavWindowingTarget;
                g.NavWindowingTarget = null;
            }
        }

        // Keyboard: Focus
        if (g.NavWindowingTarget && g.NavInputSource == InputSource.NavKeyboard)
        {
            // Visuals only appears after a brief time after pressing TAB the
            // first time, so that a fast CTRL+TAB doesn't add visual noise
            g.NavWindowingHighlightAlpha = Math.max(g.NavWindowingHighlightAlpha,
                    Vec1.Saturate((g.NavWindowingTimer-NavWinHighlightDelay)/0.05));
            if (this.isKeyPressedMap(Key.Tab, true))
                this.navUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);
            if (!g.IO.KeyCtrl)
                apply_focus_window = g.NavWindowingTarget;
        }

        // Keyboard: Press and Release ALT to toggle menu layer
        // FIXME: We lack an explicit IO variable for "is the imgui window focused",
        // so compare mouse validity to detect the common case of back-end
        // clearing releases all keys on ALT-TAB
        if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) &&
            this.isNavInputPressed(NavInput.KeyMenu_, InputReadMode.Released))
        {
            if (this.IsMousePosValid(g.IO.MousePos) ==
                this.IsMousePosValid(g.IO.MousePosPrev))
            {
                apply_toggle_layer = true;
            }
        }

        // Move window
        if (g.NavWindowingTarget &&
            !(g.NavWindowingTarget.Flags & WindowFlags.NoMove))
        {
            let move_delta;
            if (g.NavInputSource == InputSource.NavKeyboard && !g.IO.KeyShift)
                move_delta = this.getNavInputAmount2d(NavDirSourceFlags.Keyboard,
                                                        InputReadMode.Down);
            if (g.NavInputSource == InputSource.NavGamepad)
                move_delta = this.getNavInputAmount2d(NavDirSourceFlags.PadLStick,
                                                        InputReadMode.Down);
            if (move_delta.x != 0 || move_delta.y != 0)
            {
                const NAV_MOVE_SPEED = 80.;
                const move_speed = Math.floor(NAV_MOVE_SPEED * g.IO.DeltaTime *
                        Math.min(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));
                    // FIXME: Doesn't code variable framerate very well
                g.NavWindowingTarget.RootWindow.Pos.Add(move_delta.Mult(move_speed));
                g.NavDisableMouseHover = true;
                this.MarkIniSettingsDirty(g.NavWindowingTarget);
            }
        }

        // Apply final focus
        if (apply_focus_window &&
            (g.NavWindow == null || apply_focus_window != g.NavWindow.RootWindow))
        {
            g.NavDisableHighlight = false;
            g.NavDisableMouseHover = true;
            apply_focus_window = this.navRestoreLastChildNavWindow(apply_focus_window);
            this.closePopupsOverWindow(apply_focus_window);
            this.clearActiveID();
            this.FocusWindow(apply_focus_window);
            if (apply_focus_window.NavLastIds[0] == 0)
                this.navInitWindow(apply_focus_window, false);
            // If the window only has a menu layer, select it directly
            if (apply_focus_window.DC.NavLayerActiveMask == (1 << NavLayer.Menu))
                g.NavLayer = NavLayer.Menu;
        }
        if (apply_focus_window)
            g.NavWindowingTarget = null;

        // Apply menu/layer toggle
        if (apply_toggle_layer && g.NavWindow)
        {
            // Move to parent menu if necessary
            let newNavWin = g.NavWindow;
            while ((newNavWin.DC.NavLayerActiveMask & (1 << 1)) == 0 &&
                    (newNavWin.Flags & WindowFlags.ChildWindow) != 0 &&
                    (newNavWin.Flags & (WindowFlags.Popup|WindowFlags.ChildMenu)) == 0)
            {
                newNavWin = newNavWin.ParentWindow;
            }
            if (newNavWin != g.NavWindow)
            {
                let oldNavWin = g.NavWindow;
                this.FocusWindow(newNavWin);
                newNavWin.NavLastChildNavWindow = oldNavWin;
            }
            g.NavDisableHighlight = false;
            g.NavDisableMouseHover = true;
            this.navRestoreLayer(
                (g.NavWindow.DC.NavLayerActiveMask & (1 << NavLayer.Menu)) ?
                (Math.floor(g.NavLayer) ^ 1) : NavLayer.Main); // ^ is xor
        }
    },

    // Window has already passed the IsWindowNavFocusable()
    getFallbackWindowNameForWindowingList(window)
    {
        if (window.Flags & WindowFlags.Popup)
            return "(Popup)";
        if ((window.Flags & WindowFlags.MenuBar) &&
            window.Name == "##MainMenuBar")
            return "(Main menu bar)";
        return "(Untitled)";
    },

    // Overlay displayed when using CTRL+TAB. Called by EndFrame().
    navUpdateWindowingList()
    {
        let g = this.guictx;
        console.assert(g.NavWindowingTarget != null);

        if (g.NavWindowingTimer < NavWinAppearDelay)
            return;

        if (g.NavWindowingList == null)
            g.NavWindowingList = this.findWindowByName("###NavWindowingList");
        this.SetNextWindowSizeConstraints(
                new Vec2(g.IO.DisplaySize.x * 0.2, g.IO.DisplaySize.y * 0.2),
                new Vec2(Number.MAX_VALUE, Number.MAX_VALUE));
        this.SetNextWindowPos(Vec2.Mult(g.IO.DisplaySize, 0.5), CondFlags.Always,
                                new Vec2(0.5, 0.5));
        this.PushStyleVar("WindowPadding", g.Style.WindowPadding * 2.);
        this.Begin("###NavWindowingList", null,
            WindowFlags.NoTitleBar|WindowFlags.NoFocusOnAppearing|
            WindowFlags.NoResize|WindowFlags.NoMove|WindowFlags.NoInputs|
            WindowFlags.AlwaysAutoResize|WindowFlags.NoSavedSettings);
        for (let n=g.WindowsFocusOrder.length - 1; n >= 0; n--)
        {
            let window = g.WindowsFocusOrder[n];
            if (!this.isWindowNavFocusable(window))
                continue;
            let label = window.Name;
            if(label.indexOf("##") != -1)
                label = this.getFallbackWindowNameForWindowingList(window);
            this.Selectable(label, g.NavWindowingTarget==window);
        }
        this.End();
        this.PopStyleVar();
    },

    navCalcPreferredRefPos()
    {
        let g = this.guictx;
        if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)
        {
            // Mouse (we need a fallback in case the mouse becomes invalid after being used)
            if (this.IsMousePosValid(g.IO.MousePos))
                return g.IO.MousePos;
            return g.LastValidMousePos;
        }
        else
        {
            // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.
            let rect_rel = g.NavWindow.NavRectRel[g.NavLayer];
            let pos = Vec2.AddXY(g.NavWindow.Pos,
                                rect_rel.Min.x + Math.min(g.Style.FramePadding.x * 4,
                                                           rect_rel.GetWidth()),
                                rect_rel.Max.y - Math.min(g.Style.FramePadding.y,
                                                            rect_rel.GetHeight()));
            let visible_rect = this.getViewportRect();
            // floor is important because non-integer mouse position application
            // in back-end might be lossy and result in undesirable non-zero delta.
            return Vec2.Clamp(Vec2.Floor(pos, visible_rect.Min, visible_rect.Max));
        }
    },

    // Apply result from previous frame navigation directional move request
    navUpdateMoveResult()
    {
        let g = this.guictx;
        if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
        {
            // In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
            if (g.NavId != 0)
            {
                g.NavDisableHighlight = false;
                g.NavDisableMouseHover = true;
            }
            return;
        }

        // Select which result to use (of type NavMoveResult)
        let result = (g.NavMoveResultLocal.ID != 0) ? g.NavMoveResultLocal : g.NavMoveResultOther;

        // PageUp/PageDown behavior first jumps to the bottom/top mostly visible
        // item, _otherwise_ use the result from the previous/next page.
        if (g.NavMoveRequestFlags & NavMoveFlags.AlsoScoreVisibleSet)
        {
            if (g.NavMoveResultLocalVisibleSet.ID != 0 &&
                g.NavMoveResultLocalVisibleSet.ID != g.NavId)
            {
                result = g.NavMoveResultLocalVisibleSet;
            }
        }

        // Maybe entering a flattened child from the outside? In this case solve
        // the tie using the regular scoring rules.
        if (result != g.NavMoveResultOther &&
            g.NavMoveResultOther.ID != 0 &&
            g.NavMoveResultOther.Window.ParentWindow == g.NavWindow)
        {
            if ((g.NavMoveResultOther.DistBox < result.DistBox) ||
                (g.NavMoveResultOther.DistBox == result.DistBox &&
                 g.NavMoveResultOther.DistCenter < result.DistCenter))
            {
                result  &g.NavMoveResultOther;
            }
        }
        console.assert(g.NavWindow && result.Window);

        // Scroll to keep newly navigated item fully into view.
        if (g.NavLayer == 0)
        {
            let rect_abs = new Rect(Vec2.Add(result.RectRel.Min, result.Window.Pos),
                                    Vec2.Add(result.RectRel.Max, result.Window.Pos));
            this.navScrollToBringItemIntoView(result.Window, rect_abs);

            // Estimate upcoming scroll so we can offset our result position so mouse position can be applied immediately after in NavUpdate()
            let next_scroll = result.Window.calcNextScrollFromScrollTargetAndClamp(false);
            let delta_scroll = Vec2.Subtract(result.Window.Scroll, next_scroll);
            result.RectRel.Translate(delta_scroll);

            // Also scroll parent window to keep us into view if necessary (we could/should technically recurse back the whole the parent hierarchy).
            if (result.Window.Flags & WindowFlags.ChildWindow)
                this.navScrollToBringItemIntoView(result.Window.ParentWindow,
                            new Rect(Vec2.Add(rect_abs.Min, delta_scroll),
                                     Vec2.Add(rect_abs.Max, delta_scroll)));
        }
    },

    // Scroll to keep newly navigated item fully into view
    // NB: We modify window.ScollTarget by the amount we scrolled for, so it is
    // immediately updated.
    navScrollToBringItemIntoView(win, item_rect)
    {
        let window_rect = new Rect(Vec2.AddXY(win.InnerMainRect.Min, -1, -1),
                                   Vec2.AddXY(win.InnerMainRect.Max + 1, 1));

        //GetForegroundDrawList(window)->AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]
        if (window_rect.Contains(item_rect))
            return;
        let g = this.guictx;
        if (win.ScrollbarX && item_rect.Min.x < window_rect.Min.x)
        {
            win.ScrollTarget.x = item_rect.Min.x - win.Pos.x + win.Scroll.x - g.Style.ItemSpacing.x;
            win.ScrollTargetCenterRatio.x = 0;
        }
        else
        if (win.ScrollbarX && item_rect.Max.x >= window_rect.Max.x)
        {
            win.ScrollTarget.x = item_rect.Max.x - win.Pos.x + win.Scroll.x + g.Style.ItemSpacing.x;
            win.ScrollTargetCenterRatio.x = 1;
        }
        if (item_rect.Min.y < window_rect.Min.y)
        {
            win.ScrollTarget.y = item_rect.Min.y - win.Pos.y + win.Scroll.y - g.Style.ItemSpacing.y;
            win.ScrollTargetCenterRatio.y = 0;
        }
        else
        if (item_rect.Max.y >= window_rect.Max.y)
        {
            win.ScrollTarget.y = item_rect.Max.y - win.Pos.y + win.Scroll.y + g.Style.ItemSpacing.y;
            win.ScrollTargetCenterRatio.y = 1;
        }
    },

    navUpdatePageUpPageDown(allowed_dir_flags)
    {
        let g = this.guictx;
        if (g.NavMoveDir == Dir.None && g.NavWindow &&
            !(g.NavWindow.Flags & WindowFlags.NoNavInputs) &&
            !g.NavWindowingTarget && g.NavLayer == 0)
        {
            let win = g.NavWindow;
            let page_up_held = this.IsKeyDown(g.IO.KeyMap[Key.PageUp]) &&
                                    (allowed_dir_flags & (1 << Dir.Up));
            let page_down_held = this.IsKeyDown(g.IO.KeyMap[Key.PageDown]) &&
                                    (allowed_dir_flags & (1 << Dir.Down));
            if (page_up_held != page_down_held) // If either (not both) are pressed
            {
                if (win.DC.NavLayerActiveMask == 0x00 && win.DC.NavHasScroll)
                {
                    // Fallback manual-scroll when window has no navigable item
                    if (this.IsKeyPressed(g.IO.KeyMap[Key.PageUp], true))
                        win.SetWindowScrollY(win.Scroll.y - win.InnerClipRect.GetHeight());
                    else
                    if (this.IsKeyPressed(g.IO.KeyMap[Key.PageDown], true))
                        win.SetWindowScrollY(win.Scroll.y + win.InnerClipRect.GetHeight());
                }
                else
                {
                    let nav_rect_rel = win.NavRectRel[g.NavLayer];
                    const page_offset_y = Math.max(0.,
                                        win.InnerClipRect.GetHeight() -
                                        win.CalcLineHeight() * 1 +
                                        nav_rect_rel.GetHeight());
                    let nav_scoring_rect_offset_y = 0.;
                    if (this.IsKeyPressed(g.IO.KeyMap[Key.PageUp], true))
                    {
                        nav_scoring_rect_offset_y = -page_offset_y;
                        // Because our scoring rect is offset, we intentionally
                        // request the opposite direction (so we can always land
                        // on the last item)
                        g.NavMoveDir = Dir.Down;
                        g.NavMoveClipDir = Dir.Up;
                        g.NavMoveRequestFlags = NavMoveFlags.AllowCurrentNavId |
                                                NavMoveFlags.AlsoScoreVisibleSet;
                    }
                    else
                    if (this.IsKeyPressed(g.IO.KeyMap[Key.PageDown], true))
                    {
                        nav_scoring_rect_offset_y = page_offset_y;
                        // Because our scoring rect is offset, we intentionally
                        // request the opposite direction (so we can always land
                        // on the last item)
                        g.NavMoveDir = Dir.Up;
                        g.NavMoveClipDir = Dir.Down;
                        g.NavMoveRequestFlags = NavMoveFlags.AllowCurrentNavId |
                                                NavMoveFlags.AlsoScoreVisibleSet;
                    }
                    return nav_scoring_rect_offset_y;
                }
            }
        }
        return 0.;
    },

    navUpdateAnyRequestFlag()
    {
        let g = this.guictx;
        g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest;
        if (g.NavAnyRequest)
            console.assert(g.NavWindow);
    },

    // FIXME: This could be replaced by updating a frame number in each
    // window when (window == NavWindow) and (NavLayer == 0). This way we could
    // find the last focused window among our children. It would be much
    // less confusing this way?
    navSaveLastChildNavWindowIntoParent(nav_window)
    {
        let parent = nav_window;
        while (parent && (parent.Flags & WindowFlags.ChildWindow) != 0 &&
                (parent.Flags & (WindowFlags.Popup | WindowFlags.ChildMenu)) == 0)
        {
            parent = parent.ParentWindow;
        }
        if (parent && parent != nav_window)
            parent.NavLastChildNavWindow = nav_window;
    },

    navGetDirQuadrantFromDelta(dx, dy)
    {
        if (Math.abs(dx) > Math.abs(dy))
            return (dx > 0) ? Dir.Right : Dir.Left;
        else
            return (dy > 0) ? Dir.Down : Dir.Up;
    },

    navScoreItemDistInterval(a0, a1, b0, b1)
    {
        if (a1 < b0)
            return a1 - b0;
        if (b1 < a0)
            return a0 - b1;
        return 0;
    },

    navClampRectToVisibleAreaForMoveDir(move_dir, r, clip_rect)
    {
        if (move_dir == Dir.Left || move_dir == Dir.Right)
        {
            r.Min.y = Vec1.Clamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);
            r.Max.y = Vec1.Clamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);
        }
        else
        {
            r.Min.x = Vec1.Clamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);
            r.Max.x = Vec1.Clamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);
        }
    },

    // Scoring function for directional navigation. Based on
    // https://gist.github.com/rygorous/6981057
    navScoreItem(result, cand)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (g.NavLayer != win.DC.NavLayerCurrent)
            return false;

        // Current modified source rect (NB: we've applied max.x = min.x in
        // NavUpdate() to inhibit the effect of having varied item width)
        let curr = g.NavScoringRectScreen;
        g.NavScoringCount++;

        // When entering through a NavFlattened border, we consider child
        // window items as fully clipped for scoring
        if (win.ParentWindow == g.NavWindow)
        {
            console.assert((win.Flags | g.NavWindow.Flags) & WindowFlags.NavFlattened);
            if (!win.ClipRect.Contains(cand))
                return false;
            // This allows the scored item to not overlap other candidates in
            // the parent window
            cand.ClipWithFull(win.ClipRect);
        }

        // We perform scoring on items bounding box clipped by the current
        // clipping rectangle on the other axis (clipping on our movement axis
        // would give us equal scores for all clipped items) For example, this
        // ensure that items in one column are not reached when moving vertically
        // from items in another column.
        this.navClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, win.ClipRect);

        // Compute distance between boxes
        // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
        let dbx = this.navScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
        // Scale down on Y to keep using box-distance for vertically touching items
        let dby = this.navScoreItemDistInterval(Vec1.Lerp(cand.Min.y, cand.Max.y, 0.2),
                                                Vec1.Lerp(cand.Min.y, cand.Max.y, 0.8),
                                                Vec1.Lerp(curr.Min.y, curr.Max.y, 0.2),
                                                Vec1.Lerp(curr.Min.y, curr.Max.y, 0.8));
        if (dby != 0 && dbx != 0)
           dbx = (dbx/1000) + ((dbx > 0) ? +1 : -1);
        let dist_box = Math.abs(dbx) + Math.abs(dby);

        // Compute distance between centers (this is off by a factor of 2, but
        // we only compare center distances with each other so it doesn't matter)
        let dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
        let dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
        let dist_center = Math.abs(dcx) + Math.abs(dcy);
        // L1 metric (need this for our connectedness guarantee)
        // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance

        let quadrant;
        let dax = 0, day = 0, dist_axial = 0;
        if (dbx != 0 || dby != 0)
        {
            // For non-overlapping boxes, use distance between boxes
            dax = dbx;
            day = dby;
            dist_axial = dist_box;
            quadrant = this.navGetDirQuadrantFromDelta(dbx, dby);
        }
        else
        if (dcx != 0 || dcy != 0)
        {
            // For overlapping boxes with different centers, use distance
            // between centers
            dax = dcx;
            day = dcy;
            dist_axial = dist_center;
            quadrant = this.navGetDirQuadrantFromDelta(dcx, dcy);
        }
        else
        {
            // Degenerate case: two overlapping buttons with same center,
            // break ties arbitrarily (note that LastItemId here is really
            //  the _previous_ item order, but it doesn't matter)
            quadrant = (win.DC.LastItemId < g.NavId) ? Dir.Left : Dir.Right;
        }

        if(0) // DEBUG/visualize
        {
            let style = g.Style;
            if (this.IsMouseHoveringRect(cand.Min, cand.Max))
            {
                let buf = `dbox ${dbx},${dby}->${dist_box}\n` +
                          `dcen ${dcx},${dcy}->${dist_center}\n` +
                          `dax ${dax},${day} ->${dist_axial}\n` +
                          `nav ${"WENS"[g.NavMovDir]}, quadrant ${"WENS"[quadrant]}`;
                let dl = this.GetForegroundDrawList(win);
                dl.AddRect(curr.Min, curr.Max, style.GetColor("_DEBUG1"));
                dl.AddRect(cand.Min, cand.Max, style.GetColor("_DEBUG2"));
                dl.AddRectFilled(Vec2.AddXY(cand.Max, -4,-4),
                                 Vec2.Add(cand.Max,this.CalcTextSize(buf)),
                                 style.GetColor("_DEBUG3"));
                dl.AddText(buf, cand.Max, style.GetFont("Default"),
                            g.FontLineHeight, style.GetColor("Text"));
            }
            else
            if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
            {
                if (this.IsKeyPressedMap(Key.C))
                {
                    g.NavMoveDirLast = (g.NavMoveDirLast + 1) & 3;
                    g.IO.KeysDownDuration[g.IO.KeyMap[Key.C]] = 0.01;
                }
                if (quadrant == g.NavMoveDir)
                {
                    let buf = `${dist_box}/${dist_center}`;
                    let dl = this.GetForegroundDrawList(win);
                    dl.AddRectFilled(cand.Min, cand.Max, style.GetColor("_DEBUG0"));
                    dl.AddText(buf, cand.Min, style.GetFont("Default"),
                                g.FontLineHeight, style.getColor("Text"));
                }
            }
        } // end debug

        // Is it in the quadrant we're interesting in moving to?
        let new_best = false;
        if (quadrant == g.NavMoveDir)
        {
            // Does it beat the current best candidate?
            if (dist_box < result.DistBox)
            {
                result.DistBox = dist_box;
                result.DistCenter = dist_center;
                return true;
            }
            if (dist_box == result.DistBox)
            {
                // Try using distance between center points to break ties
                if (dist_center < result.DistCenter)
                {
                    result.DistCenter = dist_center;
                    new_best = true;
                }
                else
                if (dist_center == result.DistCenter)
                {
                    // Still tied! we need to be extra-careful to make sure
                    // everything gets linked properly. We consistently break
                    // ties by symbolically moving "later" items (with higher
                    // index) to the right/downwards by an infinitesimal amount
                    // since we the current "best" button already (so it must
                    // have a lower index), this is fairly easy. This rule
                    // ensures that all buttons with dx==dy==0 will end up being
                    // linked in order of appearance along the x axis.
                    if (((g.NavMoveDir == Dir.Up || g.NavMoveDir == Dir.Down) ? dby : dbx) < 0)
                    {
                        // moving bj to the right/down decreases distance
                        new_best = true;
                    }
                }
            }
        }

        // Axial check: if 'curr' has no link at all in some direction and
        // 'cand' lies roughly in that direction, add a tentative link. This
        // will only be kept if no "real" matches are found, so it only augments
        // the graph produced by the above method using extra links. (important,
        // since it doesn't guarantee strong connectedness). This is just to
        // avoid buttons having no links in a particular direction when there's
        // a suitable neighbor. you get good graphs without this too.
        // 2017/09/29: FIXME: This now currently only enabled inside menu bars,
        // ideally we'd disable it everywhere. Menus in particular need to catch
        // failure. For general navigation it feels awkward.  Disabling it may
        // lead to disconnected graphs when nodes are very spaced out on
        // different axis. Perhaps consider offering this as an option?
        if (result.DistBox == Number.MAX_VALUE && dist_axial < result.DistAxial)  // Check axial match
        {
            if (g.NavLayer == 1 && !(g.NavWindow.Flags & WindowFlags.ChildMenu))
            {
                if ((g.NavMoveDir == Dir.Left && dax < 0) ||
                    (g.NavMoveDir == Dir.Right && dax > 0) ||
                    (g.NavMoveDir == Dir.Up && day < 0) ||
                    (g.NavMoveDir == Dir.Down && day > 0.))
                {
                    result.DistAxial = dist_axial;
                    new_best = true;
                }
            }
        }
        return new_best;
    }
};
// =====================================================================================================================
// nav.js END
// =====================================================================================================================
// =====================================================================================================================
// winmgr.js BEGIN
// =====================================================================================================================


/* local classes (exported mixin below) -------------------------*/
// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true
// and BackendFlags.HasMouseCursors is set in io.BackendFlags by back-end)

// Extend outside and inside windows. Affect FindHoveredWindow().
const WinResizeEdgeHalf = 4.;

/* ---------------------------------------------------------------*/
var ImguiWinMgrMixin =
{
    /**
    // Push a new ImGui window to add widgets to.
    // - A default window called "Debug" is automatically stacked at the
    //   beginning of every frame so you can use widgets without explicitly
    //   calling a Begin/End pair.
    // - Begin/End can be called multiple times during the frame with the
    //   same window name to append content.
    // - The window name is used as a unique identifier to preserve window
    //   information across frames (and save rudimentary information to the .ini file).
    //   You can use the "##" or "###" markers to use the same label with
    //   different id, or same id with different label. See documentation
    //   elsewhere.
    // - Return false when window is collapsed, so you can early out in your
    //   code. You always need to call End() even if false is returned.
    // - Passing 'ValRef p_open' displays a Close button on the upper-right
    //   corner of the window, the pointed value will be set to false when the
    //   button is pressed.
     */
    Begin(name, p_open=null, flags=0)
    {
        let g = this.guictx;
        const style = g.Style;
        console.assert(name.length);     // Window name required
        console.assert(g.FrameScopeActive);                  // Forgot to call ImGui::NewFrame()
        console.assert(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

        // Find or create
        // name of a window may not equal title (so we can change the title)
        let sname = name.split("##");
        name = sname[sname.length-1];
        let title = sname[0];
        let win = this.findWindowByName(name);
        const window_just_created = (win == null);
        if (window_just_created)
        {
            // Any condition flag will do since we are creating a new window here.
            let sz = (g.NextWindowData.SizeCond != 0) ?
                    g.NextWindowData.SizeVal : Vec2.Zero();
            win = this.createNewWindow(name, sz, flags);
        }

        // Automatically disable manual moving/resizing when NoInputs is set
        if ((flags & WindowFlags.NoInputs) == WindowFlags.NoInputs)
            flags |= WindowFlags.NoMove | WindowFlags.NoResize;

        if (flags & WindowFlags.NavFlattened)
            console.assert(flags & WindowFlags.ChildWindow);

        const current_frame = g.FrameCount;
        const first_begin_of_the_frame = (win.LastFrameActive != current_frame);

        // Update the Appearing flag
        // Not using !WasActive because the implicit "Debug" window would always
        // toggle off.on
        let window_just_activated_by_user = (win.LastFrameActive < current_frame - 1);
        const window_just_appearing_after_hidden_for_resize =
                (win.HiddenFramesCannotSkipItems > 0);
        if (flags & WindowFlags.Popup)
        {
            let popup_ref = g.OpenPopupStack[g.BeginPopupStack.length];
            window_just_activated_by_user |= (win.PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
            window_just_activated_by_user |= (win != popup_ref.Window);
        }
        win.Appearing = (window_just_activated_by_user ||
                         window_just_appearing_after_hidden_for_resize);
        if (win.Appearing)
            win.SetWindowConditionAllowFlags(CondFlags.Appearing, true);

        // Update Flags, LastFrameActive, BeginOrderXXX fields
        if (first_begin_of_the_frame)
        {
            win.Flags = flags;
            win.LastFrameActive = current_frame;
            win.BeginOrderWithinParent = 0;
            win.BeginOrderWithinContext = g.WindowsActiveCount++;
        }
        else
        {
            flags = win.Flags;
        }

        // Parent window is latched only on the first call to Begin() of the
        // frame, so further append-calls can be done from a different window stack
        let parent_window_in_stack = g.CurrentWindowStack.empty() ?
                                        null : g.CurrentWindowStack.back();
        let parent_window = first_begin_of_the_frame ?
                    ((flags & (WindowFlags.ChildWindow|WindowFlags.Popup)) ? parent_window_in_stack : null)
                    : win.ParentWindow;
        console.assert(parent_window != null || !(flags & WindowFlags.ChildWindow));

        // Add to stack
        // We intentionally set g.CurrentWindow to NULL to prevent usage until
        // when the viewport is set, then will call setCurrentWindow()
        g.CurrentWindowStack.push_back(win);
        g.CurrentWindow = null;
        this.checkStacksSize(win, true);
        if (flags & WindowFlags.Popup)
        {
            let popup_ref = g.OpenPopupStack[g.BeginPopupStack.length];
            popup_ref.Window = win;
            g.BeginPopupStack.push_back(popup_ref);
            win.PopupId = popup_ref.PopupId;
        }

        if (window_just_appearing_after_hidden_for_resize &&
            !(flags & WindowFlags.ChildWindow))
        {
            win.NavLastIds[0] = 0;
        }

        // Process SetNextWindow***() calls
        let window_pos_set_by_api = false;
        let window_size_x_set_by_api = false, window_size_y_set_by_api = false;
        if (g.NextWindowData.PosCond)
        {
            window_pos_set_by_api = (win.SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
            if (window_pos_set_by_api &&
                g.NextWindowData.PosPivotVal.LengthSq() > 0.00001)
            {
                // May be processed on the next frame if this is our first frame
                // and we are measuring size FIXME: Look into removing the
                // branch so everything can go through this same code path for
                // consistency.
                win.SetWindowPosVal.Copy(g.NextWindowData.PosVal);
                win.SetWindowPosPivot.Copy(g.NextWindowData.PosPivotVal);
                win.SetWindowPosAllowFlags &= ~(CondFlags.Once | CondFlags.FirstUseEver | CondFlags.Appearing);
            }
            else
            {
                win.SetWindowPos(g.NextWindowData.PosVal, g.NextWindowData.PosCond);
            }
        }
        if (g.NextWindowData.SizeCond)
        {
            window_size_x_set_by_api = (win.SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0
                                        && (g.NextWindowData.SizeVal.x > 0);
            window_size_y_set_by_api = (win.SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0
                                        && (g.NextWindowData.SizeVal.y > 0);
            win.SetWindowSize(g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
        }
        if(g.NextWindowData.ZIndexCond)
        {
            win.ZIndex = g.NextWindowData.ZIndex;
        }
        if (g.NextWindowData.ContentSizeCond)
        {
            // Adjust passed "client size" to become a "window size"
            win.SizeContentsExplicit.Copy(g.NextWindowData.ContentSizeVal);
            if (win.SizeContentsExplicit.y != 0)
                win.SizeContentsExplicit.y += win.TitleBarHeight() + win.MenuBarHeight();
        }
        else
        if (first_begin_of_the_frame)
        {
            win.SizeContentsExplicit = new Vec2(0, 0);
        }
        if (g.NextWindowData.CollapsedCond)
            win.SetWindowCollapsed(g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
        if (g.NextWindowData.FocusCond)
            this.FocusWindow(win);
        if (win.Appearing)
            win.SetWindowConditionAllowFlags(CondFlags.Appearing, false);

        // When reusing window again multiple times a frame, just append
        // content (don't need to setup again)
        if (first_begin_of_the_frame)
        {
            // Initialize
            const window_is_child_tooltip = (flags & WindowFlags.ChildWindow) &&
                                            (flags & WindowFlags.Tooltip);
            // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
            win.UpdateWindowParentAndRootLinks(flags, parent_window);

            win.Active = true;
            win.HasCloseButton = (p_open != null);
            win.ClipRect = Rect.FromXY(-Number.MAX_VALUE,-Number.MAX_VALUE,
                                       +Number.MAX_VALUE,+Number.MAX_VALUE);
            win.IDStack.resize(1);

            // Update stored window name when it changes (which can _only_
            // happen with the "###" operator, so the ID would stay unchanged).
            // The title bar always display the 'name' parameter, so we only
            // update the string storage if it needs to be visible to the
            // end-user elsewhere.
            let window_title_visible_elsewhere = false;
            if (g.NavWindowingList != null &&
                (win.Flags & WindowFlags.NoNavFocus) == 0)
            {
                // Window titles visible when using CTRL+TAB
                window_title_visible_elsewhere = true;
            }
            if (window_title_visible_elsewhere &&
                !window_just_created && name != win.Name)
            {
                win.Name = name;
            }

            // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

            // Update contents size from last frame for auto-fitting (or use explicit size)
            win.SizeContents = win.CalcSizeContents(win);
            if (win.HiddenFramesCanSkipItems > 0)
                win.HiddenFramesCanSkipItems--;
            if (win.HiddenFramesCannotSkipItems > 0)
                win.HiddenFramesCannotSkipItems--;

            // Hide new windows for one frame until they calculate their size
            if (window_just_created &&
                (!window_size_x_set_by_api || !window_size_y_set_by_api))
            {
                win.HiddenFramesCannotSkipItems = 1;
            }

            // Hide popup/tooltip window when re-opening while we measure size
            // (because we recycle the windows). We reset Size/SizeContents for
            // reappearing popups/tooltips early in this function, so further
            // code won't be tempted to use the old size.
            if (window_just_activated_by_user &&
                (flags & (WindowFlags.Popup | WindowFlags.Tooltip)) != 0)
            {
                win.HiddenFramesCannotSkipItems = 1;
                if (flags & WindowFlags.AlwaysAutoResize)
                {
                    if (!window_size_x_set_by_api)
                        win.Size.x = win.SizeFull.x = 0;
                    if (!window_size_y_set_by_api)
                        win.Size.y = win.SizeFull.y = 0;
                    win.SizeContents = new Vec2(0, 0);
                    // console.log("always resize");
                }
            }

            this.setCurrentWindow(win);

            // Lock border size and padding for the frame (so that altering
            // them doesn't cause inconsistencies)
            if (flags & WindowFlags.ChildWindow)
                win.WindowBorderSize = style.ChildBorderSize;
            else
                win.WindowBorderSize =
                    ((flags & (WindowFlags.Popup | WindowFlags.Tooltip)) &&
                     !(flags & WindowFlags.Modal)) ? style.PopupBorderSize :
                                                     style.WindowBorderSize;
            win.WindowPadding = style.WindowPadding;
            if ((flags & WindowFlags.ChildWindow) &&
                !(flags & (WindowFlags.AlwaysUseWindowPadding | WindowFlags.Popup)) &&
                    win.WindowBorderSize == 0)
            {
                win.WindowPadding = new Vec2(0, (flags & WindowFlags.MenuBar) ?
                                                    style.WindowPadding.y : 0);
            }
            win.DC.MenuBarOffset.x = Math.max(Math.max(win.WindowPadding.x,
                                                        style.ItemSpacing.x),
                                        g.NextWindowData.MenuBarOffsetMinVal.x);
            win.DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

            // Collapse window by double-clicking on title bar
            // At this point we don't have a clipping rectangle setup yet, so
            // we can use the title bar area for hit detection and drawing
            if (!(flags & WindowFlags.NoTitleBar) &&
                !(flags & WindowFlags.NoCollapse))
            {
                // We don't use a regular button+id to test for double-click on
                // title bar (mostly due to legacy reason, could be fixed), so
                // verify that we don't have items over the title bar.
                let title_bar_rect = win.TitleBarRect(); // no clone needed
                if (g.HoveredWindow == window && g.HoveredId == 0 &&
                    g.HoveredIdPreviousFrame == 0 &&
                    this.IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max)
                    && g.IO.MouseDoubleClicked[0])
                {
                    win.WantCollapseToggle = true;
                }
                if (win.WantCollapseToggle)
                {
                    win.Collapsed = !win.Collapsed;
                    this.MarkIniSettingsDirty(win);
                    this.FocusWindow(win);
                }
            }
            else
            {
                win.Collapsed = false;
            }
            win.WantCollapseToggle = false;

            // SIZE

            // Calculate auto-fit size, handle automatic resize
            const size_auto_fit = win.CalcSizeAutoFit(win.SizeContents);
            let size_full_modified = new Vec2(Number.MAX_VALUE, Number.MAX_VALUE);
            if ((flags & WindowFlags.AlwaysAutoResize) && !win.Collapsed)
            {
                // Using SetNextWindowSize() overrides WindowFlags.AlwaysAutoResize,
                // so it can be used on tooltips/popups, etc.
                if (!window_size_x_set_by_api)
                    win.SizeFull.x = size_full_modified.x = size_auto_fit.x;
                if (!window_size_y_set_by_api)
                    win.SizeFull.y = size_full_modified.y = size_auto_fit.y;
            }
            else
            if (win.AutoFitFramesX > 0 || win.AutoFitFramesY > 0)
            {
                // Auto-fit may only grow window during the first few frames
                // We still process initial auto-fit on collapsed windows to
                // get a window width, but otherwise don't honor
                // WindowFlags.AlwaysAutoResize when collapsed.
                if (!window_size_x_set_by_api && win.AutoFitFramesX > 0)
                {
                    win.SizeFull.x = size_full_modified.x =
                        win.AutoFitOnlyGrows ?
                        Math.max(win.SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
                }
                if (!window_size_y_set_by_api && win.AutoFitFramesY > 0)
                {
                    win.SizeFull.y = size_full_modified.y =
                        win.AutoFitOnlyGrows ?
                            Math.max(win.SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
                }
                if (!win.Collapsed)
                {
                    this.MarkIniSettingsDirty(win);
                }
            }

            // Apply minimum/maximum window size constraints and final size
            win.SizeFull = win.CalcSizeAfterConstraint(win.SizeFull);
            win.Size = win.Collapsed && !(flags & WindowFlags.ChildWindow) ?
                        win.TitleBarRect().GetSize() : win.SizeFull;

            // SCROLLBAR STATUS

            // Update scrollbar status (based on the Size that was effective
            // during last frame or the auto-resized Size).
            if (!win.Collapsed)
            {
                // When reading the current size we need to read it after size
                // constraints have been applied
                let size_x_for_scrollbars =
                    size_full_modified.x != Number.MAX_VALUE ?
                        win.SizeFull.x : win.SizeFullAtLastBegin.x;
                let size_y_for_scrollbars =
                    size_full_modified.y != Number.MAX_VALUE ?
                        win.SizeFull.y : win.SizeFullAtLastBegin.y;
                win.ScrollbarY = (flags & WindowFlags.AlwaysVerticalScrollbar) ||
                                 ((win.SizeContents.y > size_y_for_scrollbars) &&
                                  !(flags & WindowFlags.NoScrollbar));
                win.ScrollbarX = (flags & WindowFlags.AlwaysHorizontalScrollbar) ||
                                 ((win.SizeContents.x > size_x_for_scrollbars -
                                    (win.ScrollbarY ? style.ScrollbarSize : 0)) &&
                                  !(flags & WindowFlags.NoScrollbar) &&
                                   (flags & WindowFlags.HorizontalScrollbar));
                if (win.ScrollbarX && !win.ScrollbarY)
                {
                    win.ScrollbarY = (win.SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize)
                                        && !(flags & WindowFlags.NoScrollbar);
                }
                win.ScrollbarSizes = new Vec2(win.ScrollbarY ? style.ScrollbarSize : 0,
                                              win.ScrollbarX ? style.ScrollbarSize : 0);
            }

            // POSITION

            // Popup latch its initial position, will position itself when it
            // appears next frame
            if (window_just_activated_by_user)
            {
                win.AutoPosLastDirection = Dir.None;
                if ((flags & WindowFlags.Popup) != 0 && !window_pos_set_by_api)
                    win.Pos = g.BeginPopupStack.back().OpenPopupPos;
            }

            // Position child window
            if (flags & WindowFlags.ChildWindow)
            {
                console.assert(parent_window && parent_window.Active);
                win.BeginOrderWithinParent = parent_window.DC.ChildWindows.length;
                parent_window.DC.ChildWindows.push_back(win);
                if (!(flags & WindowFlags.Popup) &&
                    !window_pos_set_by_api && !window_is_child_tooltip)
                {
                    win.Pos.Copy(parent_window.DC.CursorPos);
                }
            }

            const window_pos_with_pivot = (win.SetWindowPosVal.x != Number.MAX_VALUE &&
                                            win.HiddenFramesCannotSkipItems == 0);
            if (window_pos_with_pivot)
            {
                // Position given a pivot (e.g. for centering)
                win.SetWindowPos(Vec2.Max(style.DisplaySafeAreaPadding,
                    Vec2.Subtract(win.SetWindowPosVal,
                            Vec2.Mult(win.SizeFull, win.SetWindowPosPivot))),
                    0);
            }
            else
            if ((flags & WindowFlags.ChildMenu) != 0)
                win.Pos = this.findBestWindowPosForPopup(win);
            else
            if ((flags & WindowFlags.Popup) != 0 &&
                !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
            {
                win.Pos = this.findBestWindowPosForPopup(win);
            }
            else
            if ((flags & WindowFlags.Tooltip) != 0 &&
                !window_pos_set_by_api && !window_is_child_tooltip)
            {
                win.Pos = this.findBestWindowPosForPopup(win);
            }

            // Clamp position so it stays visible
            // Ignore zero-sized display explicitly to avoid losing positions
            // if a window manager reports zero-sized window when initializing
            // or minimizing.
            let viewport_rect = this.getViewportRect();
            if (!window_pos_set_by_api &&
                !(flags & WindowFlags.ChildWindow) &&
                win.AutoFitFramesX <= 0 && win.AutoFitFramesY <= 0)
            {
                // Ignore zero-sized display explicitly to avoid losing
                // positions  if a window manager reports zero-sized window
                // when initializing or minimizing.
                if (g.IO.DisplaySize.x > 0 && g.IO.DisplaySize.y > 0)
                {
                    let clamp_padding = Vec2.Max(style.DisplayWindowPadding,
                                                 style.DisplaySafeAreaPadding);
                    win.ClampWindowRect(viewport_rect, clamp_padding);
                }
            }
            win.Pos = Vec2.Floor(win.Pos);

            // Lock window rounding for the frame (so that altering them
            // doesn't cause inconsistencies)
            win.WindowRounding = (flags & WindowFlags.ChildWindow) ?
                                        style.ChildRounding :
                                        ((flags & WindowFlags.Popup) &&
                                         !(flags & WindowFlags.Modal)) ?
                                            style.PopupRounding : style.WindowRounding;

            // Apply scrolling
            win.CalcNextScrollFromScrollTargetAndClamp(true);

            // Apply window focus (new and reactivated windows are moved to front)
            let want_focus = false;
            if (window_just_activated_by_user &&
                !(flags & WindowFlags.NoFocusOnAppearing))
            {
                if (flags & WindowFlags.Popup)
                    want_focus = true;
                else
                if ((flags & (WindowFlags.ChildWindow | WindowFlags.Tooltip)) == 0)
                    want_focus = true;
            }

            // Handle manual resize: Resize Grips, Borders, Gamepad
            let border_held = new ValRef(-1);
            let resize_grip_col = [ null, null, null, null ];
            const resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
            const grip_draw_size = Math.floor(Math.max(g.FontSize * 1.35,
                                    win.WindowRounding + 1 + g.FontSize*0.2));
            if (!win.Collapsed)
            {
                win.UpdateManualResize(size_auto_fit, border_held,
                                    resize_grip_count, resize_grip_col);
            }
            win.ResizeBorderHeld = border_held.get();

            // Default item width. Make it proportional to window size if
            // window manually resizes
            if (win.Size.x > 0 && !(flags & WindowFlags.Tooltip) &&
                !(flags & WindowFlags.AlwaysAutoResize))
            {
                win.ItemWidthDefault = Math.floor(win.Size.x * 0.65);
            }
            else
                win.ItemWidthDefault = Math.floor(g.FontSize * 16);

            // DRAWING

            // Setup draw list and outer clipping rectangle
            win.DrawList.Clear();
            win.DrawList.Flags = (g.Style.AntiAliasedLines ? DrawListFlags.AntiAliasedLines : 0) |
                                 (g.Style.AntiAliasedFill ? DrawListFlags.AntiAliasedFill : 0);
            // win.DrawList.PushTextureID(g.Font.ContainerAtlas.TexID);
            if(flags & WindowFlags.Tooltip) // dbadb.. native does this in flatting drawlists
                win.DrawList.BeginLayer(1);
            if ((flags & WindowFlags.ChildWindow) &&
                !(flags & WindowFlags.Popup) && !window_is_child_tooltip)
            {
                this.PushClipRect(parent_window.ClipRect.Min,
                                  parent_window.ClipRect.Max, true);
            }
            else
            {
                this.PushClipRect(viewport_rect.Min, viewport_rect.Max, true);
            }

            // Draw modal window background (darkens what is behind them,
            //  all viewports)
            const dim_bg_for_modal = (flags & WindowFlags.Modal) &&
                                        win == this.getFrontMostPopupModal() &&
                                        win.HiddenFramesCannotSkipItems <= 0;
            const dim_bg_for_window_list = g.NavWindowingTargetAnim &&
                                    (win == g.NavWindowingTargetAnim.RootWindow);
            if (dim_bg_for_modal || dim_bg_for_window_list)
            {
                const dim_bg_col = style.GetColor(dim_bg_for_modal ?
                            "ModalWindowDimBg" : "NavWindowingDimBg",
                            g.DimBgRatio);
                win.DrawList.AddRectFilled(viewport_rect.Min, viewport_rect.Max,
                                            dim_bg_col);
            }

            // Draw navigation selection/windowing rectangle background
            if (dim_bg_for_window_list && win == g.NavWindowingTargetAnim)
            {
                let bb = win.Rect();
                bb.Expand(g.FontSize);
                // Avoid drawing if the window covers all the viewport anyway
                if (!bb.Contains(viewport_rect))
                {
                    win.DrawList.AddRectFilled(bb.Min, bb.Max,
                            style.GetColor("NavWindowingHighlight",
                                            g.NavWindowingHighlightAlpha * 0.25),
                                           g.Style.WindowRounding);
                }
            }

            // Draw window + handle manual resize
            // As we highlight the title bar when want_focus is set, multiple
            // reappearing windows will have have their title bar highlighted
            // on their reappearing frame.
            const window_rounding = win.WindowRounding;
            const window_border_size = win.WindowBorderSize;
            const window_to_highlight = g.NavWindowingTarget ?
                                    g.NavWindowingTarget : g.NavWindow;
            const title_bar_is_highlight = want_focus ||
                (window_to_highlight &&
                    win.RootWindowForTitleBarHighlight ==
                    window_to_highlight.RootWindowForTitleBarHighlight);
            const title_bar_rect = win.TitleBarRect();
            if (win.Collapsed)
            {
                // Title bar only
                let backup_border_size = style.FrameBorderSize;
                g.Style.FrameBorderSize = win.WindowBorderSize;
                let title_bar_col = style.GetColor(
                    (title_bar_is_highlight && !g.NavDisableHighlight) ?
                        "TitleBgActive" : "TitleBgCollapsed");
                this.renderFrame(title_bar_rect.Min, title_bar_rect.Max,
                                title_bar_col, true, window_rounding);
                g.Style.FrameBorderSize = backup_border_size;
            }
            else
            {
                // Window background
                if (!(flags & WindowFlags.NoBackground))
                {
                    let bg_col = style.GetColor(this.getWindowBgColorFromFlags(flags));
                    let alpha = 1;
                    if (g.NextWindowData.BgAlphaCond != 0)
                        alpha = g.NextWindowData.BgAlphaVal;
                    if (alpha != 1)
                    {
                        bg_col = bg_col.Clone();
                        bg_col.a = alpha;
                    }
                    let min = Vec2.AddXY(win.Pos, 0, win.TitleBarHeight());
                    let max = Vec2.Add(win.Pos, win.Size);
                    win.DrawList.AddRectFilled(min, max, bg_col, window_rounding,
                                    (flags & WindowFlags.NoTitleBar) ?
                                        CornerFlags.All : CornerFlags.Bot);
                }
                g.NextWindowData.BgAlphaCond = 0;

                // Title bar
                if (!(flags & WindowFlags.NoTitleBar))
                {
                    let title_bar_col = style.GetColor(title_bar_is_highlight ?
                                                    "TitleBgActive" : "TitleBg");
                    win.DrawList.AddRectFilled(title_bar_rect.Min, title_bar_rect.Max,
                                    title_bar_col, window_rounding,
                                    CornerFlags.Top);
                }

                // Menu bar
                if (flags & WindowFlags.MenuBar)
                {
                    let menu_bar_rect = win.MenuBarRect();
                    // Soft clipping, in particular child window don't have
                    // minimum size covering the menu bar so this is useful for them.
                    menu_bar_rect.ClipWith(win.Rect());
                    win.DrawList.AddRectFilled(
                        Vec2.AddXY(menu_bar_rect.Min,
                                   window_border_size,0),
                        Vec2.AddXY(menu_bar_rect.Max, -window_border_size, 0),
                        style.GetColor("MenuBarBg"),
                        (flags & WindowFlags.NoTitleBar) ? window_rounding : 0,
                        CornerFlags.Top);
                    if (style.FrameBorderSize > 0 &&
                        menu_bar_rect.Max.y < win.Pos.y + win.Size.y)
                    {
                        win.DrawList.AddLine(menu_bar_rect.GetBL(),
                                    menu_bar_rect.GetBR(),
                                    style.GetColor("Border"),
                                    style.FrameBorderSize);
                    }
                }

                // Scrollbars
                if (win.ScrollbarX)
                    this.scrollbar(Axis.X);
                if (win.ScrollbarY)
                    this.scrollbar(Axis.Y);

                // Render resize grips (after their input handling so we don't
                // have a frame of latency)
                if (!(flags & WindowFlags.NoResize))
                {
                    win.RenderResizeGrips(resize_grip_col, resize_grip_count,
                        grip_draw_size, window_border_size, window_rounding);
                }

                // Borders
                win.RenderOuterBorders();
            } // end !Collapsed

            // Draw navigation selection/windowing rectangle border
            if (g.NavWindowingTargetAnim == win)
            {
                let rounding = Math.max(win.WindowRounding, g.Style.WindowRounding);
                let bb = win.Rect().Expand(g.FontSize);
                // If a window fits the entire viewport, adjust its highlight inward
                if (bb.Contains(viewport_rect))
                {
                    bb.Expand(-g.FontSize - 1);
                    rounding = win.WindowRounding;
                }
                win.DrawList.AddRect(bb.Min, bb.Max,
                    style.GetColor("NavWindowingHighlight", g.NavWindowingHighlightAlpha),
                    rounding, ~0, 3);
            }

            // Store a backup of SizeFull which we will use next frame to decide
            // if we need scrollbars.
            win.SizeFullAtLastBegin = win.SizeFull;

            // Update various regions. Variables they depends on are set above
            // in this function. FIXME: win.ContentsRegionRect.Max is currently
            // very misleading / partly faulty, but some BeginChild() patterns
            // relies on it.
            win.ContentsRegionRect.Min.x = win.Pos.x - win.Scroll.x + win.WindowPadding.x;
            win.ContentsRegionRect.Min.y = win.Pos.y - win.Scroll.y + win.WindowPadding.y
                                            + win.TitleBarHeight() + win.MenuBarHeight();
            win.ContentsRegionRect.Max.x = win.Pos.x - win.Scroll.x - win.WindowPadding.x
                                            + (win.SizeContentsExplicit.x != 0 ?
                                                win.SizeContentsExplicit.x :
                                                (win.Size.x - win.ScrollbarSizes.x));
            win.ContentsRegionRect.Max.y = win.Pos.y - win.Scroll.y - win.WindowPadding.y
                                            + (win.SizeContentsExplicit.y != 0 ?
                                                win.SizeContentsExplicit.y :
                                                (win.Size.y - win.ScrollbarSizes.y));
            if(win.ContentsRegionRect.IsNaN())
            {
                console.assert("hey!");
            }

            // Setup drawing context
            // (NB: That term "drawing context / DC" lost its meaning a long
            // time ago. Initially was meant to hold transient data only.
            // Nowadays difference between win. and win.DC. is dubious.)
            win.DC.Indent.x = 0 + win.WindowPadding.x - win.Scroll.x;
            win.DC.GroupOffset.x = 0;
            win.DC.ColumnsOffset.x = 0;
            win.DC.CursorStartPos = Vec2.AddXY(
                        win.Pos, win.DC.Indent.x + win.DC.ColumnsOffset.x,
                        win.TitleBarHeight() + win.MenuBarHeight() +
                        win.WindowPadding.y - win.Scroll.y);
            win.DC.CursorPos.Copy(win.DC.CursorStartPos);
            win.DC.CursorPosPrevLine.Copy(win.DC.CursorPos);
            win.DC.CursorMaxPos.Copy(win.DC.CursorStartPos);
            win.DC.CurrentLineHeight = 0;
            win.DC.CurrentLineHeightMax = 0;
            win.DC.PrevLineHeight = 0;
            win.DC.PrevLineHeightMax = 0;
            win.DC.CurrentLineTextBaseOffset = win.DC.PrevLineTextBaseOffset = 0;
            win.DC.NavHideHighlightOneFrame = false;
            win.DC.NavHasScroll = (this.getWindowScrollMaxY(win) > 0);
            win.DC.NavLayerActiveMask = win.DC.NavLayerActiveMaskNext;
            win.DC.NavLayerActiveMaskNext = 0x00;
            win.DC.MenuBarAppending = false;
            win.DC.ChildWindows.resize(0);
            win.DC.LayoutType = LayoutType.Vertical;
            win.DC.ParentLayoutType = parent_window ? parent_window.DC.LayoutType :
                                            LayoutType.Vertical;
            win.DC.FocusCounterAll = win.DC.FocusCounterTab = -1;
            win.DC.ItemFlags = parent_window ? parent_window.DC.ItemFlags :
                                                ItemFlags.Default;
            win.DC.ItemWidth = win.ItemWidthDefault;
            win.DC.TextWrapPos = -1; // disabled
            win.DC.ItemFlagsStack.resize(0);
            win.DC.ItemWidthStack.resize(0);
            win.DC.TextWrapPosStack.resize(0);
            win.DC.CurrentColumns = null;
            win.DC.TreeDepth = 0;
            win.DC.TreeDepthMayJumpToParentOnPop = 0x00;
            win.DC.StateStorage = win.StateStorage;
            win.DC.GroupStack.resize(0);
            win.MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

            if ((flags & WindowFlags.ChildWindow) &&
                (win.DC.ItemFlags != parent_window.DC.ItemFlags))
            {
                win.DC.ItemFlags = parent_window.DC.ItemFlags;
                win.DC.ItemFlagsStack.push_back(win.DC.ItemFlags);
            }

            if (win.AutoFitFramesX > 0)
                win.AutoFitFramesX--;
            if (win.AutoFitFramesY > 0)
                win.AutoFitFramesY--;

            // Apply focus (we need to call FocusWindow() AFTER setting
            // DC.CursorStartPos so our initial navigation reference rectangle
            // can start around there)
            if (want_focus)
            {
                this.FocusWindow(win);
                this.navInitWindow(win, false);
            }

            // Title bar
            if (!(flags & WindowFlags.NoTitleBar))
            {
                // Close & collapse button are on layer 1 (same as menus) and
                // don't default focus
                const item_flags_backup = win.DC.ItemFlags;
                win.DC.ItemFlags |= ItemFlags.NoNavDefaultFocus;
                win.DC.NavLayerCurrent = NavLayer.Menu;
                win.DC.NavLayerCurrentMask = (1 << NavLayer.Menu);

                // Collapse button
                if (!(flags & WindowFlags.NoCollapse))
                {
                    if (this.CollapseButton(win.GetID("#COLLAPSE"), win.Pos))
                    {
                        // Defer collapsing to next frame as we are too far in
                        // the Begin() function
                        win.WantCollapseToggle = true;
                    }
                }

                // Close button
                if (p_open != null)
                {
                    const rad = g.FontSize * 0.5;
                    if (this.CloseButton(win.GetID("#CLOSE"),
                                new Vec2(win.Pos.x + win.Size.x - style.FramePadding.x - rad,
                                         win.Pos.y + style.FramePadding.y + rad),
                                         rad + 1))
                    {
                        p_open.set(false);
                        this.MarkIniSettingsDirty();
                    }
                }

                win.DC.NavLayerCurrent = NavLayer.Main;
                win.DC.NavLayerCurrentMask = (1 << NavLayer.Main);
                win.DC.ItemFlags = item_flags_backup;

                // Title bar text (with: horizontal alignment, avoiding
                // collapse/close button, optional "unsaved document" marker)
                // FIXME: Refactor text alignment facilities along with
                // RenderText helpers, this is too much code..
                const UNSAVED_DOCUMENT_MARKER = "*";
                let marker_size_x = (flags & WindowFlags.UnsavedDocument) ?
                    this.CalcTextSize(UNSAVED_DOCUMENT_MARKER, false).x : 0;
                let text_size = Vec2.AddXY(this.CalcTextSize(title, true),
                                           marker_size_x, 0);
                let text_r = title_bar_rect.Clone();
                let pad_left = (flags & WindowFlags.NoCollapse) ?
                    style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
                let pad_right = (p_open == null) ? style.FramePadding.x :
                        (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
                if (style.WindowTitleAlign.x > 0)
                    pad_right = Vec1.Lerp(pad_right, pad_left, style.WindowTitleAlign.x);
                text_r.Min.x += pad_left;
                text_r.Max.x -= pad_right;
                let clip_rect = text_r.Clone();
                // Match the size of CloseButton()
                clip_rect.Max.x = win.Pos.x + win.Size.x -
                    (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x);
                this.renderTextClipped(text_r.Min, text_r.Max, title, text_size,
                                    style.WindowTitleAlign, clip_rect);
                if (flags & WindowFlags.UnsavedDocument)
                {
                    let x = Math.max(text_r.Min.x,
                        text_r.Min.x +
                        (text_r.GetWidth()-text_size.x)*style.WindowTitleAlign.x) +
                        text_size.x;
                    let marker_pos = Vec2.AddXY(new Vec2(x, text_r.Min.y),
                                                2 - marker_size_x, 0);
                    let off = new Vec2(0, Math.floor(-g.FontSize * 0.25));
                    this.renderTextClipped(Vec2.Add(marker_pos, off),
                                           Vec2.Add(text_r.Max, off),
                                        UNSAVED_DOCUMENT_MARKER,  null,
                                        new Vec2(0, style.WindowTitleAlign.y),
                                        clip_rect);
                }
            } // end TitleBar

            // Save clipped aabb so we can access it in constant-time in
            // FindHoveredWindow()
            win.OuterRectClipped = win.Rect();
            win.OuterRectClipped.ClipWith(win.ClipRect);

            // Pressing CTRL+C while holding on a window copy its content to the
            // clipboard This works but 1. doesn't handle multiple Begin/End
            // pairs, 2. recursing into another Begin/End pair - so we need to
            // work that out and add better logging scope.
            // Maybe we can support CTRL+C on every element?
            /*
            if (g.ActiveId == move_id)
                if (g.IO.KeyCtrl && this.isKeyPressedMap(Key.C))
                    LogToClipboard();
            */

            // Inner rectangle
            // We set this up after processing the resize grip so that our clip
            // rectangle doesn't lag by a frame. Note that if our window is
            // collapsed we will end up with an inverted (~null) clipping
            // rectangle which is the correct behavior.
            win.InnerMainRect.Min.x = title_bar_rect.Min.x + win.WindowBorderSize;
            win.InnerMainRect.Min.y = title_bar_rect.Max.y +
                        win.MenuBarHeight() + (((flags & WindowFlags.MenuBar) ||
                                                !(flags & WindowFlags.NoTitleBar)) ?
                            style.FrameBorderSize : win.WindowBorderSize);
            win.InnerMainRect.Max.x = win.Pos.x + win.Size.x -
                            win.ScrollbarSizes.x - win.WindowBorderSize;
            win.InnerMainRect.Max.y = win.Pos.y + win.Size.y -
                            win.ScrollbarSizes.y - win.WindowBorderSize;
            //win.DrawList.AddRect(win.InnerRect.Min, win.InnerRect.Max, IM_COL32_WHITE);

            // Inner clipping rectangle
            // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
            win.InnerClipRect.Min.x = Math.floor(0.5 + win.InnerMainRect.Min.x +
                    Math.max(0, Math.floor(win.WindowPadding.x*0.5 - win.WindowBorderSize)));
            win.InnerClipRect.Min.y = Math.floor(0.5 + win.InnerMainRect.Min.y);
            win.InnerClipRect.Max.x = Math.floor(0.5 + win.InnerMainRect.Max.x -
                    Math.max(0, Math.floor(win.WindowPadding.x*0.5 - win.WindowBorderSize)));
            win.InnerClipRect.Max.y = Math.floor(0.5 + win.InnerMainRect.Max.y);

            // We fill last item data based on Title Bar/Tab, in order for
            // IsItemHovered() and IsItemActive() to be usable after Begin().
            // This is useful to allow creating context menus on title bar only,
            // etc.
            win.DC.LastItemId = win.MoveId;
            win.DC.LastItemStatusFlags = this.IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ?
                                                ItemStatusFlags.HoveredRect : 0;
            win.DC.LastItemRect = title_bar_rect;
        }
        else // not first begin of frame
        {
            // Append
            this.setCurrentWindow(win);
        }

        this.PushClipRect(win.InnerClipRect.Min, win.InnerClipRect.Max, true);

        // Clear 'accessed' flag last thing (After PushClipRect which will set
        // the flag. We want the flag to stay false when the default "Debug"
        // window is unused)
        if (first_begin_of_the_frame)
            win.WriteAccessed = false;

        win.BeginCount++;
        g.NextWindowData.Clear();

        if (flags & WindowFlags.ChildWindow)
        {
            // Child window can be out of sight and have "negative" clip windows.
            // Mark them as collapsed so commands are skipped earlier (we can't
            // manually collapse them because they have no title bar).
            console.assert((flags & WindowFlags.NoTitleBar) != 0);
            if (!(flags & WindowFlags.AlwaysAutoResize) &&
                    win.AutoFitFramesX <= 0 && win.AutoFitFramesY <= 0)
            {
                if (win.OuterRectClipped.Min.x >= win.OuterRectClipped.Max.x ||
                    win.OuterRectClipped.Min.y >= win.OuterRectClipped.Max.y)
                {
                    win.HiddenFramesCanSkipItems = 1;
                }
            }

            // Completely hide along with parent or if parent is collapsed
            if (parent_window && (parent_window.Collapsed || parent_window.Hidden))
                win.HiddenFramesCanSkipItems = 1;
        }

        // Don't render if style alpha is 0.0 at the time of Begin(). This is
        // arbitrary and inconsistent but has been there for a long while (may
        // remove at some point)
        if (style.Alpha <= 0)
            win.HiddenFramesCanSkipItems = 1;

        // Update the Hidden flag
        win.Hidden = (win.HiddenFramesCanSkipItems > 0) ||
                     (win.HiddenFramesCannotSkipItems > 0);
        // Hidden applies to popups... p_open is currently the responsibility
        // of each window.
        //if(win.Hidden) console.log(win.Name + " is hidden");

        // Update the SkipItems flag, used to early out of all items functions
        // (no layout required)
        let skip_items = false;
        if (win.Collapsed || !win.Active || win.Hidden)
        {
            if (win.AutoFitFramesX <= 0 && win.AutoFitFramesY <= 0 &&
                win.HiddenFramesCannotSkipItems <= 0)
            {
                skip_items = true;
            }
        }
        win.SkipItems = skip_items;

        return !skip_items;
    },

    End()
    {
        let g = this.guictx;

        if (g.CurrentWindowStack.length <= 1 && g.FrameScopePushedImplicitWindow)
        {
            console.assert(g.CurrentWindowStack.length > 1, "Calling End() too many times!");
            return; // FIXME-ERRORHANDLING
        }
        console.assert(g.CurrentWindowStack.length > 0);

        let win = g.CurrentWindow;

        if (win.DC.CurrentColumns != null)
            this.endColumns();
        this.PopClipRect();   // Inner window clip rectangle

        // Stop logging
        if (!(win.Flags & WindowFlags.ChildWindow))    // FIXME: add more options for scope of logging
            this.LogFinish();

        // Pop from window stack
        g.CurrentWindowStack.pop_back();
        if (win.Flags & WindowFlags.Popup)
            g.BeginPopupStack.pop_back();
        if (win.flags & WindowFlags.Tooltip) // dbadb
            win.DrawList.EndLayer();
        this.checkStacksSize(win, false);
        this.setCurrentWindow(g.CurrentWindowStack.empty() ? null :
                            g.CurrentWindowStack.back());
    },

    /**
     * Child Windows
     * - Use child windows to begin into a self-contained independent
     *   scrolling/clipping regions within a host window. Child windows can
     *   embed their own child.
     * - For each independent axis of 'size': ==0.0f: use remaining host
     *   window size / >0.0f: fixed size / <0.0f: use remaining window
     *   size minus abs(size) / Each axis can use a different mode, e.g.
     *   Rect(0,400).
     * BeginChild() returns false to indicate the window is collapsed or
     *   fully clipped, so you may early out and omit submitting anything
     *    to the window.
     * Always call a matching EndChild() for each BeginChild() call,
     *   regardless of its return value.
     */
    BeginChild(strOrID, size_arg=Vec2.Zero(), border=false, flags=0)
    {
        let id;
        let name;
        if(typeof(strOrID) == "string")
        {
            name = strOrID;
            id = this.getCurrentWindow().GetID(strOrID);
        }
        else
        {
            name = null;
            id = strOrID;
        }
        return this.beginChildEx(name, id, size_arg, border, flags);
    },

    beginChildEx(name, id, size_arg, border, flags)
    {
        let g = this.guictx;
        let parent_window = g.CurrentWindow;

        flags |= WindowFlags.NoTitleBar|WindowFlags.NoResize|
                 WindowFlags.NoSavedSettings|WindowFlags.ChildWindow;
        flags |= (parent_window.Flags & WindowFlags.NoMove);  // Inherit the NoMove flag

        // Size
        const content_avail = this.GetContentRegionAvail();
        let size = Vec2.Floor(size_arg);
        const auto_fit_axes = ((size.x == 0) ? (1 << Axis.X) : 0x00) |
                              ((size.y == 0) ? (1 << Axis.Y) : 0x00);
        // Arbitrary minimum child size (0 causing too much issues)
        if (size.x <= 0.)
            size.x = Math.max(content_avail.x + size.x, 4);
        if (size.y <= 0)
            size.y = Math.max(content_avail.y + size.y, 4);
        this.SetNextWindowSize(size);

        // Build up name. If you need to append to a same child from multiple
        // location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
        let title;
        if (name)
            title = `${parent_window.Name}/${name}_${id&0xFFFFF}`;
        else
            title = `${parent_window.Name}/${id&0xFFFFF}`;

        const backup_border_size = g.Style.ChildBorderSize;
        if (!border)
            g.Style.ChildBorderSize = 0.;
        let ret = this.Begin(title, null, flags);
        g.Style.ChildBorderSize = backup_border_size;

        let child_window = g.CurrentWindow;
        child_window.ChildId = id;
        child_window.AutoFitChildAxises = auto_fit_axes;

        // Set the cursor to handle case where the user called
        // SetNextWindowPos()+BeginChild() manually. While this is not
        // really documented/defined, it seems that the expected thing to do.
        if (child_window.BeginCount == 1)
            parent_window.DC.CursorPos.Copy(child_window.Pos);

        // Process navigation-in immediately so NavInit can run on first frame
        if (g.NavActivateId == id && !(flags & WindowFlags.NavFlattened) &&
            (child_window.DC.NavLayerActiveMask != 0 || child_window.DC.NavHasScroll))
        {
            this.FocusWindow(child_window);
            this.navInitWindow(child_window, false);
            // Steal ActiveId with a dummy id so that key-press won't activate
            // child item
            this.setActiveID(id+1, child_window);
            g.ActiveIdSource = InputSource.Nav;
        }
        return ret;
    },

    EndChild()
    {
        let g = this.guictx;
        let win = g.CurrentWindow;

        console.assert(win.Flags & WindowFlags.ChildWindow, "Mismatched BeginChild()/EndChild()");
        if (win.BeginCount > 1)
        {
            this.End();
        }
        else
        {
            let sz = win.Size.Clone();
            // Arbitrary minimum zero-ish child size of 4 causes less trouble
            // than a 0
            if (win.AutoFitChildAxises & (1 << Axis.X))
                sz.x = Math.max(4, sz.x);
            if (win.AutoFitChildAxises & (1 << Axis.Y))
                sz.y = Math.max(4, sz.y);
            this.End();

            let parent_window = g.CurrentWindow;
            let bb = new Rect(parent_window.DC.CursorPos,
                            Vec2.Add(parent_window.DC.CursorPos, sz));
            this.itemSize(sz);
            if ((win.DC.NavLayerActiveMask != 0 ||
                 win.DC.NavHasScroll) &&
                 !(win.Flags & WindowFlags.NavFlattened))
            {
                this.itemAdd(bb, win.ChildId);
                this.renderNavHighlight(bb, win.ChildId);

                // When browsing a window that has no activable items (scroll
                // only) we keep a highlight on the child
                if (win.DC.NavLayerActiveMask == 0 && win == g.NavWindow)
                {
                    this.renderNavHighlight(
                        new Rect(Vec2.SubtractXY(bb.Min, 2,2),
                                 Vec2.AddXY(bb.Max, 2,2)),
                        g.NavId, NavHighlightFlags.TypeThin);
                }
            }
            else
            {
                // Not navigable into
                this.itemAdd(bb, 0);
            }
        }
    },

    // helper to create a child window / scrolling region that looks like a
    // normal widget frame
    BeginChildFrame(id, size, extra_flags = 0)
    {
        let g = this.guictx;
        const style = g.Style;
        this.PushStyleColor("ChildBg", style.GetColor("FrameBg"));
        this.PushStyleVar("ChildRounding", style.FrameRounding);
        this.PushStyleVar("ChildBorderSize", style.FrameBorderSize);
        this.PushStyleVar("WindowPadding", style.FramePadding);
        let ret = this.BeginChild(id, size, true, WindowFlags.NoMove |
                            WindowFlags.AlwaysUseWindowPadding | extra_flags);
        this.PopStyleVar(3);
        this.PopStyleColor();
        return ret;
    },

    // always call EndChildFrame() regardless of BeginChildFrame() return
    // values (which indicates a collapsed/clipped window)
    EndChildFrame()
    {
        this.EndChild();
    },

    // Windows Utilities -------
    // - "current window" = the window we are appending into while inside a
    //  Begin()/End() block. "next window" = next window we will Begin() into.
    IsWindowAppearing()
    {
        let win = this.guictx.CurrentWindow;
        return win.Appearing;
    },

    IsWindowCollapsed()
    {
        let win = this.guictx.CurrentWindow;
        return win.Collapsed;
    },

    IsWindowFocused(flags)
    {
        let g = this.guictx;
        if (flags & FocusedFlags.AnyWindow)
            return g.NavWindow != null;

        console.assert(g.CurrentWindow);     // Not inside a Begin()/End()
        switch (flags & (FocusedFlags.RootWindow | FocusedFlags.ChildWindows))
        {
        case FocusedFlags.RootWindow | FocusedFlags.ChildWindows:
            return g.NavWindow && g.NavWindow.RootWindow == g.CurrentWindow.RootWindow;
        case FocusedFlags.RootWindow:
            return g.NavWindow == g.CurrentWindow.RootWindow;
        case FocusedFlags.ChildWindows:
            return g.NavWindow && this.isWindowChildOf(g.NavWindow, g.CurrentWindow);
        default:
            return g.NavWindow == g.CurrentWindow;
        }
    },

    IsWindowHovered(flags)
    {
        // Flags not supported by this function
        console.assert((flags & HoveredFlags.AllowWhenOverlapped) == 0);
        let g = this.guictx;
        if (flags & HoveredFlags.AnyWindow)
        {
            if (g.HoveredWindow == null)
                return false;
        }
        else
        switch (flags & (HoveredFlags.RootWindow | HoveredFlags.ChildWindows))
        {
        case HoveredFlags.RootWindow | HoveredFlags.ChildWindows:
            if (g.HoveredRootWindow != g.CurrentWindow.RootWindow)
                return false;
            break;
        case HoveredFlags.RootWindow:
            if (g.HoveredWindow != g.CurrentWindow.RootWindow)
                return false;
            break;
        case HoveredFlags.ChildWindows:
            if (g.HoveredWindow == null ||
                !this.isWindowChildOf(g.HoveredWindow, g.CurrentWindow))
            {
                return false;
            }
            break;
        default:
            if (g.HoveredWindow != g.CurrentWindow)
                return false;
            break;
        }

        if (!this.isWindowContentHoverable(g.HoveredWindow, flags))
            return false;
        if (!(flags & HoveredFlags.AllowWhenBlockedByActiveItem))
        {
            if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap &&
                g.ActiveId != g.HoveredWindow.MoveId)
            {
                return false;
            }
        }
        return true;
    },

    GetWindowDrawList()
    {
        let win = this.guictx.CurrentWindow;
        return win.DrawList;
    },

    GetWindowPos()
    {
        let win = this.guictx.CurrentWindow;
        return win.Pos;
    },

    GetWindowSize()
    {
        let win = this.guictx.CurrentWindow;
        return win.Size;
    },

    GetWindowWidth()
    {
        let win = this.guictx.CurrentWindow;
        return win.Size.x;
    },

    GetWindowHeight()
    {
        let win = this.guictx.CurrentWindow;
        return win.Size.y;
    },

    GetWindowScroll()
    {
        let win = this.guictx.CurrentWindow;
        return win.Scroll;
    },

    GetContentRegionMax()
    {
        let win = this.guictx.CurrentWindow;
        let mx = Vec2.Subtract(win.ContentsRegionRect.Max, win.Pos);
        if (win.DC.CurrentColumns)
        {
            mx.x = this.GetColumnOffset(win.DC.CurrentColumns.Current+1) -
                        win.WindowPadding.x;
        }
        return mx; // Vec2
    },

    // Absolute coordinate. Saner. This is not exposed until we finishing
    // refactoring work rect features.
    getContentRegionMaxScreen()
    {
        let win = this.guictx.CurrentWindow;
        let mx = win.ContentsRegionRect.Max.Clone();
        if (win.DC.CurrentColumns)
        {
            mx.x = win.Pos.x
                    + this.GetColumnOffset(win.DC.CurrentColumns.Current + 1)
                    - win.WindowPadding.x;
        }
        return mx;
    },

    GetContentRegionAvail()
    {
        let win = this.guictx.CurrentWindow;
        return Vec2.Subtract(this.GetContentRegionMax(),
                        Vec2.Subtract(win.DC.CursorPos, win.Pos));
    },

    GetContentRegionAvailWidth()
    {
        return this.GetContentRegionAvail().x;
    },

    GetContentRegionAvailHeight()
    {
        return this.GetContentRegionAvail().y;
    },

    GetWindowContentRegionMin()
    {
        let win = this.guictx.CurrentWindow;
        return Vec2.Subtract(win.ContentsRegionRect.Min, win.Pos);
    },

    /**
     * content boundaries max (roughly (0,0)+Size-Scroll) where Size
     * can be override with SetNextWindowContentSize(), in window coordinates
     */
    GetWindowContentRegionMax()
    {
        let win = this.guictx.CurrentWindow;
        return Vec2.Subtract(win.ContentsRegionRect.Max, win.Pos);
    },

    GetWindowContentRegionWidth()
    {
        let win = this.guictx.CurrentWindow;
        return win.ContentsRegionRect.GetWidth();
    },

    GetWindowContentRegionHeight()
    {
        let win = this.guictx.CurrentWindow;
        return win.ContentsRegionRect.GetHeight();
    },

    /**
     * set next window position. call before Begin(). use pivot=(0.5f,0.5f) to
     * center on given point, etc.
     */
    SetNextWindowPos(pos, cond, pivot)
    {
        let g = this.guictx;
        g.NextWindowData.PosVal = pos;
        g.NextWindowData.PosCond = cond ? cond : CondFlags.Always;
        g.NextWindowData.PosPivotVal = pivot ? pivot : Vec2.Zero();
    },

    // Set next window size. Set axis to 0.0f to force an auto-fit on that axis.
    // Call before Begin()
    SetNextWindowSize(size, cond=0)
    {
        let g = this.guictx;
        g.NextWindowData.SizeVal.Copy(size);
        g.NextWindowData.SizeCond = cond ? cond : CondFlags.Always;
    },

    SetNextWindowZIndex(zindex, cond=0)
    {
        let g = this.guictx;
        g.NextWindowData.ZIndex = zindex;
        g.NextWindowData.ZIndexCond = cond ? cond : CondFlags.Always;
    },

    // Set next window size limits. Use -1,-1 on either X/Y axis to preserve the
    // current size. Use callback to apply non-trivial programmatic constraints.
    SetNextWindowSizeConstraints(size_min, size_max, custom_callback, custom_callback_data)
    {
        let g = this.guictx;
        g.NextWindowData.SizeConstraintCond = CondFlags.Always;
        g.NextWindowData.SizeConstraintRect = new Rect(size_min, size_max);
        if(size_min.IsNaN() || size_max.IsNaN())
        {
            console.assert(0, "bogus constraints");
        }
        g.NextWindowData.SizeCallback = custom_callback;
        g.NextWindowData.SizeCallbackUserData = custom_callback_data;
    },

    // Set next window content size (~ enforce the range of scrollbars). Not
    // including window decorations (title bar, menu bar, etc.). Set an axis
    // to 0.0f to leave it automatic. Call before Begin()
    SetNextWindowContentSize(size)
    {
        // in Begin() we will add the size of window decorations (title bar,
        // menu etc.) to that to form a SizeContents value.
        let g = this.guictx;
        g.NextWindowData.ContentSizeVal = size;
        g.NextWindowData.ContentSizeCond = CondFlags.Always;
    },

    // set next window collapsed state. call before Begin()
    SetNextWindowCollapsed(collapsed, cond=0)
    {
        let g = this.guictx;
        g.NextWindowData.CollapsedVal = collapsed;
        g.NextWindowData.CollapsedCond = cond ? cond : CondFlags.Always;
    },

    // Set next window to be focused / front-most. Call before Begin()
    SetNextWindowFocus()
    {
        let g = this.guictx;
        g.NextWindowData.FocusCond = CondFlags.Always;
    },

    // set next window background color alpha. helper to easily modify
    // ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use
    // ImGuiWindowFlags_NoBackground.
    SetNextWindowBgAlpha(alpha)
    {
        let g = this.guictx;
        g.NextWindowData.BgAlphaVal = alpha;
        g.NextWindowData.BgAlphaCond = CondFlags.Always;
        // Using a Cond member for consistency (may transition all of them
        // to single flag set for fast Clear() op)
    },

    // (not recommended) set current window position - call within Begin()/End().
    // prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
    SetWindowPos(pos, cond)
    {
        let win = this.guictx.CurrentWindow;
        win.SetWindowPos(pos, cond);
    },

    SetWindowPosNm(nm, pos, cond)
    {
        let win = this.findWindowByName(nm);
        if(win)
            win.SetWindowPos(pos, cond);
    },

    // (not recommended) set current window size - call within Begin()/End().
    // set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(),
    // as this may incur tearing and minor side-effects.
    SetWindowSize(size, cond)
    {
        let win = this.guictx.CurrentWindow;
        win.SetWindowSize(size, cond);
    },

    SetWindowSizeNm(nm, size, cond)
    {
        let win = this.findWindowByName(nm);
        if(win)
            win.SetWindowSize(size, cond);
    },

    // (not recommended) set current window collapsed state.
    // Prefer using SetNextWindowCollapsed().
    SetWindowCollapsed(collapsed, cond)
    {
        this.guictx.CurrentWindow.SetWindowCollapsed(collapsed, cond);
    },

    SetWindowCollapsedNm(nm, collapsed, cond)
    {
        let win = this.findWindowByName(nm);
        if(win)
            win.SetWindowCollapsed(collapsed, cond);
    },

    // (not recommended) set current window to be focused / front-most.
    // Prefer using SetNextWindowFocus().
    SetWindowFocus()
    {
        this.FocusWindow(this.guictx.CurrentWindow);
    },

    SetWindowFocusNm(nm)
    {
        let win = this.findWindowByName(nm);
        if(win)
            this.FocusWindow(win);
    },

    // Set font scale. Adjust IO.FontGlobalScale if you want to scale
    // all windows
    SetWindowFontScale(scale)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        win.FontWindowScale = scale;
    },

    // Windows Scrolling --------------------------------------------------
    // get scrolling amount [0..GetScrollMaxX()]
    GetScrollX()
    {
        return this.guictx.CurrentWindow.Scroll.x;
    },

    // get scrolling amount [0..GetScrollMaxY()]
    GetScrollY()
    {
        return this.guictx.CurrentWindow.Scroll.y;
    },

    // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X
    GetScrollMaxX()
    {
        return this.guictx.CurrentWindow.GetScrollMaxX();
    },

    // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y
    GetScrollMaxY()
    {
        return this.guictx.CurrentWindow.GetScrollMaxY();
    },

    // set scrolling amount [0..GetScrollMaxX()]
    SetScrollX(scroll_x)
    {
        this.guictx.CurrentWindow.SetScrollX(scroll_x);
    },

    // set scrolling amount [0..GetScrollMaxY()]
    SetScrollY(scroll_y)
    {
        this.guictx.CurrentWindow.SetScrollX(scroll_y);
    },

    // adjust scrolling amount to make current cursor position visible.
    // center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to
    // make a "default/current item" visible, consider using
    // SetItemDefaultFocus() instead.
    // center_y_ratio: 0.0f top of last item, 0.5f vertical center of last
    // item, 1.0f bottom of last item.
    SetScrollHereY(center_y_ratio=.5)
    {
        let win = this.guictx.CurrentWindow;
        // Top of last item, in window space
        let target_y = win.DC.CursorPosPrevLine.y - win.Pos.y;
        // Precisely aim above, in the middle or below the last line.
        target_y += (win.DC.PrevLineHeight * center_y_ratio) +
            (this.guictx.Style.ItemSpacing.y * (center_y_ratio - 0.5) * 2.);
        this.SetScrollFromPosY(target_y, center_y_ratio);
    },

    // adjust scrolling amount to make given position visible. Generally
    // GetCursorStartPos() + offset to compute a valid position.
    SetScrollFromPosY(local_y, center_y_ratio)
    {
        // We store a target position so centering can occur on the next frame
        // when we are guaranteed to have a known window size
        let win = this.guictx.CurrentWindow;
        console.assert(center_y_ratio >= 0. && center_y_ratio <= 1.);
        win.ScrollTarget.y = Math.floor(local_y + win.Scroll.y);
        win.ScrollTargetCenterRatio.y = center_y_ratio;
    },

    /* -----------------------------------------------------------------*/
    createNewWindow(name, size, flags)
    {
        let g = this.guictx;

        // Create window the first time
        let win = new Window(name, this);
        win.Flags = flags;
        g.WindowsByName[name] = win;

        // Default/arbitrary window position. Use SetNextWindowPos() with
        // the appropriate condition flag to change the initial position of a window.
        win.Pos = new Vec2(60, 60);

        // User can disable loading and saving of settings. Tooltip and child
        // windows also don't store settings.
        if (!(flags & WindowFlags.NoSavedSettings))
        {
            let settings = this.findWindowSettings(win.ID);
            if (settings)
            {
                // Retrieve settings from .ini file
                win.SettingsIdx = g.SettingsWindows.indexOf(settings);
                win.SetWindowConditionAllowFlags(CondFlags.FirstUseEver, false);
                win.Pos = Vec2.Floor(settings.Pos);
                win.Collapsed = settings.Collapsed;
                if (settings.Size.LengthSq() > 0.00001)
                    size = Vec2.Floor(settings.Size);
            }
        }
        win.Size = Vec2.Floor(size);
        win.SizeFull = Vec2.Floor(size);
        win.SizeFullAtLastBegin = Vec2.Floor(size);
        // So first call to CalcSizeContents() doesn't return crazy values
        win.DC.CursorMaxPos.Copy(win.Pos);

        if ((flags & WindowFlags.AlwaysAutoResize) != 0)
        {
            win.AutoFitFramesX = win.AutoFitFramesY = 2;
            win.AutoFitOnlyGrows = false;
        }
        else
        {
            if (win.Size.x <= 0)
                win.AutoFitFramesX = 2;
            if (win.Size.y <= 0)
                win.AutoFitFramesY = 2;
            win.AutoFitOnlyGrows = (win.AutoFitFramesX > 0) ||
                                   (win.AutoFitFramesY > 0);
        }

        g.WindowsFocusOrder.push_back(win);
        if (flags & WindowFlags.NoBringToFrontOnFocus)
            g.Windows.push_front(win); // Quite slow but rare and only once
        else
            g.Windows.push_back(win);
        return win;
    },

    setCurrentWindow(win)
    {
        this.guictx.CurrentWindow = win;
        if(win)
            win.MakeCurrent();
    },

    getCurrentWindowRead()
    {
        return this.guictx.CurrentWindow;
    },

    getCurrentWindow()
    {
        let g = this.guictx;
        g.CurrentWindow.WriteAccessed = true;
        return g.CurrentWindow;
    },

    findWindowByID(id)
    {
        console.assert(0, "unused");
    },

    findWindowByName(name)
    {
        return this.guictx.WindowsByName[name];
    },

    getWindowBgColorFromFlags(flags)
    {
        if (flags & (WindowFlags.Tooltip | WindowFlags.Popup))
            return "PopupBg";
        if (flags & WindowFlags.ChildWindow)
            return "ChildBg";
        return "WindowBg";
    },

    checkStacksSize(win, begin)
    {
       // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat,
        //  DC.TextWrapPos (per window) to allow user to conveniently push
        //  once and not pop (they are cleared on Begin)
        let tracker = win.DC.StackSizesBackup;
        let g = this.guictx;
        if(begin)
        {
            tracker["ID"] = win.IDStack.length;
            tracker["Group"] = win.DC.GroupStack.length;
            tracker["BeginPopup"] = g.BeginPopupStack.length;
            tracker["DrawListLayers"] = win.DrawList.LayerStack.length;
            tracker["ColorModifiers"] = g.ColorModifiers.length;
            tracker["StyleModifiers"] = g.StyleModifiers.length;
            tracker["FontStack"] = g.FontStack.length;
        }
        else
        {
            console.assert(tracker["ID"] == win.IDStack.length);
            console.assert(tracker["Group"] == win.DC.GroupStack.length);
            console.assert(tracker["BeginPopup"] == g.BeginPopupStack.length);
            console.assert(tracker["DrawListLayers"] = win.DrawList.LayerStack.length);
            // For color, style and font stacks there is an incentive to use
            // Push/Begin/Pop/.../End patterns, so we relax our checks a little
            // to allow them.
            console.assert(tracker["ColorModifiers"] >= g.ColorModifiers.length);
            console.assert(tracker["StyleModifiers"] >= g.StyleModifiers.length);
            console.assert(tracker["FontStack"] >= g.FontStack.length);
        }
    },
    // ---- window --------------

    // Passing null to disable keyboard focus (ie: blur)
    FocusWindow(win)
    {
        let g = this.guictx;
        if (g.NavWindow != win)
        {
            g.NavWindow = win;
            if (win && g.NavDisableMouseHover)
                g.NavMousePosDirty = true;
            g.NavInitRequest = false;
            g.NavId = win ? win.NavLastIds[0] : 0; // Restore NavId
            g.NavIdIsAlive = false;
            g.NavLayer = NavLayer.Main;
            //IMGUI_DEBUG_LOG("FocusWindow(\"%s\")\n", win ? win->Name : NULL);
        }

        if (!win)
            return;

        // Move the root window to the top of the pile
        if (win.RootWindow)
            win = win.RootWindow;

        // Steal focus on active widgets
        // FIXME: This statement should be unnecessary. Need further testing
        // before removing it..
        if (win.Flags & WindowFlags.Popup)
        if (g.ActiveId != 0 && g.ActiveIdWindow &&
            g.ActiveIdWindow.RootWindow != win)
        {
            this.clearActiveID();
        }

        // Bring to front
        this.bringWindowToFocusFront(win);
        if (!(win.Flags & WindowFlags.NoBringToFrontOnFocus))
            this.bringWindowToDisplayFront(win);
    },

    focusPreviousWindowIgnoringOne(ignorewin)
    {
        let g = this.guictx;
        for (let i = g.WindowsFocusOrder.length - 1; i >= 0; i--)
        {
            // We may later decide to test for different NoXXXInputs based on
            // the active navigation input (mouse vs nav) but that may feel
            // more confusing to the user.
            let win = g.WindowsFocusOrder[i];
            if (win != ignorewin && win.WasActive &&
                !(win.Flags & WindowFlags.ChildWindow))
            {
                if ((win.Flags & (WindowFlags.NoMouseInputs | WindowFlags.NoNavInputs))
                    != (WindowFlags.NoMouseInputs | WindowFlags.NoNavInputs))
                {
                    let focus_window = this.navRestoreLastChildNavWindow(win);
                    this.FocusWindow(focus_window);
                    return;
                }
            }
        }
    },

    navRestoreLastChildNavWindow(win)
    {
        return win.NavLastChildNavWindow ? win.NavLastChildNavWindow : win;
    },

    bringWindowToFocusFront(win)
    {
        let g = this.guictx;
        let len = g.WindowsFocusOrder.length;
        if (g.WindowsFocusOrder[len-1] == win)
            return;
        // We can ignore the front most window
        for (let i=len-2; i >= 0; i--)
        {
            if (g.WindowsFocusOrder[i] == win)
            {
                g.WindowsFocusOrder.splice(i, 1);
                g.WindowsFocusOrder.push(win);
                break;
            }
        }
    },

    bringWindowToDisplayFront(win)
    {
        let g = this.guictx;
        let len = g.WindowsFocusOrder.length;
        let front = g.Windows[len-1];
        if (front && (front == win || front.RootWindow == win))
            return;
        // We can ignore the front most window
        for (let i=len-2; i >= 0; i--)
        {
            if (g.Windows[i] == win)
            {
                g.Windows.splice(i, 1);
                g.Windows.push(win);
                break;
            }
        }
    },

    bringWindowToDisplayBack(win)
    {
        let g = this.guictx;
        if (g.Windows[0] == win) // already there
            return;
        for (let i = 0; i < g.Windows.length; i++)
        {
            if (g.Windows[i] == win)
            {
                g.Windows.splice(i, 1);
                g.Windows.splice(0, 0, win); // insert(0)
                break;
            }
        }
    },

    calcWindowExpectedSize(win)
    {
        let c = win.CalcSizeContents();
        return win.CalcSizeAfterConstraint(win.CalcSizeAutoFit(c));
    },

    isWindowChildOf(win, potentialParent)
    {
        if (win.RootWindow == potentialParent)
            return true;
        while (win != null)
        {
            if (win == potentialParent)
                return true;
            win = win.ParentWindow;
        }
        return false;
    },

    isWindowNavFocusable(win)
    {
        return win.Active && win == win.RootWindow &&
                !(win.Flags & WindowFlags.NoNavFocus);
    },

    getWindowScrollMaxX(win)
    {
        return Math.max(0, win.SizeContents.x-(win.SizeFull.x-win.ScrollbarSizes.x));
    },

    getWindowScrollMaxY(win)
    {
        return Math.max(0, win.SizeContents.y-(win.SizeFull.y-win.ScrollbarSizes.y));
    },

    getWindowAllowedExtentRect(win_unused)
    {
        let padding = this.guictx.Style.DisplaySafeAreaPadding;
        let r_screen = this.getViewportRect();
        r_screen.expandXY((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0,
                          (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0);
        return r_screen;
    },

    getViewportRect()
    {
        let g = this.guictx;
        return new Rect(0., 0, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
    },

    updateHoveredWindowAndCaptureFlags()
    {
        let g = this.guictx;

        // Find the window hovered by mouse:
        // - Child windows can extend beyond the limit of their parent so we
        //   need to derive HoveredRootWindow from HoveredWindow.
        // - When moving a window we can skip the search, which also conveniently
        //   bypasses the fact that window->WindowRectClipped is lagging as this
        //   point of the frame.
        // - We also support the moved window toggling the NoInputs flag after
        //   moving has started in order to be able to detect windows below it,
        //   which is useful for e.g. docking mechanisms.

        this.findHoveredWindow();

        // Modal windows prevents cursor from hovering behind them.
        let modal_window = this.getFrontMostPopupModal();
        if (modal_window)
        {
            if (g.HoveredRootWindow &&
                !this.isWindowChildOf(g.HoveredRootWindow, modal_window))
            {
                g.HoveredRootWindow = g.HoveredWindow = null;
            }
        }

        // Disabled mouse?
        if (g.IO.ConfigFlags & ConfigFlags.NoMouse)
            g.HoveredWindow = g.HoveredRootWindow = null;

        // We track click ownership. When clicked outside of a window the
        // click is owned by the application and won't report hovering nor
        // request capture even while dragging over our windows afterward.
        let firstDown = -1; // earliest_down
        let anyDown = false;
        for (let i=0; i < g.IO.MouseDown.length; i++)
        {
            if (g.IO.MouseClicked[i])
            {
                g.IO.MouseDownOwned[i] = (g.HoveredWindow != null) ||
                                          (!g.OpenPopupStack.length==0);
            }
            anyDown |= g.IO.MouseDown[i];
            if (g.IO.MouseDown[i])
            {
                if (firstDown == -1 ||
                    g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[firstDown])
                {
                    firstDown = i;
                }
            }
        }
        let mouseAvail = (firstDown == -1) || g.IO.MouseDownOwned[firstDown];

        // If mouse was first clicked outside of ImGui bounds we also cancel out
        // hovering./ FIXME: For patterns of drag and drop across OS windows,
        // we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
        let draggingExternPayload = g.DragDropActive &&
                    (g.DragDropSourceFlags & DragDropFlags.SourceExtern) != 0;
        if (!mouseAvail && !draggingExternPayload)
            g.HoveredWindow = g.HoveredRootWindow = null;

        // Update io.WantCaptureMouse for the user application (true = dispatch
        // mouse info to imgui, false = dispatch mouse info to imgui + app)
        if (g.WantCaptureMouseNextFrame != -1)
            g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);
        else
            g.IO.WantCaptureMouse = (mouseAvail && (g.HoveredWindow != null || anyDown)) ||
                                    (g.OpenPopupStack.length > 0);

        // Update io.WantCaptureKeyboard for the user application (true =
        // dispatch keyboard info to imgui, false = dispatch keyboard info to
        // imgui + app)
        if (g.WantCaptureKeyboardNextFrame != -1)
            g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
        else
            g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != null);
        if (g.IO.NavActive && (g.IO.ConfigFlags & ConfigFlags.NavEnableKeyboard)
            && !(g.IO.ConfigFlags & ConfigFlags.NavNoCaptureKeyboard))
            g.IO.WantCaptureKeyboard = true;

        // Update io.WantTextInput flag, this is to allow systems without a
        // keyboard (e.g. mobile, hand-held) to show a software keyboard if
        // possible
        g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ?
                                (g.WantTextInputNextFrame != 0) : false;
    },

    // Find window given position, search front-to-back
    // FIXME: Note that we have an inconsequential lag here: OuterRectClipped
    // is updated in Begin(), so windows moved programatically
    // with SetWindowPos() and not SetNextWindowPos() will have that rectangle
    // lagging by a frame at the time FindHoveredWindow() is called, aka before
    // the next Begin(). Moving window isn't affected.
    findHoveredWindow()
    {
        let g = this.guictx;
        let hovered_window = null;
        if (g.MovingWindow && !(g.MovingWindow.Flags & WindowFlags.NoMouseInputs))
            hovered_window = g.MovingWindow;
        let padding_regular = g.Style.TouchExtraPadding;
        let padding_for_resize_from_edges = g.IO.ConfigWindowsResizeFromEdges ?
                Vec2.Max(g.Style.TouchExtraPadding,
                        new Vec2(WinResizeEdgeHalf, WinResizeEdgeHalf)) :
                padding_regular;
        for (let i=g.Windows.length-1; i>= 0; i--)
        {
            let win = g.Windows[i];
            if (!win.Active || win.Hidden)
                continue;
            if (win.Flags & WindowFlags.NoMouseInputs)
                continue;

            // Using the clipped AABB, a child window will typically be clipped
            // by its parent (not always)
            let bb = win.OuterRectClipped.Clone();
            if ((win.Flags & WindowFlags.ChildWindow) ||
                (win.Flags & WindowFlags.NoResize))
            {
                bb.Expand(padding_regular);
            }
            else
            {
                bb.Expand(padding_for_resize_from_edges);
            }
            if (!bb.Contains(g.IO.MousePos))
                continue;

            // Those seemingly unnecessary extra tests are because the code here
            // is a little different in viewport/docking branches.
            if (hovered_window == null)
                hovered_window = win;
            if (hovered_window)
                break;
        }
        g.HoveredWindow = hovered_window;
        g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow.RootWindow : null;
    },

    getFrontMostPopupModal()
    {
        let g = this.guictx;
        for (let n = g.OpenPopupStack.length-1; n >= 0; n--)
        {
            let popup = g.OpenPopupStack[n].Window;
            if (popup && popup.Flags & WindowFlags.Modal)
                return popup;
        }
        return null;
    },


    // sort, cb(a, b)
    // If the result is negative a is sorted before b.
    // If the result is positive b is sorted before a.
    // If the result is 0 no changes are done with the sort
    // order of the two values.

    // the front-most window is at the end of the list, so
    // higher values of ZIndex (for non-child windows) should
    // follow lower ZIndex windows.
    _zsort(a, b)
    {
        // XXX: should we find deepest ancester?
        if(a.ParentWindow) a = a.ParentWindow;
        if(b.ParentWindow) b = b.ParentWindow;

        if (a.Active && !(a.Flags & WindowFlags.ChildWindow) &&
            b.Active && !(b.Flags & WindowFlags.ChildWindow))
        {
            // no child windows here
            return a.ZIndex - b.ZIndex; //  a=1 should sort after b=0 and
                                        //   therefore be in front
        }
        // if we compare a non-child window against a child-window
        // we assert no opinion about order.  This is presumably taken
        // care of by addWindowToSortBuffer. Same with two child-windows
        return 0;
    },

    // zsortWindows called before addWindowToSortBuffer, last window in
    // Windows array is front-most
    zsortWindows()
    {
        this.guictx.Windows.sort(this._zsort);
    },

    _compareWindows(a, b)
    {

        let d = (a.Flags & WindowFlags.Popup) - (b.Flags & WindowFlags.Popup);
        if (d)
            return d;
        d = (a.Flags & WindowFlags.Tooltip) - (b.Flags & WindowFlags.Tooltip);
        if(d)
            return d;
        return (a.BeginOrderWithinParent - b.BeginOrderWithinParent);
    },

    // recursively sort the windows
    addWindowToSortBuffer(buf, win)
    {
        buf.push(win);
        if(win.Active)
        {
            let count = win.DC.ChildWindows.length;
            if(count > 1)
                win.DC.ChildWindows.sort(this._compareWindows);
            for(let i=0;i<count;i++)
            {
                let c = win.DC.ChildWindows[i];
                if(c.Active)
                    this.addWindowToSortBuffer(buf, c);
            }
        }
    },
};
// =====================================================================================================================
// winmgr.js END
// =====================================================================================================================
// =====================================================================================================================
// io.js BEGIN
// =====================================================================================================================

/**
 * ImGuiIO
 * Communicate most settings and inputs/outputs to imgui using this structure.
**/

const DirtyCount = 5; // iterations to "draw down" to LazyMode
const MinimumFrameInterval = 1000; // minimum 1 fps

class IO
{
    constructor(imgui, canvas, appname)
    {
        this.imgui = imgui;
        this.PrevTime = 0;
        this.PrevDirtyTime = 0;
        this.Dirty = 0;
        this.SynthesizePointerEvents = 
            navigator.userAgent.indexOf("iPhone") !== -1 ||
            navigator.userAgent.indexOf("iPad") !== -1;

        //------------------------------------------------------------------
        // Configuration (fill once)
        //------------------------------------------------------------------
        this.ConfigFlags = 0;
        if((typeof window.orientation !== "undefined") || 
           (navigator.userAgent.indexOf("IEMobile") !== -1))
        {
            this.ConfigFlags |= ConfigFlags.IsTouchScreen;
        }

        this.BackendFlags = 0;
        this.DisplayOffset = new Vec2(0, 0); // position of display relative to parent (usually 0)
        this.DisplaySize = new Vec2(0, 0); // Main display size, in pixels. (Vec2)
        this.DeltaTime = 1 /  60; // Time elapsed since last frame, in seconds.
        this.IniSavingRate = 5; // Minimum time between saving state, in seconds.
        // Path to .ini file. Set NULL to disable automatic .ini loading/saving,
        // if e.g. you want to manually load/save from memory.
        this.IniFilename = `/${appname}/presets.json`;
        // Path to .log file (default parameter to ImGui::LogToFile when no
        // file is specified).
        this.LogFilename = `${appname}/diagnostics.log`;

        this.LazyDraw = false; // experimental: app can set LazyDraw in "bgd"

        // Time for a double-click, in seconds.
        this.MouseDoubleClickTime = .3;
        // Distance threshold to stay in to validate a double-click, in pixels.
        this.MouseDoubleClickMaxDist = 6;
        // Distance threshold before considering we are dragging.
        this.MouseDragThreshold = 6.0;
        // Map of indices into the KeysDown[512] entries array which
        // represent your "native" keyboard state.
        this.KeyMap = new ArrayEx();
        // When holding a key/button, time before it starts repeating, in
        // seconds (for buttons in Repeat mode, etc.).
        this.KeyRepeatDelay = 0.25;
        // When holding a button, time before the click-release is
        // deemed acceptable.  See ButtonFlags.Long
        this.LongPressInterval = .75; // sec (apple defaults to .5s)
        // When holding a key/button, rate at which it repeats, in seconds.
        this.KeyRepeatRate = 0.050;
        // Store your own data for retrieval by callbacks.
        this.UserData = null;

        this.Fonts = new FontAtlas(imgui);
        // Global scale all fonts
        this.FontGlobalScale = 1;
        // Allow user scaling text of individual window with CTRL+Wheel.
        this.FontAllowScaling = false;

        // For retina display or other situations where window coordinates o
        // are different from framebuffer coordinates. This generally ends up
        // in ImDrawData::FramebufferScale.
        this.DisplayFramebufferScale = new Vec2(1, 1);

        // Miscellaneous options
        // Request ImGui to draw a mouse cursor for you (if you are on a
        // platform without a mouse cursor). Cannot be easily renamed to
        // 'io.ConfigXXX' because this is frequently used by back-end
        // implementations.
        this.MouseDrawCursor = false;
        // OS X style: Text editing cursor movement using Alt instead of Ctrl,
        // Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End
        // using Cmd+Arrows instead of Home/End, Double click selects by word
        // instead of selecting whole text, Multi-selection in lists uses
        // Cmd/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior
        // to 1.63)
        this.ConfigMacOSXBehaviors = false;          // = defined(APPLE)
        // Set to false to disable blinking cursor, for users who consider
        // it distracting. (was called: io.OptCursorBlink prior to 1.63)
        this.ConfigInputTextCursorBlink = true;
        // Enable resizing of windows from their edges and from the
        // lower-left corner. This requires
        // (io.BackendFlags & BackendFlagsHasMouseCursors) because it
        // needs mouse cursor feedback. (This used to be a per-window
        // ImGuiWindowFlagsResizeFromAnySide flag)
        this.ConfigWindowsResizeFromEdges = true;
        // [BETA] Set to true to only allow moving windows when clicked+dragged
        // from the title bar. Windows without a title bar are not affected.
        this.ConfigWindowsMoveFromTitleBarOnly = false;

        //------------------------------------------------------------------
        // Platform Functions
        // (the imguiimplxxxx back-end files are setting those up for you)
        //------------------------------------------------------------------

        // Optional: Platform/Renderer back-end name (informational only! will
        // be displayed in About Window) + User data for back-end/wrappers to
        // store their own stuff.
        this.BackendPlatformName = "html5/canvas";
        this.BackendRendererName = "canvas/2d";
        this.BackendPlatformUserData = null;
        this.BackendRendererUserData = null;
        this.BackendLanguageUserData = null;

        // Optional: Access OS clipboard
        // (default to use native Win32 clipboard on Windows, otherwise uses
        // a private clipboard. Override to access OS clipboard on other
        // architectures)
        this.ClipboardUserData = null;
        this.Clipboardtext = null;

        // Optional: Notify OS Input Method Editor of the screen position of
        // your cursor for text input position (e.g. when using Japanese/Chinese
        // IME on Windows) (default to use native imm32 api on Windows)
        this.ImeSetInputScreenPosFn = null; // accepts(int x, int y)
        this.ImeWindowHandle = null; // (Windows) Set this to your HWND to get
                                      // automatic IME cursor positioning.

        //------------------------------------------------------------------
        // Input - Fill before calling NewFrame()
        //------------------------------------------------------------------

        // Mouse position, in pixels. Set to ImVec2(-FLTMAX,-FLTMAX) if
        // mouse is unavailable (on another screen, etc.)
        this.MousePos = new Vec2(-Number.MAX_VALUE, -Number.MAX_VALUE);
        // Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself
        // mostly only uses left button (BeginPopupContext** are using right
        // button). Others buttons allows us to track if the mouse is being
        // used by your application + available to user as a convenience via
        // IsMouse** API.
        this.MouseDown = [0,0,0,0,0];
        // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.
        this.MouseWheel = 0;
        // Mouse wheel Horizontal. Most users don't have a mouse with an
        // horizontal wheel, may not be filled by all back-ends.
        // MouseEvent.button
        this.MouseWheelH = 0;
        // A number representing a given button:
        // 0: Main button pressed, usually the left button or the un-initialized state
        // 1: Auxiliary button pressed, usually the wheel button or the middle button (if present)
        // 2: Secondary button pressed, usually the right button
        // 3: Fourth button, typically the Browser Back button
        // 4: Fifth button, typically the Browser Forward button
        this.MouseButtonMap = [ 0, 2, 1, 3, 4 ];
        // Keyboard modifier pressed: Control
        this.KeyCtrl = false;
        // Keyboard modifier pressed: Shift
        this.KeyShift = false;
        // Keyboard modifier pressed: Alt
        this.KeyAlt = false;
        // Keyboard modifier pressed: Cmd/Super/Windows
        this.KeySuper;
        // Keyboard keys that are pressed (ideally left in the "native" order
        // your engine has access to keyboard keys, so you can use your own
        // defines/enums for keys).
        this.KeysDown = new ArrayEx();
        this.KeysDown.length = 512;
        // Gamepad inputs. Cleared back to zero by EndFrame(). Keyboard keys
        // will be auto-mapped and be written here by NewFrame().
        this.NavInputs = new ArrayEx();
        this.NavInputs.length = NavInput.COUNT;
        this.NavInputs.fill(0);

        // https://developer.mozilla.org/en-US/docs/Web/API/Touch_events
        this.Touches = []; // ongoing touches
        this.TouchActive = false;
        this.TouchDelta = {x: 0, y: 0};

        //------------------------------------------------------------------
        // Output - Retrieve after calling NewFrame()
        //------------------------------------------------------------------
        // When io.WantCaptureMouse is true, imgui will use the mouse inputs,
        // do not dispatch them to your main game/application (in both cases,
        // always pass on mouse inputs to imgui). (e.g. unclicked mouse is
        // hovering over an imgui window, widget is active, mouse was clicked
        // over an imgui window, etc.).
        this.WantCaptureMouse = false;
        // When io.WantCaptureKeyboard is true, imgui will use the keyboard
        // inputs, do not dispatch them to your main game/application (in
        // both cases, always pass keyboard inputs to imgui). (e.g. InputText
        // active, or an imgui window is focused and navigation is enabled, etc.).
        this.WantCaptureKeyboard = false;
        // Mobile/console: when io.WantTextInput is true, you may display an
        // on-screen keyboard. This is set by ImGui when it wants textual
        // keyboard input to happen (e.g. when a InputText widget is active).
        this.WantTextInput = false;
        // MousePos has been altered, back-end should reposition mouse on
        // next frame. Set only when ImGuiConfigFlagsNavEnableSetMousePos
        // flag is enabled.
        this.WantSetMousePos = false;
        // When manual .ini load/save is active (io.IniFilename == NULL),
        // this will be set to notify your application that you can call
        // SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need
        // to clear io.WantSaveIniSettings yourself.
        this.WantSaveIniSettings = false;
        // Directional navigation is currently allowed (will handle
        // ImGuiKeyNavXXX events) = a window is focused and it doesn't use
        // the ImGuiWindowFlagsNoNavInputs flag.
        this.NavActive = false;
        // Directional navigation is visible and allowed (will handle
        // ImGuiKeyNavXXX events).
        this.NavVisible = false;
        // Application framerate estimation, in frame per second. Solely for
        // convenience. Rolling average estimation based on IO.DeltaTime over
        // 120 frames
        this.Framerate = 60;
        // Vertices output during last call to Render()
        this.MetricsRenderVertices = 0;
        // Indices output during last call to Render() = number of triangles * 3
        this.MetricsRenderIndices = 0;
        // Number of visible windows
        this.MetricsRenderWindows = 0;
        // Number of active windows
        this.MetricsActiveWindows = 0;
        // Number of active allocations, updated by MemAlloc/MemFree based
        // on current context. May be off if you have multiple imgui contexts.
        this.MetricsActiveAllocations;

        //------------------------------------------------------------------
        // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!
        //------------------------------------------------------------------
        // Mouse delta. Note that this is zero if either current or previous
        // position are invalid (-FLTMAX,-FLTMAX), so a disappearing/reappearing
        // mouse won't have a huge delta.
        this.MouseDelta = new Vec2(0, 0);
        // Previous mouse position (note that MouseDelta is not necessary ==
        // MousePos-MousePosPrev, in case either position is invalid)
        this.MousePosPrev = new Vec2(0, 0);
        // Position at time of clicking
        this.MouseClickedPos = [null, null, null, null, null]; // of Vec2
        // Time of last click (used to figure out double-click)
        this.MouseClickedTime = new ArrayEx();
        // Mouse button went from !Down to Down
        this.MouseClicked = new ArrayEx();
        // Has mouse button been double-clicked?
        this.MouseDoubleClicked = new ArrayEx();
        // Mouse button went from Down to !Down
        this.MouseReleased = new ArrayEx();
        this.MouseDownOwned = new ArrayEx();
        // Track if button was clicked inside a window. We don't request
        // mouse capture from the application if click started outside ImGui bounds.
        this.MouseDownDuration = new ArrayEx();
        // Duration the mouse button has been down (0.0f == just clicked)
        this.MouseDownDurationPrev = new ArrayEx();
        // Previous time the mouse button has been down
        this.MouseDragMaxDistanceAbs = new ArrayEx();
        // Maximum distance, absolute, on each axis, of how much mouse has
        // traveled from the clicking point
        this.MouseDragMaxDistanceSqr = new ArrayEx();
        // Squared maximum distance of how much mouse has traveled from
        // the clicking point

        this.KeysDownDuration = new ArrayEx();
        // Duration the keyboard key has been down (0.0f == just pressed)
        this.KeysDownDurationPrev = new ArrayEx();
        // Previous duration the key has been down

        this.NavInputsDownDuration = new ArrayEx();
        this.NavInputsDownDuration.length = NavInput.COUNT;
        this.NavInputsDownDuration.fill(0);
        this.NavInputsDownDurationPrev = new ArrayEx();
        this.NavInputsDownDurationPrev.length = NavInput.COUNT;
        this.NavInputsDownDurationPrev.fill(0);

        // Queue of characters input (obtained by platform back-end).
        this.InputKeyEvents = new ArrayEx(); // evt

        this.initCanvas(canvas);
    }

    initCanvas(canvas)
    {
        this.canvas = canvas;
        if (typeof(window) !== "undefined")
        {
            // ImGui.LoadIniSettingsFromMemory(window.localStorage.getItem("imgui.ini") || "");
        }

        if (typeof(this.imgui.appServices) !== "undefined")
        {
            this.ConfigMacOSXBehaviors = this.imgui.appServices.platform.match(/Mac/) !== null;
        }

        if (typeof(document) !== "undefined")
        {
            document.body.addEventListener("copy", this.onCopy.bind(this));
            document.body.addEventListener("cut", this.onCut.bind(this));
            document.body.addEventListener("paste", this.onPaste.bind(this));
        }

        this.ClipboardUserData = null;

        if (typeof(window) !== "undefined")
        {
            window.addEventListener("resize",
                                    this.onWindowResize.bind(this));
            window.addEventListener("gamepadconnected",
                                    this.onGamepadConnected.bind(this));
            window.addEventListener("gamepaddisconnected",
                                    this.onGamepadDisconnected.bind(this));
            // prevent browser context menu
            window.oncontextmenu = function() { return false; };

        }

        if (canvas !== null)
        {
            this.onWindowResize();
            // Disable browser handling of all panning and zooming gestures.
            canvas.tabIndex = 1; // forces delivery of keyboard events
            canvas.style.touchAction = "none";
            canvas.addEventListener("blur", this.onBlur.bind(this));

            /*
             * The onkeypress event occurs when the user presses a key (on the keyboard).
             * The order of events related to the onkeypress event:
             *  1. onkeydown
             *  2. onkeypress
             *  3. onkeyup
             * Note: The onkeypress event is not fired for all keys
             *   (e.g. ALT, CTRL, SHIFT, ESC) in all browsers. To detect only
             *   whether the user has pressed a key, use the onkeydown event
             *   instead, because it works for all keys.
             */
            // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
            /* NB: only listen to canvas keyboard and mouse events to support
             *  mixed-mode DOM operation (as with AceEditor).
             */
            canvas.addEventListener("keydown", this.onKeyDown.bind(this));
            canvas.addEventListener("keyup", this.onKeyUp.bind(this));
            canvas.addEventListener("keypress", this.onKeyPress.bind(this));

            /* pointer events combine touch events with mouse events */
            canvas.addEventListener("pointermove", this.onPointerMove.bind(this));
            canvas.addEventListener("pointerdown", this.onPointerDown.bind(this));
            canvas.addEventListener("pointerup", this.onPointerUp.bind(this));

            canvas.addEventListener("wheel", this.onWheel.bind(this),
                    {passive: true}); // means no prevent-default
            
            // On a phone, touch can be tricky since browsers use touch
            // events to synthesize pointerclick and pointermove events.
            // No mouse, no wheel, etc. If we want a natural scrolling
            // behavior from touch events we would need to distinguish between 
            // mouse-like and mousewheel-like events. Currently this doesn't
            // seem possible.  Specifically: if a touchstart occurs over a
            // clickable (button, drag, etc) we can't infer whether the
            // user is scrolling or clicking.  In the case of buttons, we
            // could wait for a release event and check if there's little/no 
            // motion. This wouldn't work for draggables like sliders and
            // drags.  Currently we update this.Touch* and support 
            // mouse-wheel-like behavior in imgui.updateMouseWheel().
            canvas.addEventListener("touchstart", this.onTouchStart.bind(this),
                                    {passive: true});
            canvas.addEventListener("touchend", this.onTouchEnd.bind(this),
                                    {passive: true});
            canvas.addEventListener("touchcancel", this.onTouchCancel.bind(this),
                                    {passive: true});
            canvas.addEventListener("touchmove", this.onTouchMove.bind(this),
                                    {passive: true});
        }

        // Setup back-end capabilities flags
        // We can honor GetMouseCursor() values (optional)
        this.BackendFlags |= BackendFlags.HasMouseCursors;

        // Keyboard mapping used to peek into keysDown.
        this.NavKeys =
        {
            "ArrowLeft": 37,
            "ArrowUp": 38,
            "ArrowRight": 39,
            "ArrowDown": 40,
            "Escape": 27,
            "Tab": 9,
            "Delete": 46,
            "Backspace": 8,
            "PageUp": 33,
            "PageDown": 34,
            "Insert": 45,
            "Home": 36,
            "End": 35,
            "Space": 32,
            "Enter": 13,
        };

        this.MetaKeys =
        {
            "Control": 17,
            "Shift": 16,
            "Alt": 18,
            "Meta": 91, // Windows key
        };

        this.KeyMap[Key.Tab] = this.NavKeys.Tab;
        this.KeyMap[Key.LeftArrow] = this.NavKeys.ArrowLeft;
        this.KeyMap[Key.RightArrow] = this.NavKeys.ArrowRight;
        this.KeyMap[Key.UpArrow] = this.NavKeys.ArrowUp;
        this.KeyMap[Key.DownArrow] = this.NavKeys.ArrowDown;
        this.KeyMap[Key.PageUp] = this.NavKeys.PageUp;
        this.KeyMap[Key.PageDown] = this.NavKeys.PageDown;
        this.KeyMap[Key.Home] = this.NavKeys.Home;
        this.KeyMap[Key.End] = this.NavKeys.End;
        this.KeyMap[Key.Insert] = this.NavKeys.Insert;
        this.KeyMap[Key.Delete] = this.NavKeys.Delete;
        this.KeyMap[Key.Backspace] = this.NavKeys.Backspace;
        this.KeyMap[Key.Space] = this.NavKeys.Space;
        this.KeyMap[Key.Enter] = this.NavKeys.Enter;
        this.KeyMap[Key.Escape] = this.NavKeys.Escape;
        this.KeyMap[Key.A] = 65;
        this.KeyMap[Key.C] = 67;
        this.KeyMap[Key.V] = 86;
        this.KeyMap[Key.X] = 88;
        this.KeyMap[Key.Y] = 89;
        this.KeyMap[Key.Z] = 90;

        this.KeyCodeMap = {}; // inverse of KeyMap
        for(let key in this.NavKeys)
            this.KeyCodeMap[this.NavKeys[key]] = key;
        this.KeyCodeMap[65] = "A"; // select-all
        this.KeyCodeMap[67] = "C"; // copy
        this.KeyCodeMap[86] = "V"; // paste
        this.KeyCodeMap[88] = "X"; // cut
        this.KeyCodeMap[89] = "Y"; // redo
        this.KeyCodeMap[90] = "Z"; // undo
    }

    // called via guictx.NewFrame which is called by imgui.NewFrame
    // NB: this happens before imgui resets volatile state (like MouseCursor)
    //  so we react to the state at the end of last frame.
    NewFrame(time)
    {
        if(this.WantsSaveIniSettings)
        {
            this.WantsSaveIniSettings = false;
            // XXX: save settings to .prefs file/dir
            window.localStorage.setItem(this.IniFilename, this.imgui.SaveIniSettingsToMemory());
        }

        this.DisplaySize.x = this.canvas.scrollWidth;
        this.DisplaySize.y = this.canvas.scrollHeight;
        let cbound = this.canvas.getBoundingClientRect();
        if(cbound && cbound.x != undefined)
        {
            // preferred since it's viewport relative, but seems to
            // fail on older android browsers
            this.DisplayOffset.x = cbound.x;
            this.DisplayOffset.y = cbound.y;
        }
        else
        {
            if(this.DisplayOffset.y != this.canvas.offsetTop)
            {
                console.debug("bad bounding client rect " + JSON.stringify(cbound));
                this.DisplayOffset.x = this.canvas.offsetLeft;
                this.DisplayOffset.y = this.canvas.offsetTop;
            }
        }

        const dt = time - this.PrevTime;
        this.PrevTime = time;
        this.DeltaTime = dt / 1000;
        if(this.LazyDraw)
        {
            // this experiment currently fails due to the fact that
            // certain imgui behaviors occur over multiple frames.
            // Popups, textinput are among the biggest fails.
            const ddt = time - this.PrevDirtyTime;
            if(ddt > MinimumFrameInterval) 
            {
                this.PrevDirtyTime = time;
                this.Dirty++;
            }
        }
        else
            this.Dirty = true; // checked by app.OnLoop/imgui.NewFrame

        if (this.WantSetMousePos)
            console.log("TODO: MousePos", this.MousePos.x, this.MousePos.y);


        if(this.MouseDrawCursor)
            document.body.style.cursor = "none";
        else
        {
            let nc;
            switch(this.imgui.GetMouseCursor())
            {
            case MouseCursor.None:
                nc = "none";
                break;
            case MouseCursor.TextInput:
                nc = "text";
                break;
            case MouseCursor.ResizeAll:
                nc = "move";
                break;
            case MouseCursor.ResizeNS:
                nc = "ns-resize";
                break;
            case MouseCursor.ResizeEW:
                nc = "ew-resize";
                break;
            case MouseCursor.ResizeNESW:
                nc = "nesw-resize";
                break;
            case MouseCursor.ResizeNWSE:
                nc = "nwse-resize";
                break;
            case MouseCursor.Hand:
                nc = "move";
                break;
            case MouseCursor.Arrow:
            default:
                nc = "default";
                break;
            }
            if(document.body.style.cursor != nc)
            {
                // console.log("new cursor: " + nc);
                document.body.style.cursor = nc;
            }
        }

        this.updateMouseInputs();
    }

    EndFrame()
    {
        if(this.Dirty > 0)
            this.Dirty--;
    }

    Shutdown()
    {
        if (this.canvas)
        {
            let c = this.canvas;
            c.removeEventListener("blur", this.onBlur.bind(this));
            c.removeEventListener("keydown", this.onKeyDown.bind(this));
            c.removeEventListener("pointerup", this.onPointerUp.bind(this));
            c.removeEventListener("wheel", this.onWheel.bind(this));
            c.removeEventListener("keyup", this.onKeyUp.bind(this));
            c.removeEventListener("keypress", this.onKeyPress.bind(this));
            c.removeEventListener("pointermove", this.onPointerMove.bind(this));
            c.removeEventListener("pointerdown", this.onPointerDown.bind(this));
            c.removeEventListener("contextmenu", this.onContextMenu.bind(this));
            c.removeEventListener("touchstart", this.onTouchStart.bind(this));
            c.removeEventListener("touchend", this.onTouchEnd.bind(this));
            c.removeEventListener("touchcancel", this.onTouchCancel.bind(this));
            c.removeEventListener("touchmove", this.onTouchMove.bind(this));
        }

        if (typeof(window) !== "undefined")
        {
            window.removeEventListener("resize", this.onWindowResize.bind(this));
            window.removeEventListener("gamepadconnected", this.onGamepadConnected.bind(this));
            window.removeEventListener("gamepaddisconnected", this.onGamepadDisconnected.bind(this));
        }

        if (typeof(document) !== "undefined")
        {
            document.body.removeEventListener("cut", this.onCut.bind(this));
            document.body.removeEventListener("copy", this.onCopy.bind(this));
            document.body.removeEventListener("paste", this.onPaste.bind(this));
        }
    }

    // Clear the text input buffer manually
    ClearInputCharacters()
    {
        this.InputKeyEvents.resize(0);
    }

    GetKeyFromCode(code)
    {
        let ret = this.KeyCodeMap[code]; // dont want Tab to convert to "\t"
        if(ret == undefined)
            ret = String.fromCharCode(code);
        return ret;
    }

    onCopy(evt/*ClipboardEvent*/)
    {
        evt.clipboardData.setData("text/plain", this.clipboardtext);
        // console.log(`${event.type}: "${clipboardtext}"`);
        evt.preventDefault();
        this.Dirty = DirtyCount;
    }

    onCut(evt/*ClipboardEvent*/)
    {
        evt.clipboardData.setData("text/plain", this.clipboardtext);
        // console.log(`${event.type}: "${clipboardtext}"`);
        evt.preventDefault();
        this.Dirty = DirtyCount;
    }

    onPaste(evt)
    {
        this.Clipboardtext = evt.clipboardData.getData("text/plain");
        // console.log(`${evt.type}: "${clipboardtext}"`);
        evt.preventDefault();
        this.Dirty = DirtyCount;
    }

    onWindowResize()
    {
        if (this.canvas !== null)
        {
            const devicePixelRatio = window.devicePixelRatio || 1;
            this.canvas.width = this.canvas.scrollWidth * devicePixelRatio;
            this.canvas.height = this.canvas.scrollHeight * devicePixelRatio;
        }
        this.Dirty = DirtyCount;
    }

    onGamepadConnected(evt)
    {
        console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
                    evt.gamepad.index, evt.gamepad.id,
                    evt.gamepad.buttons.length, evt.gamepad.axes.length);
    }

    onGamepadDisconnected(evt)
    {
        console.log("Gamepad disconnected at index %d: %s.",
                    evt.gamepad.index, evt.gamepad.id);
    }

    onBlur(evt/*FocusEvent*/)
    {
        this.KeyCtrl = false;
        this.KeyShift = false;
        this.KeyAlt = false;
        this.KeySuper = false;
        for (let i=0; i< this.KeysDown.length; ++i)
            this.KeysDown[i] = false;
        for (let i=0; i< this.MouseDown.length; ++i)
            this.MouseDown[i] = false;
        this.Dirty = DirtyCount;
    }

    // In a keypress event, the Unicode value of the key pressed is
    // stored in either the keyCode or charCode property, never both.
    // If the key pressed generates a character (e.g. 'a'), charCode
    // is set to the code of that character, respecting the letter case.
    // (i.e. charCode takes into account whether the shift key is held down).
    // Otherwise, the code of the pressed key is stored in keyCode.
    //
    // - Keyboard:
    // - Set io.ConfigFlags |= ConfigFlags.NavEnableKeyboard to enable.
    //   NewFrame() will automatically fill io.NavInputs[] based on your
    //   io.KeysDown[] + io.KeyMap[] arrays.
    // - When keyboard navigation is active (io.NavActive + ConfigFlags.NavEnableKeyboard),
    //   the io.WantCaptureKeyboard flag will be set. For more advanced uses,
    //   you may want to read from:
    //    - io.NavActive: true when a window is focused and it doesn't have
    //      the WindowFlagsNoNavInputs flag set.
    //    - io.NavVisible: true when the navigation cursor is visible (and
    //      usually goes false when mouse is used).
    //    - or query focus information with e.g.
    //       -- IsWindowFocused(FocusedFlags.AnyWindow)
    //       -- IsItemFocused() etc. functions.
    onKeyDown(evt/*KeyboardEvent*/)
    {
        this.KeyCtrl = evt.ctrlKey;
        this.KeyShift = evt.shiftKey;
        this.KeyAlt = evt.altKey;
        this.KeySuper = evt.metaKey;
        this.KeysDown[evt.keyCode] = true; // produce a sparse array
        // a Control + o shows up as two events:
        //  1. Control
        //  2. o (control-key still down)
        // if control/meta/alt isn't down, then keypress is invoked
        // console.info(`key down: ${evt.keyCode}, ${evt.key}, ${evt.timeStamp}`);
        if(this.MetaKeys[evt.key] == undefined)
        {
            // not a meta key
            this.InputKeyEvents.push(evt);
            // ClearInputCharacters called during imgui.EndFrame(0)

            // since we defer delivery of events, we can't leave it to
            // client to invoke evt.preventDefault.  See also 
            // . this.WantCaptureKeyboard above.
            if(!this.isSystemEvent(evt))
                evt.preventDefault();
        }
        this.Dirty = DirtyCount;
    }

    // this is a matter of policy, perhaps user-configuration required?
    isSystemEvent(evt)
    {
        let issystem = false;
        if(this.imgui.appServices.platform.indexOf("Mac") != -1)
        {
            // cmd-alt-j
            if(evt.shiftKey && evt.metaKey && event.code == "KeyI")
                issystem = true;
            else
            if(evt.shiftKey && evt.metaKey && event.code == "KeyC")
                issystem = true;
            else
            if(evt.metaKey && event.code == "KeyR")
                issystem = true;
        }
        else
        {
            // ctrl-shift-I is dev-inspector
            if(evt.shiftKey && evt.ctrlKey && evt.key.toUpperCase() == "I")
                issystem = true;
            if(evt.ctrlKey && evt.code == "KeyR") // Reload in electron
                issystem = true;
        }
        if(evt.code == "F11" || // F11 is fullscreen
           evt.code == "F12")  // F12 is inspector
            issystem = true;

        if(false)
        {
            // electron on mac doesn't react to certain system events
            //  cmd-R works, shift-cmd-I/C don't.
            console.log(event.code + 
                    `\nmeta: ${evt.metaKey} ` +
                    `\nalt: ${event.altKey} ` +
                    `\nshift: ${event.shiftKey}` +
                    `\nplatform: ${this.imgui.appServices.platform}`);
            if(issystem)
                console.log("is a system key combination!");
        }
        return issystem;
    }

    onKeyUp(evt/*KeyboardEvent*/)
    {
        // console.log(event.type, event.key, event.keyCode);
        this.KeyCtrl = evt.ctrlKey;
        this.KeyShift = evt.shiftKey;
        this.KeyAlt = evt.altKey;
        this.KeySuper = evt.metaKey;
        this.KeysDown[evt.keyCode] = false;
        this.Dirty = DirtyCount;
    }

    // no meta keys are delivered through this event, only "regular" keys.
    // there is some 'magic' associated with input methods for diverse
    // languages that we may lose by skipping these?
    onKeyPress(evt/*KeyboardEvent*/)
    {
        // console.debug(`keypress: ${evt.keyCode}, ${evt.key}`);
        this.Dirty = DirtyCount;
    }

    onPointerMove(evt/*PointerEvent*/)
    {
        this.MousePos.x = evt.offsetX;
        this.MousePos.y = evt.offsetY;
        if (this.WantCaptureMouse) 
        {
            evt.preventDefault();
        }
        // console.log(`${this.MousePos.x.toFixed(0)}, ${this.MousePos.y.toFixed(0)}`);
        this.Dirty = DirtyCount;
    }

    onPointerDown(evt/*pointerEvent*/)
    {
        this.canvas.focus();
        this.MousePos.x = evt.offsetX;
        this.MousePos.y = evt.offsetY;
        this.MouseDown[this.MouseButtonMap[evt.button]] = true;
        evt.preventDefault(); // https://bit.ly/2SfbQqG
        this.Dirty = DirtyCount;
    }

    onPointerUp(evt/*PointerEvent*/)
    {
        this.MouseDown[this.MouseButtonMap[evt.button]] = false;
        this.Dirty = DirtyCount;
    }

    onWheel(evt/*WheelEvent*/)
    {
        let scale = 1.0;
        switch (evt.deltaMode)
        {
        case 0: // pixels
            scale = 0.01;
            break;
        case 1: // lines
            scale = 0.2;
            break;
        case 2: // pages
            scale = 1.0;
            break;
        }
        this.MouseWheelH = evt.deltaX * scale;
        this.MouseWheel = -evt.deltaY * scale; // Mouse wheel: 1 unit scrolls about 5 lines text.
        this.Dirty = DirtyCount;
    }

    onTouchStart(evt)
    {
        var touches = evt.changedTouches;
        var offset = {x: 0, y: 0}; // getTouchPos(evt);  
        for (var i=0; i < touches.length; i++) 
        {
            if(this.validateTouch(touches[i], offset))
            {
                // evt.preventDefault();  (passive)
                // console.log("touchstart:" + i + " " + Math.round(touches[i].clientY));
                this.Touches.push(this.copyTouch(touches[i]));
                this.TouchActive++;

                this.TouchDelta.x = 0; // <-- cancel deceleration
                this.TouchDelta.y = 0;
                if(this.SynthesizePointerEvents)
                {
                    // https://github.com/Rich-Harris/Point
                    // pointerOver (we're not currently using this)
                    // pointerEnter, (we're not currently using this)
                    // pointerDown
                    this.fakePointerEvent(evt, touches[i]);
                    this.onPointerMove(evt);
                    this.onPointerDown(evt); // XXX: button mapping
                }
            }
        }
        this.Dirty = DirtyCount;
    }

    onTouchMove(evt)
    {
        let touches = evt.changedTouches;
        let offset = {x: 0, y: 0};
        let scale = .01; // <---- scaling constant determined experimentally
                         // see also misc.js for deceleration constant
        for (let i = 0; i < touches.length; i++) 
        {
            if(this.validateTouch(touches[i], offset))
            {
                // evt.preventDefault(); (passive)
                let j = this.getTouchIndex(touches[i]);
                if (j >= 0) 
                {
                    let deltaX = touches[i].clientX - this.Touches[j].x;
                    let deltaY = touches[i].clientY - this.Touches[j].y;
                    // console.log("move by: " + 
                    //              Math.round(deltaX) + ", " + 
                    //              Math.round(deltaY));
                    // swap in the new touch record
                    this.Touches.splice(j, 1, this.copyTouch(touches[i])); 
                    this.TouchDelta.x = deltaX * scale;
                    this.TouchDelta.y = deltaY * scale;
                }
                if(this.SynthesizePointerEvents)
                {
                    this.fakePointerEvent(evt, touches[i]);
                    this.onPointerMove(evt);
                }
            } 
            else 
            {
                console.error("can't figure out which touch to continue");
            }
        }
        this.Dirty = DirtyCount;
    }

    onTouchEnd(evt)
    {
        var touches = evt.changedTouches;
        var offset = {x: 0, y: 0};
        for (let i = 0; i < touches.length; i++) 
        {
            if(this.validateTouch(touches[i], offset))
            {
                // evt.preventDefault(); (passive)
                let j = this.getTouchIndex(touches[i]);
                if (j >= 0) 
                {
                    this.Touches.splice(j, 1); // remove it; we're done
                    this.TouchActive--;
                    // we could set TouchDelta to zero but to
                    // get deceleration, we let updateMouseWheel
                    // handle it.
                }
                else 
                {
                    // console.log("hm: " + touches[i].identifier);
                }
                if(this.SynthesizePointerEvents)
                {
                    this.fakePointerEvent(evt, touches[i]);
                    this.onPointerUp(evt);
                }
            }
            else
                console.error("invalid touch");
        }
        this.Dirty = DirtyCount;
    }

    onTouchCancel(evt)
    {
        // evt.preventDefault(); (passive)
        for(var i=0;i<evt.changedTouches.length;i++)
        {
            let j = this.getTouchIndex(evt.changedTouches[i]);
            if(j != -1)
            {
                this.TouchActive--;
                this.Touches.splice(j, 1);
            }
            if(this.SynthesizePointerEvents)
            {
                this.fakePointerEvent(evt, touches[i]);
                this.onPointerUp(evt);
            }
        }
        this.Dirty = DirtyCount;
    }

    fakePointerEvent(evt, touch)
    {
        // add fields to event that are needed by onPointer[Move,Down,Up]
        // touch.client{X,Y} is coordinate of touch poihnt relative to
        // the browser's viewport excluding scroll offset
        let r = evt.target.getBoundingClientRect();
        evt.button = 0;
        evt.offsetX = touch.clientX - r.left;
        evt.offsetY = touch.clientY - r.top;
        evt.preventDefault();
    }

    getTouchIndex(t)
    {
        for(let i=0;i<this.Touches.length;i++)
        {
            if(t.identifier == this.Touches[i].id)
                return i;
        }
        return -1;
    }

    copyTouch(t)
    {
        return {
            id: t.identifier,
            x: t.clientX,
            y: t.clientY
        };
    }

    validateTouch(t, offset)
    {
        return (t.clientX - offset.x > 0 && 
                t.clientX - offset.x < parseFloat(this.canvas.width) && 
                t.clientY - offset.y > 0 && 
                t.clientY - offset.y < parseFloat(this.canvas.height));
    }

    onContextMenu(evt/*Event*/) /* rightclick, (change background?) */
    {
        // no-op to prevent system menu
    }

    updateMouseInputs() // called by imgui on NewFrame
    {
        let imgui = this.imgui;
        let g = this.imgui.guictx;
        // Round mouse position to avoid spreading non-rounded position
        // (e.g. UpdateManualResize doesn't support them well)
        if (imgui.IsMousePosValid(this.MousePos))
        {
            this.MousePos = g.LastValidMousePos = Vec2.Floor(this.MousePos);
        }

        // If mouse just appeared or disappeared (usually denoted by
        // -FLT_MAX components) we cancel out movement in MouseDelta
        if (imgui.IsMousePosValid(this.MousePos) &&
            imgui.IsMousePosValid(this.MousePosPrev))
        {
            this.MouseDelta = Vec2.Subtract(this.MousePos, this.MousePosPrev);
            /* DEBUG
            if(this.MouseDown[0])
            {
                console.log(this.MouseDelta);
            }
            */
        }
        else
            this.MouseDelta = Vec2.Zero();
        if (this.MouseDelta.x != 0 || this.MouseDelta.y != 0)
            g.NavDisableMouseHover = false;

        this.MousePosPrev = this.MousePos.Clone();
        for (let i = 0; i < this.MouseDown.length; i++)
        {
            this.MouseClicked[i] = this.MouseDown[i] && this.MouseDownDuration[i] < 0.;
            this.MouseReleased[i] = !this.MouseDown[i] && this.MouseDownDuration[i] >= 0;
            this.MouseDownDurationPrev[i] = this.MouseDownDuration[i];
            this.MouseDownDuration[i] = this.MouseDown[i] ?
                            (this.MouseDownDuration[i] < 0 ? 0 :
                                this.MouseDownDuration[i] + this.DeltaTime) : -1;
            this.MouseDoubleClicked[i] = false;
            if (this.MouseClicked[i])
            {
                if ((g.Time - this.MouseClickedTime[i]) < this.MouseDoubleClickTime)
                {
                    let deltaClick = imgui.IsMousePosValid(this.MousePos) ?
                            Vec2.Subtract(this.MousePos, this.MouseClickedPos[i]) :
                            Vec2.Zero();
                    if (deltaClick.LengthSq() <
                        this.MouseDoubleClickMaxDist*this.MouseDoubleClickMaxDist)
                    {
                        this.MouseDoubleClicked[i] = true;
                    }
                    // so the third click isn't turned into a double-click
                    this.MouseClickedTime[i] = -Number.MAX_VALUE;
                }
                else
                {
                    this.MouseClickedTime[i] = g.Time;
                }
                this.MouseClickedPos[i] = this.MousePos.Clone();
                this.MouseDragMaxDistanceAbs[i] = new Vec2(0, 0);
                this.MouseDragMaxDistanceSqr[i] = 0.;
            }
            else
            if (this.MouseDown[i])
            {
                // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
                let deltaClick = imgui.IsMousePosValid(this.MousePos) ?
                                Vec2.Subtract(this.MousePos, this.MouseClickedPos[i]) :
                                Vec2.Zero();
                let len = deltaClick.LengthSq();
                this.MouseDragMaxDistanceSqr[i] = Math.max(this.MouseDragMaxDistanceSqr[i],len);
                this.MouseDragMaxDistanceAbs[i].x = Math.max(this.MouseDragMaxDistanceAbs[i].x,
                                                            Math.abs(deltaClick.x));
                this.MouseDragMaxDistanceAbs[i].y = Math.max(this.MouseDragMaxDistanceAbs[i].y,
                                                            Math.abs(deltaClick.y));
            }
            if (this.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
                g.NavDisableMouseHover = false;
        }
    }

    // see misc.js for updateMouseWheel

} // end of class IO


// =====================================================================================================================
// io.js END
// =====================================================================================================================
// =====================================================================================================================
// guictx.js BEGIN
// =====================================================================================================================


class GuiContext
{
    constructor(imgui, canvas, appname="imgui-njs")
    {
        this.canvas = canvas;
        this.AppName = appname;
        this.Initialized = true;
        this.FrameScopeActive = false; // Set by NewFrame(), cleared by EndFrame()
        this.FrameScopePushedImplicitWindow = false;
        this.IO = new IO(imgui, canvas, appname);
        this.Style = new Style(this.IO.Fonts, imgui);
        this.Font = null;
        this.FontSize = 0;
        this.FontLineHeight = 0; // Just Size*Pct
        this.Time = 0.;
        this.FrameCount = 0;
        this.FrameCountEnded = -1;
        this.FrameCountRendered = -1;
        this.Windows = new ArrayEx();
        this.WindowsFocusOrder = new ArrayEx();
        this.WindowsSortBuffer = new ArrayEx();
        this.CurrentWindowStack = new ArrayEx();
        this.WindowsByName = {};
        this.WindowsActiveCount = 0;
        this.CurrentWindow = null; // Begin drawin into
        this.HoveredWindow = null; // Will catch mouse inputs
        this.HoveredRootWindow = null; // Will catch mouse inputs (for focus/move)
        this.HoveredId = 0; // Hovered Widget
        this.HoveredIdAllowOverlap = false;
        this.HoveredIdPreviousFrame = 0;
        this.HoveredIdTimer = 0; // contiguous hovering time
        this.HoveredIdNotActiveTimer = 0.;
        this.ActiveId = 0;
        this.ActiveIdPreviousFrame = 0;
        this.ActiveIdIsAlive = 0;
        this.ActiveIdTimer = 0.;
        this.ActiveIdIsJustActivated = false;
        this.ActiveIdAllowOverlap = false;
        this.ActiveIdHasBeenPressed = false;
        this.ActiveIdHasBeenEdited = false;
        this.ActiveIdPreviousFrameIsAlive = false;
        this.ActiveIdPreviousFrameHasBeenEdited = false;
        this.ActiveIdAllowNavDirFlags = 0;
        this.ActiveIdBlockNavInputFlags = 0;
        this.ActiveIdClickOffset = new Vec2(-1,-1);
        this.ActiveIdWindow = null;
        this.ActiveIdPreviousFrameWindow = null;
        this.ActiveIdSource = InputSource.None;
        this.LastActiveId = 0;
        this.LastActiveIdTimer = 0.;
        this.LastValidMousePos = new Vec2(0., 0.);
        this.MovingWindow = null;
        this.ColorModifiers = new ArrayEx();
        this.StyleModifiers = new ArrayEx();
        this.FontStack = new ArrayEx();
        this.OpenPopupStack = new ArrayEx();
        this.BeginPopupStack = new ArrayEx();
        this.NextWindowData = new NextWindowData();
        this.NextTreeNodeOpenVal = false;
        this.NextTreeNodeOpenCond = CondFlags.None;

        // Navigation data (from gamepad/keyboard)
        this.NavWindow = null; // focused window
        this.NavId = 0;  // GuiID
        this.NavActivateId = 0;
        this.NavActivateDownId = 0;
        this.NavActivatePressedId = 0;
        this.NavInputId = 0;
        this.NavJustTabbedId = 0;
        this.NavJustMovedToId = 0;
        this.NavJustMovedToSelectScopeId = 0;
        this.NavNextActivateId = 0;
        this.NavInputSource = InputSource.None;
        this.NavScoringRectScreen = new Rect();
        this.NavScoringCount = 0;
        this.NavWindowingTarget = null; // window
        this.NavWindowingTargetAnim = null; // window
        this.NavWindowingList = null; // window
        this.NavWindowingTimer = 0.;
        this.NavWindowingHighlightAlpha = 0.;
        this.NavWindowingToggleLayer = false;
        this.NavLayer = NavLayer.Main;
            // Layer we are navigating on. For now the system is hard-coded for
            // 0=main contents and 1=menu/title bar, may expose layers later.
        this.NavIdTabCounter = Number.MAX_SAFE_INTEGER;
            // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing
        this.NavIdIsAlive = false;
        this.NavMousePosDirty = false;
        this.NavDisableHighlight = true;
        this.NavDisableMouseHover = false;
        this.NavAnyRequest = false;
        this.NavInitRequest = false;
        this.NavInitRequestFromMove = false;
        this.NavInitResultId = 0;
        this.NavMoveFromClampedRefRect = false;
        this.NavMoveRequest = false;
        this.NavMoveRequestFlags = 0;
        this.NavMoveRequestForward = NavForward.None;
        this.NavMoveDir = Dir.None;
        this.NavMoveDirLast = Dir.None;
        this.NavMoveClipDir = Dir.None;
        this.NavMoveResultLocal = new NavMoveResult();
            // Best move request candidate within NavWindow
        this.NavMoveResultLocalVisibleSet = new NavMoveResult();
            // Best move request candidate within NavWindow that are mostly
            // visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
        this.NavMoveResultOther = new NavMoveResult();
            // Best move request candidate within NavWindow's flattened hierarchy
            // (when using WindowFlags.NavFlattened flag)

        // tabbing system (older than nav, ...)
        this.FocusRequestCurrWindow = null;
        this.FocusRequestNextWindow = null;
        this.FocusRequestCurrCounterAll = Number.MAX_SAFE_INTEGER;
        this.FocusRequestCurrCounterTab = Number.MAX_SAFE_INTEGER;
        this.FocusRequestNextCounterAll = Number.MAX_SAFE_INTEGER;
        this.FocusRequestNextCounterTab = Number.MAX_SAFE_INTEGER;
        this.FocusTabPressed = false;

        this.DimBgRatio = 0.; // [0,1] for anim fades
        this.DrawList = new DrawList(imgui, "guictx");

        // BackgroundDrawList
        // ForegroundDrawList
        this.MouseCursor = MouseCursor.Arrow;

        // Drag and Drop
        this.DragDropActive = false;
        this.DragDropWithinSourceOrTarget = false;
        this.DragDropSourceFlags = 0;
        this.DragDropSourceFrameCount = -1;
        this.DragDropMouseButton = -1;
        this.DragDropPayload = new Payload();
        this.DragDropTargetRect = new Rect();
        this.DragDropTargetId = 0;
        this.DragDropAcceptFlags = 0;
        this.DragDropAcceptIdCurrRectSurface = 0.;
        this.ActiveIdDragDropAcceptIdCurr = 0;
        this.DragDropAcceptIdPrev = 0;
        this.DragDropAcceptFrameCount = -1;

        // Tab bars
        this.TabBars = {}; // pool of TabBar
        this.CurrentTabBar = null;
        this.CurrentTabBarStack = new ArrayEx(); // of TabBarRef
        this.TabSortByWidthBuffer = new ArrayEx(); // of TabBarSortItem

        // Widget state
        this.InputTextState = new InputTextState(this); // of InputTextState
        this.InputTextPasswordFont = null;
        this.ScalarAsInputTextId = 0; // id of temporary text input when ctrl+clicking
        this.ColorEditOptions = ColorEditFlags.OptionsDefault;
        this.ColorPickerRef = Color.rgba();
        this.DragCurrentAccumDirty = false;
        this.DragCurrentAccum = 0.;
        this.DragSpeedDefaultRatio = 1. / 100.;
        this.ScrollbarClickDeltaToGrabCenter = new Vec2(0., 0.);
        this.TooltipOverrideCount = 0;
        this.PrivateClipboard = null; // char array

        // Range-select/multie-select (unused?)
        this.MultiSelectScopeId = 0;

        // Platform input method support
        this.PlatformImePos = new Vec2(Number.MAX_VALUE, Number.MAX_VALUE);
        this.PlatformImeLastPos = new Vec2(Number.MAX_VALUE, Number.MAX_VALUE);

        // Settings
        this.SettingsLoaded = false;
        this.SettingsDirtyTimer = 0.;
        this.SettingsHandlers = new ArrayEx(); // list of SettingsHandler
        this.SettingsHandlers.push(new WindowsSettingsHandler());
        this.SettingsHandlers.push(this.Style);
        this.SettingsWindows = new ArrayEx();// list of WindowSettings
        this.SettingsIniData = ""; // json-string of all settings

        // Logging
        this.LogEnabled = false;
        this.LogType = LogType.None;
        this.LogFile = null;
        this.LogLinePosY = Number.MAX_VALUE;
        this.LogLineFirstItem = false;
        this.LogDepthRef = 0;
        this.LogDepthToExpand = this.LogDepthToExpandDefault = 2;

        // Misc
        this.FramerateSecPerFrame = new ArrayEx(); // keep two seconds of framerates for avg
        this.FramerateSecPerFrame.length = 120;
        this.FramerateSecPerFrame.fill(0);
        this.FramerateSecPerFrameIdx = 0;
        this.FramerateSecPerFrameAccum = 0.;
        this.WantCaptureMouseNextFrame = -1;
        this.WantCaptureKeyboardNextFrame = -1;
        this.WantTextInputNextFrame = -1;

        this.TempBuffer = new ArrayEx();
    }

    NewFrame(time)
    {
        this.IO.NewFrame(time);
    }

    EndFrame()
    {
        this.IO.EndFrame();
    }
}

// =====================================================================================================================
// guictx.js END
// =====================================================================================================================
// =====================================================================================================================
// settings.js BEGIN
// =====================================================================================================================


// initially our settings will be stored in a single json string
// of the form:
//  {
//      "Type1": {
//          "Entity1": {encapsulation},
//          "Entity2": {encapsulation}
//       },
//      "Type2": {
//          "Entity1": {encapsulation},
//          "Entity2": {encapsulation}
//       }
//  }

// We expect a subclass of SettingsHandler for each serializable datatype.
// The SettingsHandler manager reads/writes the single json file.
class SettingsHandler
{
    constructor() {}
    GetTypeName() {console.assert(0);}
    // return an object appropriate for JSON.stringify
    Encapsulate(imgui) {console.assert(0);}
    // obj is a parsed json obj
    Instantiate(imgui, obj) {console.assert(0);}
}

class WindowSettings
{
    constructor(o)
    {
        this.Name = null;
        this.ID = 0;
        this.Pos = new Vec2();
        this.Size = new Vec2();
        this.Collapsed = false;
    }

    Encapsulate()
    {
        return this;
    }

    Instantiate(o)
    {
        this.Name = o.Name;
        this.ID = o.ID;
        this.Pos.x = o.Pos.x;
        this.Pos.y = o.Pos.y;
        this.Size.x = o.Size.x;
        this.Size.y = o.Size.y;
        this.Collapsed = o.Collapsed;
    }
}

class WindowsSettingsHandler extends SettingsHandler
{
    constructor()
    {
        super();
    }
    GetTypeName() { return "Windows"; }
    Encapsulate(imgui) // we read from the real windows list
    {
        let g = imgui.guictx;
        let o = {};
        for(let win of g.Windows)
        {
            if(win.Flags & WindowFlags.NoSavedSettings)
                continue;
            let settings = (win.SettingsIdx != -1) ?
                            g.SettingsWindows[win.SettingsIdx] :
                            imgui.findWindowSettings(win.ID);
            if (!settings)
            {
                settings = imgui.createNewWindowSettings(win.Name);
                win.SettingsIdx = g.SettingsWindows.indexOf(settings);
            }
            console.assert(settings.ID == win.ID);
            settings.Pos.Copy(win.Pos);
            settings.Size.Copy(win.SizeFull);
            settings.Collapsed = win.Collapsed;
            o[win.Name] = settings.Encapsulate();
        }
        return o;
    }
    Instantiate(imgui, strOrObj)
    {
        let g = imgui.guictx;
        try
        {
            let o = typeof(strOrObj) == "string" ? JSON.parse(strOrObj) : strOrObj;
            let extra = [];
            for(let key in o)
            {
                let ws = null;
                for(let w of g.SettingsWindows)
                {
                    if(key == w.Name)
                    {
                        ws = w;
                        break;
                    }
                }
                if (ws == null)
                {
                    ws = new WindowSettings();
                    extra.push(ws);
                }
                ws.Instantiate(o[key]);
            }
            for(let el of extra)
                g.SettingsWindows.push(el);
        }
        catch(err)
        {
            console.error("JSON parse error: " + err);
        }
    }
}

var ImguiSettingsMixin =
{
    // - The disk functions are automatically called if io.IniFilename != NULL
    //   (default is "imgui.ini").
    // - Set io.IniFilename to NULL to load/save manually. Read
    //  io.WantSaveIniSettings description about handling .ini saving manually.

    // call after CreateContext() and before the first call to NewFrame().
    // NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
    LoadIniSettingsFromDisk(ini_filename=null)
    {
        if(ini_filename == null)
            ini_filename = this.guictx.IO.IniFilename;
        // for now, we'll use localStorage:
        let d = window.localStorage.getItem(ini_filename);
        if(d)
           this.LoadIniSettingsFromMemory(d);
    },

    // this is automatically called (if io.IniFilename is not empty) a few
    // seconds after any modification that should be reflected in the .ini
    // file (and also by DestroyContext).
    SaveIniSettingsToDisk(ini_filename)
    {
        let g = this.guictx;
        g.SettingsDirtyTimer = 0;
        if (!ini_filename)
            return;
        let value = this.SaveIniSettingsToMemory();
        if(value)
            window.localStorage.setItem(ini_filename, value);
    },


    // call after CreateContext() and before the first call to NewFrame() to
    // provide .ini data from your own data source.
    LoadIniSettingsFromMemory(json)
    {
        try
        {
            let o = JSON.parse(json);
            for(let key in o)
            {
                let h = this.FindSettingsHandler(key);
                if(h)
                    h.Instantiate(this, o[key]);
            }
            this.guictx.SettingsLoaded = true;
        }
        catch(err)
        {
            console.error("Problem parsing settings", err);
        }
    },

    // return a zero-terminated string with the .ini data which you can
    // save by your own means. call when io.WantSaveIniSettings is set,
    // then save data by your own mean and clear io.WantSaveIniSettings.
    SaveIniSettingsToMemory(pretty=false)
    {
        let g = this.guictx;
        g.SettingsDirtyTimer = 0.;
        let o = {};
        for(let handler_n = 0; handler_n < g.SettingsHandlers.length; handler_n++)
        {
            let handler = g.SettingsHandlers[handler_n];
            let typename = handler.GetTypeName();
            o[typename] = handler.Encapsulate(this);
        }
        if(pretty)
            g.SettingsIniData = JSON.stringify(o, null, 2);
        else
            g.SettingsIniData = JSON.stringify(o);
        return g.SettingsIniData;
    },

    MarkIniSettingsDirty(win=null)
    {
        if(win && win.Flags & WindowFlags.NoSavedSettings)
            return;
        let g = this.guictx;
        if (g.SettingsDirtyTimer <= 0)
            g.SettingsDirtyTimer = g.IO.IniSavingRate;
    },

    createNewWindowSettings(name)
    {
        let g = this.guictx;
        g.SettingsWindows.push_back(new WindowSettings());
        let wSetting = g.SettingsWindows.back();
        wSetting.Name = name;
        wSetting.ID = GetHash(name);
        return wSetting;
    },

    findWindowSettings(id)
    {
        let g = this.guictx;
        for (let i = 0; i != g.SettingsWindows.length; i++)
        {
            if (g.SettingsWindows[i].ID == id)
                return g.SettingsWindows[i];
        }
        return null;
    },

    findOrCreateWindowSettings(name)
    {
        let settings = this.findWindowSettings(GetHash(name));
        if (settings)
            return settings;
        return this.createNewWindowSettings(name);
    },

    FindSettingsHandler(type_name)
    {
        let g = this.guictx;
        for(let i=0;i<g.SettingsHandlers.length;i++)
        {
            let h = g.SettingsHandlers[i];
            if(h.GetTypeName() === type_name)
                return h;
        }
        return null;
    },
};

// =====================================================================================================================
// settings.js END
// =====================================================================================================================
// =====================================================================================================================
// fontmetrics.js BEGIN
// =====================================================================================================================


// modified version of:
//   https://github.com/soulwire/FontMetrics, license: MIT
//
// see also: https://smad.jmu.edu/shen/webtype/index.html
//
const sStdMeasureChars =
{
    capHeight: "S",
    baseline: "n",
    xHeight: "x",
    descent: "p",
    ascent: "h",
    tittle: "i"
};

class FontMetrics
{
    constructor()
    {
        this.initialized = false;
        this.padding = null;
        this.context = null;
        this.canvas = null;
    }

    initialize()
    {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.initialized = true;
    }

    MeasureFont(family, size, weight, style, bypass)
    {
        this.SetFont(family, size, weight, style);
        return this.GetMetrics(bypass ? null : sStdMeasureChars);
    }

    SetFont(fontFamily, fontSize, fontWeight, fontStyle)
    {
        if (!this.initialized)
            this.initialize();
        this.fontFamily = fontFamily;
        this.fontSize = fontSize;
        this.fontWeight = fontWeight;
        this.fontStyle = fontStyle;
        this.padding = fontSize * 0.5;
        this.canvas.width = fontSize * 2;
        this.canvas.height = fontSize * 2 + this.padding;
        this.context.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
        this.context.textBaseline = "top";
        this.context.textAlign = "center";
    }

    GetMetrics(chars=sStdMeasureChars)
    {
        // These values are measured relative to the top, (ie: all positive)
        // More commonly, fonts are measured relative to baseline. Now the
        // question is should y go up or down.
        if(chars == null)
            return {
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontWeight: this.fontWeight,
                capHeight: 0,
                baseline: this.fontSize,
                xHeight: this.fontSize*.5,
                descent: this.fontSize,
                bottom: this.fontSize,
                ascent: 0,
                tittle: this.fontSize*.5,
                top: 0,
            };
        else
            return {
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontWeight: this.fontWeight,
                capHeight: this.measureTop(chars.capHeight),
                baseline: this.measureBottom(chars.baseline),
                xHeight: this.measureTop(chars.xHeight),
                descent: this.measureBottom(chars.descent),
                bottom: this.computeLineHeight(),
                ascent: this.measureTop(chars.ascent),
                tittle: this.measureTop(chars.tittle),
                top: 0,
            };
    }

    setAlignment(baseline="top")
    {
        const ty = baseline === "bottom" ? this.canvas.height : 0;
        this.context.setTransform(1, 0, 0, 1, 0, ty);
        this.context.textBaseline = baseline;
    }

    updateText(text)
    {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.fillText(text, this.canvas.width/2, this.padding, this.canvas.width);
    }

    computeLineHeight()
    {
        const letter = "A";
        this.setAlignment("bottom");
        const gutter = this.canvas.height - this.measureBottom(letter);
        this.setAlignment("top");
        return this.measureBottom(letter) + gutter;
    }

    getPixels(text)
    {
        this.updateText(text);
        return this.context.getImageData(0, 0, this.canvas.width, this.canvas.height).data;
    }

    getFirstIndex(pixels)
    {
        for (let i = 3, n = pixels.length; i < n; i += 4)
        {
            if (pixels[i] > 0)
                return (i - 3) / 4;
        }
        return pixels.length;
    }

    getLastIndex(pixels)
    {
        for (let i = pixels.length - 1; i >= 3; i -= 4)
        {
            if (pixels[i] > 0)
                return i / 4;
        }
        return 0;
    }

    normalize(metrics, fontSize, origin)
    {
        const result = {};
        const offset = metrics[origin];
        for (let key in metrics)
            result[key] = (metrics[key] - offset) / fontSize;
        return result;
    }

    measureTop(text)
    {
        return Math.round(this.getFirstIndex(this.getPixels(text))/this.canvas.width)
                - this.padding;
    }

    measureBottom(text)
    {
        return Math.round(this.getLastIndex(this.getPixels(text))/this.canvas.width)
                - this.padding;
    }
}

// =====================================================================================================================
// fontmetrics.js END
// =====================================================================================================================
// =====================================================================================================================
// geoutil.js BEGIN
// =====================================================================================================================


function LineClosestPoint(a, b, p)
{
    let ap = Vec2.Subtract(p, a);
    let abDir = Vec2.Subtract(b, a);
    let dot = Vec2.dot(ap, abDir);
    if(dot < 0)
        return a;
    let abLenSq = Vec2.dot(abDir, abDir);
    if(dot > abLenSq)
        return b;
    else
        return Vec2.Add(a, Vec2.Scale(abDir,dot/abLenSq));
}


function TriangleContainsPoint(a, b, c, p) // all args are Vec2
{
    let b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.;
    let b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0;
    let b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0;
    return ((b1 == b2) && (b2 == b3));
}

// returns tuple(u,v,w)
function TriangleBarycentricCoords(a, b, c, p)
{
    let v0 = Vec2.Subtract(b, a);
    let v1 = Vec2.Subtract(c, a);
    let v2 = Vec2.Subtrace(p, a);
    const denom = v0.x * v1.y - v1.x * v0.y;
    let out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
    let out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
    let out_u = 1. - out_v - out_w;
    return [out_v, out_w, out_u];
}

// return Vec2
function TriangleClosestPoint(a, b, c, p)
{
    let proj_ab = LineClosestPoint(a, b, p);
    let proj_bc = LineClosestPoint(b, c, p);
    let proj_ca = LineClosestPoint(c, a, p);
    let dist2_ab = Vec2.LengthSqr(p, proj_ab);
    let dist2_bc = Vec2.LengthSqr(p, proj_bc);
    let dist2_ca = Vec2.LengthSqr(p, proj_ca);
    let m = Math.min(dist2_ab, dist2_bc, dist2_ca);
    if (m == dist2_ab)
        return proj_ab;
    if (m == dist2_bc)
        return proj_bc;
    return proj_ca;
}

// =====================================================================================================================
// geoutil.js END
// =====================================================================================================================
// =====================================================================================================================
// color.js BEGIN
// =====================================================================================================================


class ColorMod
{
    constructor(field, backupValue)
    {
        this.Field = field; // aka: Col (we use field name, not idx)
        this.BackupValue = backupValue;
    }
}

function _lerp(v, a, b)
{
    return a + (b - a) * v;
}

var CSSColors = {}; // filled below
var Colors = {}; // filled below

class Color
{
    static RandomCss()
    {
        let keys = Object.keys(CSSColors);
        let i = Math.floor(Math.random() * keys.length);
        return Color.Css(keys[i]);
    }

    static Random(min=0, max=1)
    {
        return Color.rgb(
            _lerp(Math.random(), min, max),
            _lerp(Math.random(), min, max),
            _lerp(Math.random(), min, max),
                );
    }

    static Css(nm)
    {
        return CSSColors[nm].Clone();
    }

    static FromArray(c, alpha=true, space=undefined)
    {
        return new Color(c[0], c[1], c[2], alpha?c[3] : 1, space);
    }

    static FromCSS(cstr)
    {
        let m = /^(rgba?)\s*\(([^)]*)\)/.exec(cstr);
        let fields;
        if (m)
        {
            fields = m[2].split(",").map((x, i) => {
                    if(i < 3) return parseFloat(x)/255;
                    else return parseFloat(x);
                });
        }
        else
        if (/^#[A-Fa-f0-9]+$/.test(cstr))
        {
            var base = cstr.slice(1);
            var size = base.length;
            let parts = base.split(size <= 4 ? /(.)/ : /(..)/)
                            .filter((x)=>x!="");
            fields = parts.map(function (x) {
                    if (size <= 4)
                        return parseInt(x+"0", 16)/255;
                    else
                        return parseInt(x, 16)/255;
                });
        }
        else
            return null;

        if(fields.length == 3)
            return Color.rgb(fields[0], fields[1], fields[2]);
        else
            return Color.rgba(fields[0], fields[1], fields[2], fields[3]);
    }

    static rgbi(r, g, b)
    {
        if(r === undefined)
        {
            r = g = b = 0;
        }
        return new Color(r/255.0, g/255.0, b/255.0, 1);
    }

    static rgbai(r, g, b, a)
    {
        if(r === undefined)
        {
            r = g = b = 0;
            a = 1;
        }
        return new Color(r/255.0, g/255.0, b/255.0, a/255.0);
    }

    static rgb(r, g, b)
    {
        if(r === undefined)
        {
            r = g = b = 0;
        }
        return new Color(r, g, b, 1);
    }

    static rgba(r, g, b, a)
    {
        if(r === undefined)
        {
            r = g = b = 0;
            a = 1;
        }
        return new Color(r, g, b, a);
    }

    static hsv(h, s, v)
    {
        return new Color(h, s, v, 1, "hsv");
    }

    static hsva(h, s, v , a)
    {
        return new Color(h, s, v, a, "hsv");
    }

    static hsl(h, s, l)
    {
        return new Color(h, s, l, 1., "hsl");
    }

    static hsla(h, s, l , a)
    {
        return new Color(h, s, l, a, "hsl");
    }

    static Lerp(a, b, pct)
    {
        console.assert(a.space == b.space);
        return new Color(
            a.x + (b.x - a.x) * pct,
            a.y + (b.y - a.y) * pct,
            a.z + (b.z - a.z) * pct,
            a.a + (b.a - a.a) * pct);
    }

    static Blend(a, b) // b over a
    {
        let t = b.a;
        if(t == 1) return b;
        if(t == 0) return a;
        let under = a.AsRGB();
        let over = b.AsRGB();
        let x = Vec1.Lerp(under.x, over.x, t);
        let y = Vec1.Lerp(under.y, over.y, t);
        let z = Vec1.Lerp(under.z, over.z, t);
        return new Color(x,y,z);
    }

    static Instantiate(str)
    {
        let c = new Color();
        let fields = str.split(" ");
        console.assert(fields.length == 5);
        c.space = fields[0];
        c.x = Number(fields[1]);
        c.y = Number(fields[2]);
        c.z = Number(fields[3]);
        c.a = Number(fields[4]);
        return c;
    }

    constructor(x, y, z, a, space="rgb") // rgb, hsv, hsl
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.space = space;
        this.a = a === undefined ? 1 : a;
        this.str = null;
    }

    Encapsulate()
    {
        return `${this.space} ${this.x.toFixed(3)} ` +
              `${this.y.toFixed(3)} ${this.z.toFixed(3)} ${this.a.toFixed(3)}`;
    }

    Copy(src)
    {
        this.x = src.x;
        this.y = src.y;
        this.z = src.z;
        this.a = src.a;
        this.space = src.space;
        this.str = null;
    }

    CopyArray(src)
    {
        this.x = src[0];
        this.y = src[1];
        this.z = src[2];
        this.a = src[3];
        this.str = null;
    }

    Equals(other)
    {
        return this.AsStr() == other.AsStr();
    }

    Clone()
    {
        // don't clone str
        return new Color(this.x, this.y, this.z, this.a, this.space);
    }

    // after editing a color, clear the str rep cache.
    Dirty()
    {
        if(this.str)
            this.str = null;
    }

    Index(i)
    {
        if(i==0) return this.x;
        if(i==1) return this.y;
        if(i==2) return this.z;
        if(i==3) return this.a;
    }

    AsArray(space=null)
    {
        if(space == null || space == this.space)
            return [this.x, this.y, this.z, this.a];
        else
        {
            console.assert(0, "could do more work here.");
            return [];
        }
    }

    AsIArray()
    {
        return [ Math.round(255*this.x),
                 Math.round(255*this.y),
                 Math.round(255*this.z),
                 Math.round(255*this.a) ];
    }

    AsFloatStr(noalpha)
    {
        let x = this.x.toFixed(3);
        let y = this.y.toFixed(3);
        let z = this.z.toFixed(3);
        if(noalpha)
            return `${this.space}(${x}, ${y}, ${z})`;

        let a = this.a.toFixed(3);
        return `${this.space}a(${x}, ${y}, ${z}, ${a})`;
    }

    AsIntStr(noalpha)
    {
        let x = Math.floor(this.x*255);
        let y = Math.floor(this.y*255);
        let z = Math.floor(this.z*255);
        if(noalpha)
            return `${this.space}(${x}, ${y}, ${z})`;
        let a = Math.floor(this.a*255);
        return `${this.space}a(${x}, ${y}, ${z}, ${a})`;
    }

    AsHashStr(noalpha=false) // hash strings always in RGB
    {
        let c = this.AsRGB();
        let r = ("0" + Math.floor(c.x*255).toString(16)).slice(-2);
        let g = ("0" + Math.floor(c.y*255).toString(16)).slice(-2);
        let b = ("0" + Math.floor(c.z*255).toString(16)).slice(-2);
        if(noalpha)
            return `#${r}${g}${b}`.toUpperCase();
        else
        {
            let a = ("0" + Math.floor(c.a*255).toString(16)).slice(-2);
            return `#${r}${g}${b}${a}`.toUpperCase();
        }
    }

    AsHexStr(noalpha=false) // hex strings always in rgb (currently)
    {
        let c = this.AsRGB();
        let r = ("0" + Math.floor(c.x*255).toString(16)).slice(-2);
        let g = ("0" + Math.floor(c.y*255).toString(16)).slice(-2);
        let b = ("0" + Math.floor(c.z*255).toString(16)).slice(-2);
        if(noalpha)
            return `0x${r}${g}${b}`;
        else
        {
            let a = ("0" + Math.floor(c.a*255).toString(16)).slice(-2);
            return `0x${r}${g}${b}${a}`;
        }
    }

    // XXX: alphaMult?
    AsStr(alphaMult=1)
    {
        if(this.str) return this.str;
        let c = this.AsRGB();
        let r = (c.x * 255).toFixed(0);
        let g = (c.y * 255).toFixed(0);
        let b = (c.z * 255).toFixed(0);
        let a = c.a.toFixed(3);
        this.str = `rgba(${r},${g},${b},${a})`;
        return this.str;
    }

    AsMultiStr(noalpha=false)
    {
        switch(this.space)
        {
        case "rgb":
            {
                let hstr = this.AsHashStr(noalpha);
                let dstr = this.AsIntStr(noalpha);
                let fstr = this.AsFloatStr(noalpha);
                return `${hstr}\n${dstr}\n${fstr}`;
            }
        case "hsv":
            {
                let dstr = this.AsIntStr(noalpha);
                let fstr = this.AsFloatStr(noalpha);
                return `${dstr}\n${fstr}`;
            }
        case "hsl":
            console.assert(0, "unimplemented");
            break;
        }
    }

    AsOpaque()
    {
        if(this.a == 1) return this;
        return new Color(this.x, this.y, this.z, 1, this.space);
    }

    AsRGB(alphaMult=1, clone=false)
    {
        switch(this.space)
        {
        case "rgb":
            if(alphaMult == 1 && !clone)
                return this;
            else
                return new Color(this.x, this.y, this.z, this.a*alphaMult);
        case "hsv": // hsv to rgb
            {
                let h = this.x;
                let s = this.y;
                let v = this.z;
                let r, g, b;
                let i = Math.floor(h * 6);
                let f = h * 6 - i;
                let p = v * (1 - s);
                let q = v * (1 - f * s);
                let t = v * (1 - (1 - f) * s);

                switch (i % 6)
                {
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
                }
                return new Color(r, g, b, this.a*alphaMult);
            }
        case "hsl": // hsl to rgb
            {
                let r, g, b;
                let h = this.x;
                let s = this.y;
                let l = this.z;
                if (this.y == 0)
                  r = g = b = this.z; // achromatic
                else
                {
                    let hue2rgb = function(p, q, t)
                    {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3-t) * 6;
                        return p;
                    };

                    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    var p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return new Color(r, g, b, this.a*this.alphaMult);
            }
        }
    }

    AsHSL()
    {
        switch(this.space)
        {
        case "rgb": // rgb to hsl
            {
                let r = this.x;
                let g = this.y;
                let b = this.z;
                let a = this.a;
                let max = Math.max(r, g, b);
                let min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max == min)
                {
                    h = 0;
                    s = 0;
                }
                else
                {
                    var d = max - min;
                    s = l > 0.5 ? d / (2-max-min) : d / (max+min);
                    switch (max)
                    {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                    }
                    h /= 6;
                }
                return new Color(h, s, l, a, "hsl");
            }
        case "hsl":
            return this;
        case "hsv": // to hsv to rsl
            return this.AsRGB().AsHSL();
        }
    }

    AsHSV(clone=false)
    {
        switch(this.space)
        {
        case "rgb": // rgb to hsv
            {
                let K = 0;
                let t;
                let r = this.x;
                let g = this.y;
                let b = this.z;
                if (g < b)
                {
                    t = g;
                    g = b;
                    b = t;
                    K = -1;
                }
                if (r < g)
                {
                    t = r;
                    r = g;
                    g = t;
                    K = -2 / 6 - K;
                }
                const chroma = r - (g < b ? g : b);
                let h = Math.abs(K + (g - b) / (6 * chroma + 1e-20));
                let s = chroma / (r + 1e-20);
                let v = r;
                return new Color(h, s, v, this.a, "hsv");
            }
        case "hsl": // hsl to hsv
            return this.AsRGB().AsHSV();
        case "hsv":
            if(!clone)
                return this;
            else
                return this.Clone();
        }
    }

    rgbaStr()
    {
        let c = this.AsRGB();
        return "rgba(" +
                (255*c.x).toFixed(0) + "," +
                (255*c.y).toFixed(0) + "," +
                (255*c.z).toFixed(0) + "," +
                this.a.toFixed(3) + ")";
    }

    hslaStr()
    {
        // h: [0-360], s,l: ptc "0-100%"
        let c = this.AsHSL();
        return "hsla(" +
                (360*c.x).toFixed(0) + "," +
                (100*c.y).toFixed(0) + "%," +
                (100*c.z).toFixed(0) + "%," +
                this.a.toFixed(3) + ")";
    }

}

// https://www.w3schools.com/colors/colors_names.asp
CSSColors =
{
    aliceblue:	Color.rgbi(240,248,255),
    antiquewhite:	Color.rgbi(250,235,215),
    aqua:	Color.rgbi(0,255,255),
    aquamarine:	Color.rgbi(127,255,212),
    azure:	Color.rgbi(240,255,255),
    beige:	Color.rgbi(245,245,220),
    bisque:	Color.rgbi(255,228,196),
    black:	Color.rgbi(0,0,0),
    blanchedalmond:	Color.rgbi(255,235,205),
    blue:	Color.rgbi(0,0,255),
    blueviolet:	Color.rgbi(138,43,226),
    brown:	Color.rgbi(165,42,42),
    burlywood:	Color.rgbi(222,184,135),
    cadetblue:	Color.rgbi(95,158,160),
    chartreuse:	Color.rgbi(127,255,0),
    chocolate:	Color.rgbi(210,105,30),
    coral:	Color.rgbi(255,127,80),
    cornflowerblue:	Color.rgbi(100,149,237),
    cornsilk:	Color.rgbi(255,248,220),
    crimson:	Color.rgbi(220,20,60),
    cyan:	Color.rgbi(0,255,255),
    darkblue:	Color.rgbi(0,0,139),
    darkcyan:	Color.rgbi(0,139,139),
    darkgoldenrod:	Color.rgbi(184,134,11),
    darkgray:	Color.rgbi(169,169,169),
    darkgreen:	Color.rgbi(0,100,0),
    darkgrey:	Color.rgbi(169,169,169),
    darkkhaki:	Color.rgbi(189,183,107),
    darkmagenta:	Color.rgbi(139,0,139),
    darkolivegreen:	Color.rgbi(85,107,47),
    darkorange:	Color.rgbi(255,140,0),
    darkorchid:	Color.rgbi(153,50,204),
    darkred:	Color.rgbi(139,0,0),
    darksalmon:	Color.rgbi(233,150,122),
    darkseagreen:	Color.rgbi(143,188,143),
    darkslateblue:	Color.rgbi(72,61,139),
    darkslategray:	Color.rgbi(47,79,79),
    darkslategrey:	Color.rgbi(47,79,79),
    darkturquoise:	Color.rgbi(0,206,209),
    darkviolet:	Color.rgbi(148,0,211),
    deeppink:	Color.rgbi(255,20,147),
    deepskyblue:	Color.rgbi(0,191,255),
    dimgray:	Color.rgbi(105,105,105),
    dimgrey:	Color.rgbi(105,105,105),
    dodgerblue:	Color.rgbi(30,144,255),
    firebrick:	Color.rgbi(178,34,34),
    floralwhite:	Color.rgbi(255,250,240),
    forestgreen:	Color.rgbi(34,139,34),
    fuchsia:	Color.rgbi(255,0,255),
    gainsboro:	Color.rgbi(220,220,220),
    ghostwhite:	Color.rgbi(248,248,255),
    gold:	Color.rgbi(255,215,0),
    goldenrod:	Color.rgbi(218,165,32),
    gray:	Color.rgbi(128,128,128),
    green:	Color.rgbi(0,128,0),
    greenyellow:	Color.rgbi(173,255,47),
    grey:	Color.rgbi(128,128,128),
    honeydew:	Color.rgbi(240,255,240),
    hotpink:	Color.rgbi(255,105,180),
    indianred:	Color.rgbi(205,92,92),
    indigo:	Color.rgbi(75,0,130),
    ivory:	Color.rgbi(255,255,240),
    khaki:	Color.rgbi(240,230,140),
    lavender:	Color.rgbi(230,230,250),
    lavenderblush:	Color.rgbi(255,240,245),
    lawngreen:	Color.rgbi(124,252,0),
    lemonchiffon:	Color.rgbi(255,250,205),
    lightblue:	Color.rgbi(173,216,230),
    lightcoral:	Color.rgbi(240,128,128),
    lightcyan:	Color.rgbi(224,255,255),
    lightgoldenrodyellow:	Color.rgbi(250,250,210),
    lightgray:	Color.rgbi(211,211,211),
    lightgreen:	Color.rgbi(144,238,144),
    lightgrey:	Color.rgbi(211,211,211),
    lightpink:	Color.rgbi(255,182,193),
    lightsalmon:	Color.rgbi(255,160,122),
    lightseagreen:	Color.rgbi(32,178,170),
    lightskyblue:	Color.rgbi(135,206,250),
    lightslategray:	Color.rgbi(119,136,153),
    lightslategrey:	Color.rgbi(119,136,153),
    lightsteelblue:	Color.rgbi(176,196,222),
    lightyellow:	Color.rgbi(255,255,224),
    lime:	Color.rgbi(0,255,0),
    limegreen:Color.rgbi(50,205,50),
    linen:	Color.rgbi(250,240,230),
    magenta:	Color.rgbi(255,0,255),
    maroon:	Color.rgbi(128,0,0),
    mediumaquamarine:	Color.rgbi(102,205,170),
    mediumblue:	Color.rgbi(0,0,205),
    mediumorchid:	Color.rgbi(186,85,211),
    mediumpurple:	Color.rgbi(147,112,219),
    mediumseagreen:	Color.rgbi(60,179,113),
    mediumslateblue:	Color.rgbi(123,104,238),
    mediumspringgreen:	Color.rgbi(0,250,154),
    mediumturquoise:	Color.rgbi(72,209,204),
    mediumvioletred:	Color.rgbi(199,21,133),
    midnightblue:	Color.rgbi(25,25,112),
    mintcream:	Color.rgbi(245,255,250),
    mistyrose:	Color.rgbi(255,228,225),
    moccasin:	Color.rgbi(255,228,181),
    navajowhite:	Color.rgbi(255,222,173),
    navy:	Color.rgbi(0,0,128),
    oldlace:	Color.rgbi(253,245,230),
    olive:	Color.rgbi(128,128,0),
    olivedrab:	Color.rgbi(107,142,35),
    orange:	Color.rgbi(255,165,0),
    orangered:	Color.rgbi(255,69,0),
    orchid:	Color.rgbi(218,112,214),
    palegoldenrod:	Color.rgbi(238,232,170),
    palegreen:	Color.rgbi(152,251,152),
    paleturquoise:	Color.rgbi(175,238,238),
    palevioletred:	Color.rgbi(219,112,147),
    papayawhip:	Color.rgbi(255,239,213),
    peachpuff:	Color.rgbi(255,218,185),
    peru:	Color.rgbi(205,133,63),
    pink:	Color.rgbi(255,192,203),
    plum:	Color.rgbi(221,160,221),
    powderblue:	Color.rgbi(176,224,230),
    purple:	Color.rgbi(128,0,128),
    red:	Color.rgbi(255,0,0),
    rosybrown:	Color.rgbi(188,143,143),
    royalblue:	Color.rgbi(65,105,225),
    saddlebrown:	Color.rgbi(139,69,19),
    salmon:	Color.rgbi(250,128,114),
    sandybrown:	Color.rgbi(244,164,96),
    seagreen:	Color.rgbi(46,139,87),
    seashell:	Color.rgbi(255,245,238),
    sienna:	Color.rgbi(160,82,45),
    silver:	Color.rgbi(192,192,192),
    skyblue:	Color.rgbi(135,206,235),
    slateblue:	Color.rgbi(106,90,205),
    slategray:	Color.rgbi(112,128,144),
    slategrey:	Color.rgbi(112,128,144),
    snow:	Color.rgbi(255,250,250),
    springgreen:	Color.rgbi(0,255,127),
    steelblue:	Color.rgbi(70,130,180),
    tan:	Color.rgbi(210,180,140),
    teal:	Color.rgbi(0,128,128),
    thistle:	Color.rgbi(216,191,216),
    tomato:	Color.rgbi(255,99,71),
    turquoise:	Color.rgbi(64,224,208),
    violet:	Color.rgbi(238,130,238),
    wheat:	Color.rgbi(245,222,179),
    white:	Color.rgbi(255,255,255),
    whitesmoke:	Color.rgbi(245,245,245),
    yellow:	Color.rgbi(255,255,0),
    yellowgreen:	Color.rgbi(154,205,50),
};

for(let k in CSSColors)
{
    CSSColors[k].str = k;
}

var HueRampStr = [
    CSSColors.red.AsStr(),
    CSSColors.yellow.AsStr(),
    CSSColors.green.AsStr(),
    CSSColors.cyan.AsStr(),
    CSSColors.blue.AsStr(),
    CSSColors.magenta.AsStr(),
    CSSColors.red.AsStr(),
];

// simple, common, useful for debugging, overlaps with CSSColors
Colors =
{
    clear: Color.rgba(0,0,0,0),
    black: Color.rgb(0,0,0),
    gray:  Color.rgb(.5,.5,.5),
    white: Color.rgb(1,1,1),
    red: Color.rgb(1,0,0),
    green: Color.rgb(0,1,0),
    blue: Color.rgb(0,0,1),
    cyan: Color.rgb(0,1,1),
    yellow: Color.rgb(1,1,0),
    magenta: Color.rgb(1,0,1),

    dark1: Color.rgb(.05, .05, .08),
    dark2: Color.rgb(.08, .08, .10),
    dark3: Color.rgb(.10, .10, .15),
    mid1: Color.rgb(.4, .4, .4),
};


// =====================================================================================================================
// color.js END
// =====================================================================================================================
// =====================================================================================================================
// style.js BEGIN
// =====================================================================================================================


let rgba = Color.rgba;
let rgb = Color.rgb;
let rgbi = Color.rgbi;

// DarkColors is the Primary Style object... If you feel lazy
// just be sure to populate new entries there.  Those values
// will be automatically propagated to other canned styles.
// Clearly they may not be good choices, but at least the styles
// will all have the same keys.
var DarkColors = {};
let c = DarkColors;
let bgActive = rgb(0.16, 0.29, 0.48);
let bg = rgb(0.04, 0.04, 0.04);
DarkColors.Border = rgba(0.43, 0.43, 0.50, 0.50);
DarkColors.BorderShadow = rgba(0.0, 0.0, 0.0, 0.0);
DarkColors.Button = rgba(0.26, 0.59, 0.98, 0.40);
DarkColors.ButtonActive = rgba(0.06, 0.53, 0.98, 1.00);
DarkColors.ButtonHovered = rgba(0.26, 0.59, 0.98, 1.00);
DarkColors.CheckMark = rgba(0.26, 0.59, 0.98, 1.0);
DarkColors.CheckerOff = rgbi(64,64,64);
DarkColors.CheckerOn =  rgbi(204,204,204);
DarkColors.ChildBg = rgba(0.0, 0.0, 0.0, 0.0);
DarkColors.DragDropTarget = rgba(1.00, 1.00, 0.00, 0.90);
DarkColors.FBDir = rgb(.2, .9, .2);
DarkColors.FBFile = rgb(.8, .8, .8);
DarkColors.FBMkDir = rgb(.3, .6, 1);
DarkColors.FrameBg = rgba(0.16, 0.29, 0.48, 0.54);
DarkColors.FrameBgActive = rgba(0.26, 0.59, 0.98, 0.67);
DarkColors.FrameBgHovered = rgba(0.26, 0.59, 0.98, 0.40);
DarkColors.Header = rgba(0.26, 0.59, 0.98, 0.31);
DarkColors.HeaderActive = rgba(0.26, 0.59, 0.98, 1.00);
DarkColors.HeaderHovered = rgba(0.26, 0.59, 0.98, 0.80);
DarkColors.Link = rgb(.3, .6, .9);
DarkColors.LinkActive = rgb(.2, .9, .7);
DarkColors.LinkHovered = rgb(.4, .6, 1);
DarkColors.MenuBarBg = rgba(0.14, 0.14, 0.14, 1.);
DarkColors.ModalWindowDimBg = rgba(0.80, 0.80, 0.80, 0.35);
DarkColors.NavHighlight = rgba(0.26, 0.59, 0.98, 1.00);
DarkColors.NavWindowingDimBg = rgba(0.80, 0.80, 0.80, 0.20);
DarkColors.NavWindowingHighlight = rgba(1.00, 1.00, 1.00, 0.70);
DarkColors.PlotBg = rgb(.1, .1, .1);
DarkColors.PlotHistogram = rgba(0.90, 0.70, 0.00, 1.00);
DarkColors.PlotHistogramDimmed = rgba(0.45, 0.35, 0.00, 1.00);
DarkColors.PlotHistogramHovered = rgba(1.00, 0.60, 0.00, 1.00);
DarkColors.PlotLines = rgba(0.61, 0.61, 0.61, 1.0);
DarkColors.PlotLinesDimmed = rgba(0.3, 0.3, 0.3, 1.0);
DarkColors.PlotLinesHovered = rgba(1.00, 0.43, 0.35, 1.00);
DarkColors.PlotSignal = rgba(0.90, 0.70, 0.00, 1.00);
DarkColors.PlotSignalDimmed = rgba(0.45, 0.35, 0.0, 1.0);
DarkColors.PlotSignalHovered = rgba(1.00, 0.43, 0.35, 1.00);
DarkColors.PopupBg = rgba(0.08, 0.08, 0.08, 0.94);
DarkColors.ResizeGrip = rgba(0.26, 0.59, 0.98, 0.25);
DarkColors.ResizeGripActive = rgba(0.26, 0.59, 0.98, 0.95);
DarkColors.ResizeGripHovered = rgba(0.26, 0.59, 0.98, 0.67);
DarkColors.ScrollbarBg = rgba(0.02, 0.02, 0.02, 0.53);
DarkColors.ScrollbarGrab = rgba(0.31, 0.31, 0.31, 1.);
DarkColors.ScrollbarGrabActive = rgba(0.51, 0.51, 0.51, 1.);
DarkColors.ScrollbarGrabHovered = rgba(0.41, 0.41, 0.41, 1.);
DarkColors.Separator = c.Border;
DarkColors.SeparatorActive = rgba(0.10, 0.40, 0.75, 1.00);
DarkColors.SeparatorHovered = rgba(0.10, 0.40, 0.75, 0.78);
DarkColors.SliderGrab = rgba(0.24, 0.52, 0.88, 1.0);
DarkColors.SliderGrabActive = rgba(0.26, 0.59, 0.98, 1.0);
DarkColors.Tab = Color.Lerp(c.Header, bgActive, 0.80);
DarkColors.TabActive = Color.Lerp(c.HeaderActive, bgActive, 0.6);
DarkColors.TabHovered = c.HeaderHovered;
DarkColors.TabUnfocused = Color.Lerp(c.Tab, bg, 0.8);
DarkColors.TabUnfocusedActive = Color.Lerp(c.TabActive, bg, 0.4);
DarkColors.Text = rgb(.9, .9, .9);
DarkColors.TextDisabled = rgb(0.5, 0.5, 0.5);
DarkColors.TextEmphasized = rgb(0.8, 1, 0.8);
DarkColors.TextHighlighted = rgbi(25, 211, 97);
DarkColors.TextError = CSSColors.darkorange;
DarkColors.TextSelectedBg = rgba(0.26, 0.59, 0.98, 0.35);
DarkColors.TitleBg = bg;
DarkColors.TitleBgActive = bgActive;
DarkColors.TitleBgCollapsed = rgba(0.0, 0.0, 0.0, 0.51);
DarkColors.WindowBg = rgba(0.06, 0.06, 0.06, 0.94);

DarkColors.DEBUG = rgb(.2, .4, .9);
DarkColors.INFO = rgb(.3, .8, .9);
DarkColors.NOTICE = rgb(.4, .9, .4);
DarkColors.WARNING = CSSColors.darkorange;
DarkColors.ALERT = CSSColors.darkorange;
DarkColors.ERROR = rgb(1, 0, 0);
DarkColors._DEBUG0 = rgba(1, 0, 0, .5);
DarkColors._DEBUG1 = rgba(0, 1, 0, .5);
DarkColors._DEBUG2 = rgba(0, 0, 1, .5);
DarkColors._DEBUG3 = rgba(1, 1, 0, .5);

var ClassicColors = Object.assign({}, DarkColors); // inherit from Dark
c = ClassicColors;
ClassicColors.Border = rgba(0.50, 0.50, 0.50, 0.50);
ClassicColors.BorderShadow = rgba(0.00, 0.00, 0.00, 0.00);
ClassicColors.Button = rgba(0.35, 0.40, 0.61, 0.62);
ClassicColors.ButtonActive = rgba(0.46, 0.54, 0.80, 1.00);
ClassicColors.ButtonHovered = rgba(0.40, 0.48, 0.71, 0.79);
ClassicColors.CheckMark = rgba(0.90, 0.90, 0.90, 0.50);
ClassicColors.CheckerOff = rgbi(64,64,64);
ClassicColors.CheckerOn =  rgbi(204,204,204);
ClassicColors.ChildBg = rgba(0.00, 0.00, 0.00, 0.00);
ClassicColors.DragDropTarget = rgba(1.00, 1.00, 0.00, 0.90);
ClassicColors.FBDir = rgb(.2, .9, .2);
ClassicColors.FBFile = rgb(.8, .8, .8);
ClassicColors.FBMkDir = rgb(.2, .4, .9);
ClassicColors.FrameBg = rgba(0.43, 0.43, 0.43, 0.39);
ClassicColors.FrameBgActive = rgba(0.42, 0.41, 0.64, 0.69);
ClassicColors.FrameBgHovered = rgba(0.47, 0.47, 0.69, 0.40);
ClassicColors.Header = rgba(0.40, 0.40, 0.90, 0.45);
ClassicColors.HeaderActive = rgba(0.53, 0.53, 0.87, 0.80);
ClassicColors.HeaderHovered = rgba(0.45, 0.45, 0.90, 0.80);
ClassicColors.MenuBarBg = rgba(0.40, 0.40, 0.55, 0.80);
ClassicColors.ModalWindowDimBg = rgba(0.20, 0.20, 0.20, 0.35);
ClassicColors.NavHighlight = c.HeaderHovered;
ClassicColors.NavWindowingDimBg = rgba(0.80, 0.80, 0.80, 0.20);
ClassicColors.NavWindowingHighlight = rgba(1.00, 1.00, 1.00, 0.70);
ClassicColors.PlotBg = rgb(.1, .1, .1);
ClassicColors.PlotHistogram = rgba(0.90, 0.70, 0.00, 1.00);
ClassicColors.PlotHistogramDimmed = rgba(1.00, 0.60, 0.00, 1.00);
ClassicColors.PlotHistogramHovered = rgba(1.00, 0.60, 0.00, 1.00);
ClassicColors.PlotLines = rgba(1.00, 1.00, 1.00, 1.00);
ClassicColors.PlotLinesDimmed = rgba(0.90, 0.70, 0.00, 1.00);
ClassicColors.PlotLinesHovered = rgba(0.90, 0.70, 0.00, 1.00);
ClassicColors.PlotSignal = rgba(1.00, 1.00, 1.00, 1.00);
ClassicColors.PlotSignalDimmed = rgba(0.90, 0.70, 0.00, 1.00);
ClassicColors.PlotSignalHovered = rgba(0.90, 0.70, 0.00, 1.00);
ClassicColors.PopupBg = rgba(0.11, 0.11, 0.14, 0.92);
ClassicColors.ResizeGrip = rgba(1.00, 1.00, 1.00, 0.16);
ClassicColors.ResizeGripActive = rgba(0.78, 0.82, 1.00, 0.90);
ClassicColors.ResizeGripHovered = rgba(0.78, 0.82, 1.00, 0.60);
ClassicColors.ScrollbarBg = rgba(0.20, 0.25, 0.30, 0.60);
ClassicColors.ScrollbarGrab = rgba(0.40, 0.40, 0.80, 0.30);
ClassicColors.ScrollbarGrabActive = rgba(0.41, 0.39, 0.80, 0.60);
ClassicColors.ScrollbarGrabHovered = rgba(0.40, 0.40, 0.80, 0.40);
ClassicColors.Separator = rgba(0.50, 0.50, 0.50, 1.00);
ClassicColors.SeparatorActive = rgba(0.70, 0.70, 0.90, 1.00);
ClassicColors.SeparatorHovered = rgba(0.60, 0.60, 0.70, 1.00);
ClassicColors.SliderGrab = rgba(1.00, 1.00, 1.00, 0.30);
ClassicColors.SliderGrabActive = rgba(0.41, 0.39, 0.80, 0.60);
ClassicColors.Tab = Color.Lerp(c.Header, c.TitleBgActive, 0.80);
ClassicColors.TabActive = Color.Lerp(c.HeaderActive, c.TitleBgActive, 0.60);
ClassicColors.TabHovered = c.HeaderHovered;
ClassicColors.TabUnfocused = Color.Lerp(c.Tab, c.TitleBg, 0.80);
ClassicColors.TabUnfocusedActive = Color.Lerp(c.TabActive, c.TitleBg, 0.40);
ClassicColors.Text = rgba(0.90, 0.90, 0.90, 1.00);
ClassicColors.TextDisabled = rgba(0.60, 0.60, 0.60, 1.00);
ClassicColors.TextEmphasized = rgba(0.60, 0.80, 0.60, 1.00);
ClassicColors.TextError = CSSColors.darkorange;
ClassicColors.TextSelectedBg = rgba(0.00, 0.00, 1.00, 0.35);
ClassicColors.TitleBg = rgba(0.27, 0.27, 0.54, 0.83);
ClassicColors.TitleBgActive = rgba(0.32, 0.32, 0.63, 0.87);
ClassicColors.TitleBgCollapsed = rgba(0.40, 0.40, 0.80, 0.20);
ClassicColors.WindowBg = rgba(0.00, 0.00, 0.00, 0.70);

var LightColors = Object.assign({}, DarkColors); // inherit
c = LightColors;
LightColors.Border = rgba(0.00, 0.00, 0.00, 0.30);
LightColors.BorderShadow = rgba(0.00, 0.00, 0.00, 0.00);
LightColors.Button = rgba(0.26, 0.59, 0.98, 0.40);
LightColors.ButtonActive = rgba(0.06, 0.53, 0.98, 1.00);
LightColors.ButtonHovered = rgba(0.26, 0.59, 0.98, 1.00);
LightColors.CheckMark = rgba(0.26, 0.59, 0.98, 1.00);
LightColors.CheckerOff = rgbi(64,64,64);
LightColors.CheckerOn =  rgbi(204,204,204);
LightColors.ChildBg = rgba(0.00, 0.00, 0.00, 0.00);
LightColors.DragDropTarget = rgba(0.26, 0.59, 0.98, 0.95);
LightColors.FBDir = rgb(.2, .9, .2);
LightColors.FBFile = rgb(.8, .8, .8);
LightColors.FBMkDir = rgb(.2, .4, .9);
LightColors.FrameBg = rgba(1.00, 1.00, 1.00, 1.00);
LightColors.FrameBgActive = rgba(0.26, 0.59, 0.98, 0.67);
LightColors.FrameBgHovered = rgba(0.26, 0.59, 0.98, 0.40);
LightColors.Header = rgba(0.26, 0.59, 0.98, 0.31);
LightColors.HeaderActive = rgba(0.26, 0.59, 0.98, 1.00);
LightColors.HeaderHovered = rgba(0.26, 0.59, 0.98, 0.80);
LightColors.MenuBarBg = rgba(0.86, 0.86, 0.86, 1.00);
LightColors.ModalWindowDimBg = rgba(0.20, 0.20, 0.20, 0.35);
LightColors.NavHighlight = c.HeaderHovered;
LightColors.NavWindowingDimBg = rgba(0.20, 0.20, 0.20, 0.20);
LightColors.NavWindowingHighlight = rgba(0.70, 0.70, 0.70, 0.70);
LightColors.PlotBg = rgb(.1, .1, .1);
LightColors.PlotHistogram = rgba(0.90, 0.70, 0.00, 1.00);
LightColors.PlotHistogramDimmed = rgba(0.90, 0.70, 0.00, 1.00);
LightColors.PlotHistogramHovered = rgba(1.00, 0.45, 0.00, 1.00);
LightColors.PlotLines = rgba(0.39, 0.39, 0.39, 1.00);
LightColors.PlotLinesDimmed = rgba(0.39, 0.39, 0.39, 1.00);
LightColors.PlotLinesHovered = rgba(1.00, 0.43, 0.35, 1.00);
LightColors.PlotSignal = rgba(0.90, 0.70, 0.00, 1.00);
LightColors.PlotSignalDimmed = rgba(0.90, 0.70, 0.00, 1.00);
LightColors.PlotSignalHovered = rgba(1.00, 0.45, 0.00, 1.00);
LightColors.PopupBg = rgba(1.00, 1.00, 1.00, 0.98);
LightColors.ResizeGrip = rgba(0.80, 0.80, 0.80, 0.56);
LightColors.ResizeGripActive = rgba(0.26, 0.59, 0.98, 0.95);
LightColors.ResizeGripHovered = rgba(0.26, 0.59, 0.98, 0.67);
LightColors.ScrollbarBg = rgba(0.98, 0.98, 0.98, 0.53);
LightColors.ScrollbarGrab = rgba(0.69, 0.69, 0.69, 0.80);
LightColors.ScrollbarGrabActive = rgba(0.49, 0.49, 0.49, 1.00);
LightColors.ScrollbarGrabHovered = rgba(0.49, 0.49, 0.49, 0.80);
LightColors.Separator = rgba(0.39, 0.39, 0.39, 1.00);
LightColors.SeparatorActive = rgba(0.14, 0.44, 0.80, 1.00);
LightColors.SeparatorHovered = rgba(0.14, 0.44, 0.80, 0.78);
LightColors.SliderGrab = rgba(0.26, 0.59, 0.98, 0.78);
LightColors.SliderGrabActive = rgba(0.46, 0.54, 0.80, 0.60);
LightColors.Tab = Color.Lerp(c.Header, c.TitleBgActive, 0.90);
LightColors.TabActive = Color.Lerp(c.HeaderActive, c.TitleBgActive, 0.60);
LightColors.TabHovered = c.HeaderHovered;
LightColors.TabUnfocused = Color.Lerp(c.Tab, c.TitleBg, 0.80);
LightColors.TabUnfocusedActive = Color.Lerp(c.TabActive, c.TitleBg, 0.40);
LightColors.Text = rgba(0.00, 0.00, 0.00, 1.00);
LightColors.TextDisabled = rgba(0.60, 0.60, 0.60, 1.00);
LightColors.TextEmphasized = rgba(0.0, 0.20, 0.00, 1.00);
LightColors.TextError = CSSColors.darkorange;
LightColors.TextSelectedBg = rgba(0.26, 0.59, 0.98, 0.35);
LightColors.TitleBg = rgba(0.96, 0.96, 0.96, 1.00);
LightColors.TitleBgActive = rgba(0.82, 0.82, 0.82, 1.00);
LightColors.TitleBgCollapsed = rgba(1.00, 1.00, 1.00, 0.51);
LightColors.WindowBg = rgba(0.94, 0.94, 0.94, 1.00);

var DebugColors = Object.assign({}, DarkColors);
for(let k in DebugColors)
{
    DebugColors[k] = Color.RandomCss();
}

var ColorSchemes =
{
    "ClassicColors": ClassicColors,
    "DarkColors": DarkColors,
    "LightColors": LightColors,
    "DebugColors": DebugColors,
};

class StyleMod
{
    constructor(field, val)
    {
        this.Field = field;
        this.Value = val;
    }
}

class Style extends SettingsHandler
{
    constructor(fontAtlas, imgui)
    {
        // NB: all member variables that don't begin with _ are part
        //  of the serialization.
        super();
        this._imgui = imgui;
        this.Alpha = 1.0;
            // Global alpha applies to everything in ImGui
        this.WindowPadding = new Vec2(8,8);
            // Padding within a window
        this.WindowRounding = 7.0;
            // Radius of window corners rounding. Set to 0.0f to have
            // rectangular windows
        this.WindowBorderSize = 1.0;
            // Thickness of border around windows. Generally set to 0.0f or 1.0f.
            // Other values not well tested.
        this.WindowMinSize = new Vec2(32,32);
            // Minimum window size
        this.WindowTitleAlign = new Vec2(0.,0.5);
            // Alignment for title bar text
        this.ChildRounding = 0.0;
            // Radius of child window corners rounding. Set to 0.0f to have
            // rectangular child windows
        this.ChildBorderSize = 1;
            // Thickness of border around child windows. Generally set to 0.0f
            // or 1.0f. Other values not well tested.
        this.PopupRounding = 0.0;
            // Radius of popup window corners rounding. Set to 0.0f to have
            // rectangular child windows
        this.PopupBorderSize = 1.;
            // Thickness of border around popup or tooltip windows. Generally
            // set to 0.0f or 1.0f. Other values not well tested.
        this.FramePadding = new Vec2(4,3);
            // Padding within a framed rectangle (used by most widgets)
        this.FrameRounding = 3.;
            // Radius of frame corners rounding. Set to 0.0f to have rectangular
            // frames (used by most widgets).
        this.FrameBorderSize = 0.;
            // Thickness of border around frames. Generally set to 0.0f or
            // 1.0f. Other values not well tested.
        this.ItemSpacing = new Vec2(8,4);
            // Horizontal and vertical spacing between widgets/lines
        this.ItemInnerSpacing = new Vec2(4,4);
            // Horizontal and vertical spacing between within elements of
            // a composed widget (e.g. a slider and its label)
        this.TextLineHeightPct = 1.25;
            // lineheight for text (usually >= 1)
        this.LabelWidth = "MMMMMM"; // aka 6em
        this.TouchExtraPadding = new Vec2(0,0);
            // Expand reactive bounding box for touch-based system where
            // touch position is not accurate enough. Unfortunately we don't
            // sort widgets so priority on overlap will always be given to
            // the first widget. So don't grow this too much!
        this.IndentSpacing = 21;
            // Horizontal spacing when e.g. entering a tree node.
            // Generally == (FontSize + FramePadding.x*2).
        this.ColumnsMinSpacing = 6.;
            // Minimum horizontal spacing between two columns
        this.ScrollbarSize = 16.;
            // Width of the vertical scrollbar, Height of the horizontal scrollbar
        this.ScrollbarRounding = 3.;
            // Radius of grab corners rounding for scrollbar
        this.GrabMinSize = 10.;
            // Minimum width/height of a grab box for slider/scrollbar
        this.GrabRounding = 0.;
            // Radius of grabs corners rounding. Set to 0.0f to have
            // rectangular slider grabs.
        this.TabRounding = 4.;
            // Radius of upper corners of a tab. Set to 0.0f to have
            // rectangular tabs.
        this.TabBorderSize = 0.;
            // Thickness of border around tabs.
        this.ButtonTextAlign = new Vec2(0.5,0.5);
            // Alignment of button text when button is larger than text.
        this.SelectableTextAlign = new Vec2(0.,0.);
            // Alignment of selectable text when button is larger than text.
        this.DisplayWindowPadding = new Vec2(19,19);
            // Window position are clamped to be visible within the display
            // area by at least this amount. Only applies to regular windows.
        this.DisplaySafeAreaPadding = new Vec2(3,3);
            // If you cannot see the edge of your screen (e.g. on a TV)
            // increase the safe area padding. Covers popups/tooltips as well
            // regular windows.
        this.MouseCursorScale = 1.;
            // Scale software rendered mouse cursor (when io.MouseDrawCursor
            // is enabled). May be removed later.
        this.AntiAliasedLines = true;
            // Enable anti-aliasing on lines/borders. Disable if you are really
            // short on CPU/GPU.
        this.AntiAliasedFill = true;
            // Enable anti-aliasing on filled shapes (rounded rectangles,
            // circles, etc.)
        this.CurveTessellationTol = 1.25;
            // Tessellation tolerance when using PathBezierCurveTo() without a
            // specific number of segments. Decrease for highly tessellated
            // curves (higher quality, more polygons), increase to reduce quality.

        this.SetColorScheme("DarkColors");

        // Font abstractions
        /* _DefaultFontSizes and _DefaultFonts are combined with
         * the users' saved values to allow for addition of
         * new ids 'after the fact'.
         */
        this._DefaultFontSizes =
        {
            "Small": 9,
            "Std": 10,
            "Med": 15,
            "Big": 20,
            "Huge": 32,
        };

        this._DefaultFonts = 
        {
            "Default": ["Exo", "Std", "normal"],
            "Label": ["Exo", "Std", "bold"],
            "Small": ["Exo", "Small", "normal"],
            "Med": ["Exo", "Med", "normal"],
            "Std": ["Exo", "Std", "normal"],
            "Big": ["Exo", "Big", "normal"],
            "serif": ["Georgia", "Std", "normal"],
            "sans-serif": ["Exo", "Std", "normal"],
            "monospace": ["SourceCodePro", "Std", "normal"],
            "Fixed": ["SourceCodePro", "Std", "normal"],
            "MedFixed": ["SourceCodePro", "Med", "normal"],
            "BigFixed": ["SourceCodePro", "Big", "normal"],
            "Icons": ["Material Icons", "Std", "normal"],
            "BigIcons": ["Material Icons", "Big", "normal"],
            "HugeIcons": ["Material Icons", "Huge", "normal"],
        };

        this.FontSizes = Object.assign({}, this._DefaultFontSizes);
        this.Fonts = Object.assign({}, this._DefaultFonts);

        // currently tied to MaterialIcons
        //  https://material.io/resources/icons/?style=baseline
        //  https://github.com/google/material-design-icons/blob/master/iconfont/codepoints
        //  same but more up to date:
        //  https://github.com/jossef/material-design-icons-iconfont/tree/master/dist/fonts
        //  https://github.com/jossef/material-design-icons-iconfont/blob/master/dist/fonts/MaterialIcons-Regular.json
        this._MIcons =
        {
            AccountBalance: String.fromCharCode(0x0e84f),
            AddLocation: String.fromCharCode(0x0e567),
            BorderColor: String.fromCharCode(0x0e22b), // edit-like
            Build: String.fromCharCode(0x0e869),
            Camera: String.fromCharCode(0x0ea3f), // shutter
            ChevronLeft: String.fromCharCode(0x0e5cb), 
            ChevronRight: String.fromCharCode(0x0e5cc),
            Close: String.fromCharCode(0x0e5cd),
            CloudDownload: String.fromCharCode(0x0e2c0),
            CloudUpload: String.fromCharCode(0x0e2c3),
            CreateNewFolder: String.fromCharCode(0x0e2cc),
            DateRange: String.fromCharCode(0x0e916),
            Delete: String.fromCharCode(0x0e872), // trash
            DeleteSweep: String.fromCharCode(0x0e16c),
            Edit: String.fromCharCode(0x0e3c9),
            Error: String.fromCharCode(0x0e000),
            ErrorOutline: String.fromCharCode(0x0e001),
            Eye: String.fromCharCode(0x0e8f4),
            Folder: String.fromCharCode(0x0e2c7),
            FolderOpen: String.fromCharCode(0x0e2c8),
            Help: String.fromCharCode(0x0e887),
            HelpOutline: String.fromCharCode(0x0e8fd),
            Info: String.fromCharCode(0x0e88e),
            InfoOutline: String.fromCharCode(0x0e88f),
            ImportExport: String.fromCharCode(0x0e0c3),
            LibraryBooks: String.fromCharCode(0x0e02f),
            NavFwd: String.fromCharCode(0x0e315), // keyboard_arrow_right
            NavRev: String.fromCharCode(0x0e314), // keyboard_arrow_left
            Menu: String.fromCharCode(0x0e5d2), // ie hamburger
            MenuOpen: String.fromCharCode(0x0e9bd),
            Mute: String.fromCharCode(0x0e04f),
            Monitization: String.fromCharCode(0x0e263), // $ dollar
            MyLocation: String.fromCharCode(0x0e050),
            NoMute: String.fromCharCode(0x0e050),
            Note: String.fromCharCode(0x0e3a1), // audiotrack, musical_note
            Notes: String.fromCharCode(0x0e26c), // subject
            OpenInBrowser: String.fromCharCode(0x0e89d),
            People: String.fromCharCode(0x0ea21), // people-alt
            Pause: String.fromCharCode(0x0e034),
            PickFile: String.fromCharCode(0x0e2c8),
            PickImage: String.fromCharCode(0x0e43e), // add_photograph_alt
            Play: String.fromCharCode(0x0e037),
            Refresh: String.fromCharCode(0x0e5d5),
            Settings: String.fromCharCode(0x0e8b8),
            StarFilled: String.fromCharCode(0x0e838),
            StarOutline: String.fromCharCode(0x0e83a),
            Stop: String.fromCharCode(0x0e047),
            Sync: String.fromCharCode(0x0e627),
            Trash: String.fromCharCode(0x0e872), // delete
            UnfoldLess: String.fromCharCode(0x0e5d6), // unfold_less
            UnfoldMore: String.fromCharCode(0x0e5d7), // unfold_more
            ViewComfy: String.fromCharCode(0x0e42a), // tighter grid
            ViewGrid: String.fromCharCode(0x0e8f0), // aka Module
            ViewHeadline: String.fromCharCode(0x0e872),
            ViewList: String.fromCharCode(0x0e872),
            ViewModule: String.fromCharCode(0x0e8f0), // aka Grid
            Warning: String.fromCharCode(0x0e002),
        };
        initMaterialIcons(this._MIcons);

        // unicode character codes (font-independent-ish)
        // https://graphemica.com/
        this._UIcons =
        {
            NavIcon: String.fromCodePoint(0x2630), //  hamburger
            InfoIcon: String.fromCodePoint(0x2139), // 0x1f6c8 circled information source
            GearIcon: String.fromCodePoint(0x2699),
            RightArrow: String.fromCodePoint(0x25B6),
            SmallRightArrow: String.fromCodePoint(0x25B8),
            RightArrow2: String.fromCodePoint(0x25BA),
            DownArrow: String.fromCodePoint(0x25BC),
            SmallDownArrow: String.fromCodePoint(0x25BE),
            Tricolon: String.fromCodePoint(0x205D), // 3 vertical dots (menu)
        };

        // stuff not subject to encapsulation should start with _
        this._fontAtlas = fontAtlas;
        this.GetFont("Default"); // to populate the cache
    }

    GetTypeName() { return "Style"; }

    Encapsulate(imgui)
    {
        let o = {};
        for(let k of Object.getOwnPropertyNames(this))
        {
            if(k[0] == "_") continue; // font atlas, icons, _defaults
            if(k == "Colors")
            {
                o.Colors = {};
                for(let cnm in this.Colors)
                    o.Colors[cnm] = this.Colors[cnm].Encapsulate();
            }
            else
                o[k] = this[k]; // ok for Vec2, see Instantiate
        }
        o.ColorScheme = "custom";
        return o;
    }

    Instantiate(imgui, o)
    {
        let deprecatedProps = ["MIcons", "UIcons"];
        let knownProps = Object.getOwnPropertyNames(this); // a list
        for(let k in o)
        {
            if(deprecatedProps.indexOf(k) != -1)
                continue;
            if(knownProps.indexOf(k) == -1)
                console.debug("Style unknown field: " + k);
            else
            if(k == "Colors")
            {
                let colors = o[k];
                for(let cnm in colors)
                    this.Colors[cnm] = Color.Instantiate(colors[cnm]);
            }
            else
            if(k == "Fonts")
            {
                this.Fonts = Object.assign(this._DefaultFonts, o[k]);
            }
            else
            if(k == "FontSizes")
            {
                this.FontSizes = Object.assign(this._DefaultFontSizes, o[k]);
            }
            else
            if(typeof(o[k]) == "object" && this[k])
            {
                if(this[k].Copy)
                    this[k].Copy(o[k]); // copy Vec2, otherwise no prototype
                else
                    this[k] = o[k]; // Fonts, FontSizes should be okay here
            }
            else
                this[k] = o[k];
        }
    }

    GetSchemeColorNames()
    {
        return Object.keys(this.Colors).sort();
    }

    SetColorScheme(name)
    {
        // name = "DebugColors";
        this.ColorScheme = name;
        this.Colors = ColorSchemes[name];
    }

    Clone()
    {
        let s = Object.assign({}, this);
        s.Fonts = Object.assign({}, this.Fonts);
        s.Colors = {};
        for(let cnm in this.Colors)
            s.Colors[cnm] = this.Colors[cnm].Clone();
        return s;
    }

    GetFont(field)
    {
        let fdesc = this.Fonts[field];
        let nm = fdesc[0];
        let sz = fdesc[1];
        let weight = fdesc[2];
        if(typeof(sz) == "string")
            sz = this.FontSizes[sz];
        return this._fontAtlas.GetFont(nm, sz, weight); // also accepts style
    }

    SetFont(field, font)
    {
        this.Fonts[field] = [font.Family, font.Size, font.Weight];
        this._imgui.MarkIniSettingsDirty();
    }

    GetFontSize(nm) // GetFontSize("Default")
    {
        return this.FontSizes[nm];
    }

    SetFontSize(nm, sz) // SetFontSize("Default", 12)
    {
        this.FontSizes[nm] = sz;
        this._imgui.MarkIniSettingsDirty();
    }

    GetColor(field)
    {
        let c = this.Colors[field];
        if(c == undefined)
        {
            console.warn("unknown style color " + field);
            c = this.Colors._DEBUG0;
        }
        if(this.Alpha == 1)
            return c;
        else
        {
            c = c.Clone();
            c.a = this.Alpha;
            return c;
        }
    }

    MarkDirty()
    {
        this._imgui.MarkIniSettingsDirty();
    }

    ScaleAllSizes(factor)
    {
        this.WindowPadding.Mult(factor).Floor();
        this.WindowRounding = Math.floor(this.WindowRounding * factor);
        this.WindowMinSize.Mult(factor).Floor();
        this.ChildRounding = Math.floor(this.ChildRounding * factor);
        this.PopupRounding = Math.floor(this.PopupRounding * factor);
        this.FramePadding.Mult(factor).Floor();
        this.FrameRounding = Math.floor(this.FrameRounding * factor);
        this.ItemSpacing.Mult(factor).Floor();
        this.ItemInnerSpacing.Mult(factor).Floor();
        this.TouchExtraPadding.Mult(factor).Floor();
        this.IndentSpacing = Math.floor(this.IndentSpacing * factor);
        this.ColumnsMinSpacing = Math.floor(this.ColumnsMinSpacing * factor);
        this.ScrollbarSize = Math.floor(this.ScrollbarSize * factor);
        this.ScrollbarRounding = Math.floor(this.ScrollbarRounding * factor);
        this.GrabMinSize = Math.floor(this.GrabMinSize * factor);
        this.GrabRounding = Math.floor(this.GrabRounding * factor);
        this.TabRounding = Math.floor(this.TabRounding * factor);
        this.DisplayWindowPadding.Mult(factor).Floor();
        this.DisplaySafeAreaPadding.Mult(factor).Floor();
        this.MouseCursorScale = Math.floor(this.MouseCursorScale * factor);
    }
}

function initMaterialIcons(iconTable)
{
    //  from:
    // https://github.com/google/material-design-icons/blob/master/iconfont/codepoints
    const iconDump = `
3d_rotation e84d
ac_unit eb3b
access_alarm e190
access_alarms e191
access_time e192
accessibility e84e
accessible e914
account_balance e84f
account_balance_wallet e850
account_box e851
account_circle e853
adb e60e
add e145
add_a_photo e439
add_alarm e193
add_alert e003
add_box e146
add_circle e147
add_circle_outline e148
add_location e567
add_shopping_cart e854
add_to_photos e39d
add_to_queue e05c
adjust e39e
airline_seat_flat e630
airline_seat_flat_angled e631
airline_seat_individual_suite e632
airline_seat_legroom_extra e633
airline_seat_legroom_normal e634
airline_seat_legroom_reduced e635
airline_seat_recline_extra e636
airline_seat_recline_normal e637
airplanemode_active e195
airplanemode_inactive e194
airplay e055
airport_shuttle eb3c
alarm e855
alarm_add e856
alarm_off e857
alarm_on e858
album e019
all_inclusive eb3d
all_out e90b
android e859
announcement e85a
apps e5c3
archive e149
arrow_back e5c4
arrow_downward e5db
arrow_drop_down e5c5
arrow_drop_down_circle e5c6
arrow_drop_up e5c7
arrow_forward e5c8
arrow_upward e5d8
art_track e060
aspect_ratio e85b
assessment e85c
assignment e85d
assignment_ind e85e
assignment_late e85f
assignment_return e860
assignment_returned e861
assignment_turned_in e862
assistant e39f
assistant_photo e3a0
attach_file e226
attach_money e227
attachment e2bc
audiotrack e3a1
autorenew e863
av_timer e01b
backspace e14a
backup e864
battery_alert e19c
battery_charging_full e1a3
battery_full e1a4
battery_std e1a5
battery_unknown e1a6
beach_access eb3e
beenhere e52d
block e14b
bluetooth e1a7
bluetooth_audio e60f
bluetooth_connected e1a8
bluetooth_disabled e1a9
bluetooth_searching e1aa
blur_circular e3a2
blur_linear e3a3
blur_off e3a4
blur_on e3a5
book e865
bookmark e866
bookmark_border e867
border_all e228
border_bottom e229
border_clear e22a
border_color e22b
border_horizontal e22c
border_inner e22d
border_left e22e
border_outer e22f
border_right e230
border_style e231
border_top e232
border_vertical e233
branding_watermark e06b
brightness_1 e3a6
brightness_2 e3a7
brightness_3 e3a8
brightness_4 e3a9
brightness_5 e3aa
brightness_6 e3ab
brightness_7 e3ac
brightness_auto e1ab
brightness_high e1ac
brightness_low e1ad
brightness_medium e1ae
broken_image e3ad
brush e3ae
bubble_chart e6dd
bug_report e868
build e869
burst_mode e43c
business e0af
business_center eb3f
cached e86a
cake e7e9
call e0b0
call_end e0b1
call_made e0b2
call_merge e0b3
call_missed e0b4
call_missed_outgoing e0e4
call_received e0b5
call_split e0b6
call_to_action e06c
camera e3af
camera_alt e3b0
camera_enhance e8fc
camera_front e3b1
camera_rear e3b2
camera_roll e3b3
cancel e5c9
card_giftcard e8f6
card_membership e8f7
card_travel e8f8
casino eb40
cast e307
cast_connected e308
center_focus_strong e3b4
center_focus_weak e3b5
change_history e86b
chat e0b7
chat_bubble e0ca
chat_bubble_outline e0cb
check e5ca
check_box e834
check_box_outline_blank e835
check_circle e86c
chevron_left e5cb
chevron_right e5cc
child_care eb41
child_friendly eb42
chrome_reader_mode e86d
class e86e
clear e14c
clear_all e0b8
close e5cd
closed_caption e01c
cloud e2bd
cloud_circle e2be
cloud_done e2bf
cloud_download e2c0
cloud_off e2c1
cloud_queue e2c2
cloud_upload e2c3
code e86f
collections e3b6
collections_bookmark e431
color_lens e3b7
colorize e3b8
comment e0b9
compare e3b9
compare_arrows e915
computer e30a
confirmation_number e638
contact_mail e0d0
contact_phone e0cf
contacts e0ba
content_copy e14d
content_cut e14e
content_paste e14f
control_point e3ba
control_point_duplicate e3bb
copyright e90c
create e150
create_new_folder e2cc
credit_card e870
crop e3be
crop_16_9 e3bc
crop_3_2 e3bd
crop_5_4 e3bf
crop_7_5 e3c0
crop_din e3c1
crop_free e3c2
crop_landscape e3c3
crop_original e3c4
crop_portrait e3c5
crop_rotate e437
crop_square e3c6
dashboard e871
data_usage e1af
date_range e916
dehaze e3c7
delete e872
delete_forever e92b
delete_sweep e16c
description e873
desktop_mac e30b
desktop_windows e30c
details e3c8
developer_board e30d
developer_mode e1b0
device_hub e335
devices e1b1
devices_other e337
dialer_sip e0bb
dialpad e0bc
directions e52e
directions_bike e52f
directions_boat e532
directions_bus e530
directions_car e531
directions_railway e534
directions_run e566
directions_subway e533
directions_transit e535
directions_walk e536
disc_full e610
dns e875
do_not_disturb e612
do_not_disturb_alt e611
do_not_disturb_off e643
do_not_disturb_on e644
dock e30e
domain e7ee
done e876
done_all e877
donut_large e917
donut_small e918
drafts e151
drag_handle e25d
drive_eta e613
dvr e1b2
edit e3c9
edit_location e568
eject e8fb
email e0be
enhanced_encryption e63f
equalizer e01d
error e000
error_outline e001
euro_symbol e926
ev_station e56d
event e878
event_available e614
event_busy e615
event_note e616
event_seat e903
exit_to_app e879
expand_less e5ce
expand_more e5cf
explicit e01e
explore e87a
exposure e3ca
exposure_neg_1 e3cb
exposure_neg_2 e3cc
exposure_plus_1 e3cd
exposure_plus_2 e3ce
exposure_zero e3cf
extension e87b
face e87c
fast_forward e01f
fast_rewind e020
favorite e87d
favorite_border e87e
featured_play_list e06d
featured_video e06e
feedback e87f
fiber_dvr e05d
fiber_manual_record e061
fiber_new e05e
fiber_pin e06a
fiber_smart_record e062
file_download e2c4
file_upload e2c6
filter e3d3
filter_1 e3d0
filter_2 e3d1
filter_3 e3d2
filter_4 e3d4
filter_5 e3d5
filter_6 e3d6
filter_7 e3d7
filter_8 e3d8
filter_9 e3d9
filter_9_plus e3da
filter_b_and_w e3db
filter_center_focus e3dc
filter_drama e3dd
filter_frames e3de
filter_hdr e3df
filter_list e152
filter_none e3e0
filter_tilt_shift e3e2
filter_vintage e3e3
find_in_page e880
find_replace e881
fingerprint e90d
first_page e5dc
fitness_center eb43
flag e153
flare e3e4
flash_auto e3e5
flash_off e3e6
flash_on e3e7
flight e539
flight_land e904
flight_takeoff e905
flip e3e8
flip_to_back e882
flip_to_front e883
folder e2c7
folder_open e2c8
folder_shared e2c9
folder_special e617
font_download e167
format_align_center e234
format_align_justify e235
format_align_left e236
format_align_right e237
format_bold e238
format_clear e239
format_color_fill e23a
format_color_reset e23b
format_color_text e23c
format_indent_decrease e23d
format_indent_increase e23e
format_italic e23f
format_line_spacing e240
format_list_bulleted e241
format_list_numbered e242
format_paint e243
format_quote e244
format_shapes e25e
format_size e245
format_strikethrough e246
format_textdirection_l_to_r e247
format_textdirection_r_to_l e248
format_underlined e249
forum e0bf
forward e154
forward_10 e056
forward_30 e057
forward_5 e058
free_breakfast eb44
fullscreen e5d0
fullscreen_exit e5d1
functions e24a
g_translate e927
gamepad e30f
games e021
gavel e90e
gesture e155
get_app e884
gif e908
golf_course eb45
gps_fixed e1b3
gps_not_fixed e1b4
gps_off e1b5
grade e885
gradient e3e9
grain e3ea
graphic_eq e1b8
grid_off e3eb
grid_on e3ec
group e7ef
group_add e7f0
group_work e886
hd e052
hdr_off e3ed
hdr_on e3ee
hdr_strong e3f1
hdr_weak e3f2
headset e310
headset_mic e311
healing e3f3
hearing e023
help e887
help_outline e8fd
high_quality e024
highlight e25f
highlight_off e888
history e889
home e88a
hot_tub eb46
hotel e53a
hourglass_empty e88b
hourglass_full e88c
http e902
https e88d
image e3f4
image_aspect_ratio e3f5
remove_red_eye e417
remove_shopping_cart e928
reorder e8fe
repeat e040
repeat_one e041
replay e042
replay_10 e059
replay_30 e05a
replay_5 e05b
reply e15e
reply_all e15f
report e160
report_problem e8b2
restaurant e56c
restaurant_menu e561
restore e8b3
restore_page e929
ring_volume e0d1
room e8b4
room_service eb49
rotate_90_degrees_ccw e418
rotate_left e419
rotate_right e41a
rounded_corner e920
router e328
rowing e921
rss_feed e0e5
rv_hookup e642
satellite e562
save e161
scanner e329
schedule e8b5
school e80c
screen_lock_landscape e1be
screen_lock_portrait e1bf
screen_lock_rotation e1c0
screen_rotation e1c1
screen_share e0e2
sd_card e623
sd_storage e1c2
search e8b6
security e32a
select_all e162
send e163
sentiment_dissatisfied e811
sentiment_neutral e812
sentiment_satisfied e813
sentiment_very_dissatisfied e814
sentiment_very_satisfied e815
settings e8b8
settings_applications e8b9
settings_backup_restore e8ba
settings_bluetooth e8bb
settings_brightness e8bd
settings_cell e8bc
settings_ethernet e8be
settings_input_antenna e8bf
settings_input_component e8c0
settings_input_composite e8c1
settings_input_hdmi e8c2
settings_input_svideo e8c3
settings_overscan e8c4
settings_phone e8c5
settings_power e8c6
settings_remote e8c7
settings_system_daydream e1c3
settings_voice e8c8
share e80d
shop e8c9
shop_two e8ca
shopping_basket e8cb
shopping_cart e8cc
short_text e261
show_chart e6e1
shuffle e043
signal_cellular_4_bar e1c8
signal_cellular_connected_no_internet_4_bar e1cd
signal_cellular_no_sim e1ce
signal_cellular_null e1cf
signal_cellular_off e1d0
signal_wifi_4_bar e1d8
signal_wifi_4_bar_lock e1d9
signal_wifi_off e1da
sim_card e32b
sim_card_alert e624
skip_next e044
skip_previous e045
slideshow e41b
slow_motion_video e068
smartphone e32c
smoke_free eb4a
smoking_rooms eb4b
sms e625
sms_failed e626
snooze e046
sort e164
sort_by_alpha e053
spa eb4c
space_bar e256
speaker e32d
speaker_group e32e
speaker_notes e8cd
speaker_notes_off e92a
speaker_phone e0d2
spellcheck e8ce
star e838
star_border e83a
star_half e839
stars e8d0
stay_current_landscape e0d3
stay_current_portrait e0d4
stay_primary_landscape e0d5
stay_primary_portrait e0d6
stop e047
stop_screen_share e0e3
storage e1db
store e8d1
store_mall_directory e563
straighten e41c
streetview e56e
strikethrough_s e257
style e41d
subdirectory_arrow_left e5d9
subdirectory_arrow_right e5da
subject e8d2
subscriptions e064
subtitles e048
subway e56f
supervisor_account e8d3
surround_sound e049
swap_calls e0d7
swap_horiz e8d4
swap_vert e8d5
swap_vertical_circle e8d6
switch_camera e41e
switch_video e41f
sync e627
sync_disabled e628
sync_problem e629
system_update e62a
system_update_alt e8d7
tab e8d8
tab_unselected e8d9
tablet e32f
tablet_android e330
tablet_mac e331
tag_faces e420
tap_and_play e62b
terrain e564
text_fields e262
text_format e165
textsms e0d8
texture e421
theaters e8da
thumb_down e8db
thumb_up e8dc
thumbs_up_down e8dd
time_to_leave e62c
timelapse e422
timeline e922
timer e425
timer_10 e423
timer_3 e424
timer_off e426
title e264
toc e8de
today e8df
toll e8e0
tonality e427
touch_app e913
toys e332
track_changes e8e1
traffic e565
train e570
tram e571
transfer_within_a_station e572
transform e428
translate e8e2
trending_down e8e3
trending_flat e8e4
trending_up e8e5
tune e429
turned_in e8e6
turned_in_not e8e7
tv e333
unarchive e169
undo e166
unfold_less e5d6
unfold_more e5d7
update e923
usb e1e0
verified_user e8e8
vertical_align_bottom e258
vertical_align_center e259
vertical_align_top e25a
vibration e62d
video_call e070
video_label e071
video_library e04a
videocam e04b
videocam_off e04c
videogame_asset e338
view_agenda e8e9
view_array e8ea
view_carousel e8eb
view_column e8ec
view_comfy e42a
view_compact e42b
view_day e8ed
view_headline e8ee
view_list e8ef
view_module e8f0
view_quilt e8f1
view_stream e8f2
view_week e8f3
vignette e435
visibility e8f4
visibility_off e8f5
voice_chat e62e
voicemail e0d9
volume_down e04d
volume_mute e04e
volume_off e04f
volume_up e050
vpn_key e0da
vpn_lock e62f
wallpaper e1bc
warning e002
watch e334
watch_later e924
wb_auto e42c
wb_cloudy e42d
wb_incandescent e42e
wb_iridescent e436
wb_sunny e430
wc e63d
web e051
web_asset e069
weekend e16b
whatshot e80e
widgets e1bd
wifi e63e
wifi_lock e1e1
wifi_tethering e1e2
work e8f9
wrap_text e25b
youtube_searched_for e8fa
zoom_in e8ff
zoom_out e900
zoom_out_map e56b
        `.split("\n").forEach( (v) =>
    {
        if(v != "")
        {
            let fields = v.split(" ");
            if(fields.length == 2)
            {
                let num = Number("0x" + fields[1]);
                iconTable[fields[0]] = String.fromCharCode(num);
            }
        }
    });
}


// =====================================================================================================================
// style.js END
// =====================================================================================================================
// =====================================================================================================================
// arrayex.js BEGIN
// =====================================================================================================================

// https://bit.ly/2KsZkSO

// some extensions to Array to facilitate imgui porting.
// we don't extend Array directly because it may muck with
// non-imgui packages array iteration.
class ArrayEx
{
    constructor()
    {
        var aex = Object.create(Array.prototype);
        for(let i=0;i<arguments.length;i++)
            aex.push(arguments[i]);
        ArrayEx._extendArray(aex);
        return aex;
    }

    clear()
    {
        this.length = 0;
    }

    back()
    {
        return this[this.length-1];
    }

    push_back(v)
    {
        return this.push(v);
    }

    pop_back()
    {
        return this.pop();
    }

    push_front(v)
    {
        this.unshift(v);
        // return this.splice(0, 0, v);
    }

    resize(len)
    {
        return this.length = len;
    }

    empty()
    {
        return (this.length == 0);
    }

    clone()
    {
        return this.slice();
    }

    static _extendArray(aex)
    {
        let props = Object.getOwnPropertyNames(ArrayEx.prototype);
        for (var nm of props)
            aex[nm] = ArrayEx.prototype[nm];
        return aex;
    }
}

// =====================================================================================================================
// arrayex.js END
// =====================================================================================================================
// =====================================================================================================================
// storage.js BEGIN
// =====================================================================================================================

class Storage
{
    constructor()
    {
        this.Clear();
    }

    Clear()
    {
        this.intMap = {};
        this.floatMap = {};
        this.boolMap = {};
        this.voidPtrMap = {};
    }

    GetInt(key, defaultVal=0)
    {
        let v = this.intMap[key];
        if(v === undefined)
            return defaultVal;
        else
            return v;
    }

    SetInt(key, val)
    {
        this.intMap[key] = val;
    }

    GetBool(key, defaultVal=false)
    {
        let v = this.boolMap[key];
        if(v === undefined)
            return defaultVal;
        else
            return v;
    }

    SetBool(key, val)
    {
        this.boolMap[key] = val;
    }

    GetFloat(key, defaultVal=0.)
    {
        let v = this.floatMap[key];
        if(v === undefined)
            return defaultVal;
        else
            return v;
    }

    SetFloat(key, val)
    {
        this.floatMap[key] = val;
    }

    GetVoidPtr(key)
    {
        let v = this.voidPtrMap[key];
        if(v === undefined)
            return null;
        else
            return v;
    }

    SetVoidPtr(key, val)
    {
        this.voidPtrMap[key] = val;
    }

    // - Get***Ref() functions finds pair, insert on demand if missing,
    // return pointer. Useful if you intend to do Get+Set.
    // - References are only valid until a new value is added to the storage.
    // Calling a Set***() function or a Get***Ref() function invalidates the pointer.
    // - A typical use case where this is convenient for quick hacking (e.g.
    // add storage during a live Edit&Continue session if you can't modify existing struct)
    //   float* pvar = ImGui::GetFloatRef(key);
    //   ImGui::SliderFloat("var", pvar, 0, 100.0f);
    //    some_var += *pvar;


}
// =====================================================================================================================
// storage.js END
// =====================================================================================================================
// =====================================================================================================================
// hashutil.js BEGIN
// =====================================================================================================================


// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript
function GetHash(val, seed=0)
{
    // NB: this isn't the same hash as ImGui which uses a crc32 lookup table
    // we'll see if this is sufficient.
    var hash = seed, i, chr;
    if(typeof(val) == "number")
    {
        if(seed)
            return hash + val;
        else
            val = "" + val;  // convert to string
    }

    if(typeof(val) == "string")
    {
        if (val.length === 0) return hash+23;
        let vals = val.split("##");
        val = vals[vals.length-1];
        for (i = 0; i < val.length; i++)
        {
            chr = val.charCodeAt(i);
            hash = ((hash << 5) - hash) + chr;
        }
    }
    else
        console.assert(0, "unimplemented hash type:" + typeof(val));
    return hash;
}

function HashData(data, seed)
{
    // NB: this isn't the same hash as ImGui which uses a crc32 lookup table
    // we'll see if this is sufficient.
    var hash = 0, i, d;
    if (data.length === 0) return hash;
    for (i = 0; i < data.length; i++)
    {
        d = data[i];
        hash = ((hash << 5) - hash) + d;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}

function IsPowerOfTwo(num)
{
    return num != 0 && (num & (num-1)) == 0;
}
// =====================================================================================================================
// hashutil.js END
// =====================================================================================================================
// =====================================================================================================================
// flags.js BEGIN
// =====================================================================================================================

let f;
var FocusedFlags =
{
    None: 0,
    ChildWindows: 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused
    RootWindow: 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)
    AnyWindow: 1 << 2,   // IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use ImGui::GetIO().WantCaptureMouse instead.
};
FocusedFlags.RootAndChildWindows = FocusedFlags.RootWindow |
                                   FocusedFlags.ChildWindows;
// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
// Note: if you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that. Please read the FAQ!
// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.

var HoveredFlags =
{
    None: 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
    ChildWindows: 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered
    RootWindow: 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
    AnyWindow: 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered
    AllowWhenBlockedByPopup: 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window
    //AllowWhenBlockedByModal: 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
    AllowWhenBlockedByActiveItem: 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
    AllowWhenOverlapped: 1 << 6,   // Return true even if the position is overlapped by another window
    AllowWhenDisabled: 1 << 7,   // Return true even if the item is disabled
};
HoveredFlags.RectOnly = HoveredFlags.AllowWhenBlockedByPopup |
                        HoveredFlags.AllowWhenBlockedByActiveItem |
                        HoveredFlags.AllowWhenOverlapped;
HoveredFlags.RootAndChildWindows = HoveredFlags.RootWindow |
                        HoveredFlags.ChildWindows;

var NavHighlightFlags =
{
    None: 0,
    TypeDefault: 1 << 0,
    TypeThin: 1 << 1,
    AlwaysDraw: 1 << 2, // Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.
    NoRounding: 1 << 3
};

var NavMoveFlags =
{
    None: 0,
    LoopX: 1 << 0, // On failed request, restart from opposite side
    LoopY: 1 << 1,
    WrapX: 1 << 2, // On failed request, request from opposite side one line
                   // down (when NavDir==right) or one line up (when NavDir==left)
    WrapY: 1 << 3, // This is not super useful for provided for completeness
    AllowCurrentNavId: 1 << 4, // Allow scoring and considering the current
                               // NavId as a move target candidate. This is used
                               // when the move source is offset (e.g. pressing
                               // PageDown actually needs to send a Up move
                               // request, if we are pressing PageDown from the
                               // bottom-most item we need to stay in place)

    AlsoScoreVisibleSet: 1 << 5// Store alternate result in NavMoveResultLocalVisibleSet
                               // that only comprise elements that are already fully
                               // visible.
};

var ItemFlags =
{
    Default: 0,
    NoTabStop: 1 << 0,  // false
    ButtonRepeat: 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.
    Disabled: 1 << 2,  // false    // [BETA] Disable interactions but doesn't affect visuals yet. See github.com/ocornut/imgui/issues/211
    NoNav: 1 << 3,  // false
    NoNavDefaultFocus: 1 << 4,  // false
    SelectableDontClosePopup: 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window
};

var ItemStatusFlags =
{
    None: 0,
    HoveredRect: 1,
    HasDisplayRect: 2,
    Edited: 4,  // Value exposed by item was edited in the current frame
                // (should match the bool return value of most widgets)
};

var CondFlags =
{
    None: 0,
    Always: 1,
    Once: 2, // once per runtime session (only the first call with succeed)
    FirstUseEver: 4, // object has no persistently saved data (no entry in .ini file)
    Appearing: 8 // if object is appearing after being hidden/inactive (or the first time)
};

var ConfigFlags =
{
    None: 0,
    // Master keyboard navigation enable flag. NewFrame() will automatically
    // fill io.NavInputs[] based on io.KeysDown[].
    NavEnableKeyboard: 1 << 0,
    // Master gamepad navigation enable flag. This is mostly to instruct your
    // imgui back-end to fill io.NavInputs[]. Back-end also needs to set
    // BackendFlags.HasGamepad.
    NavEnableGamepad: 1 << 1,
    // Instruct navigation to move the mouse cursor. May be useful on
    // TV/console systems where moving a virtual mouse is awkward. Will
    // update io.MousePos and set io.WantSetMousePos=true. If enabled you
    // MUST honor io.WantSetMousePos requests in your binding, otherwise
    // ImGui will react as if the mouse is jumping around back and forth.
    NavEnableSetMousePos: 1 << 2,
    // Instruct navigation to not set the io.WantCaptureKeyboard flag when
    // io.NavActive is set.
    NavNoCaptureKeyboard: 1 << 3,
    // Instruct imgui to clear mouse position/buttons in NewFrame(). This
    // allows ignoring the mouse information set by the back-end.
    NoMouse: 1 << 4,
    // Instruct back-end to not alter mouse cursor shape and visibility.
    // Use if the back-end cursor changes are interfering with yours and
    // you don't want to use SetMouseCursor() to change mouse cursor. You
    // may want to honor requests from imgui by reading GetMouseCursor()
    // yourself instead.
    NoMouseCursorChange: 1 << 5,

    // User storage (to allow your back-end/engine to communicate to code
    // that may be shared between multiple projects. Those flags are not
    // used by core ImGui)

    // Application is SRGB-aware.
    IsSRGB: 1 << 20,

    // Application is using a touch screen instead of a mouse.
    IsTouchScreen: 1 << 21
};

// Back-end capabilities flags stored in io.BackendFlags. Set by
// imgui_impl_xxx or custom back-end.
var BackendFlags =
{
    None: 0,
    // Back-end supports gamepad and currently has one connected.
    HasGamepad: 1 << 0,
    // Back-end supports honoring GetMouseCursor() value to change
    // the OS cursor shape.
    HasMouseCursors: 1 << 1,
    // Back-end supports io.WantSetMousePos requests to reposition
    // the OS mouse position (only used if ConfigFlags.NavEnableSetMousePos
    // is set).
    HasSetMousePos: 1 << 2
};

var ColorEditFlags =
{
    None: 0,
    NoAlpha: 1 << 1,   // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).
    NoPicker: 1 << 2,   // ColorEdit: disable picker when clicking on colored square.
    NoOptions: 1 << 3,   // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
    NoSmallPreview: 1 << 4,   // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
    NoInputs: 1 << 5,   // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
    NoTooltip: 1 << 6,   // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
    NoLabel: 1 << 7,   // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
    NoSidePreview: 1 << 8,   // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.
    NoDragDrop: 1 << 9,   // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.

    // User Options (right-click on widget to change some of them).
    AlphaBar: 1 << 16,  // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
    AlphaPreview: 1 << 17,  // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
    AlphaPreviewHalf: 1 << 18,  // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
    HDR: 1 << 19,  // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
    DisplayRGB: 1 << 20,  // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.
    DisplayHSV: 1 << 21,
    DisplayHex: 1 << 22,
    Uint8: 1 << 23,  // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
    Float: 1 << 24,  // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
    PickerHueBar: 1 << 25,  // ColorPicker: bar for Hue, rectangle for Sat/Value.
    PickerHueWheel: 1 << 26,  // ColorPicker: wheel for Hue, triangle for Sat/Value.
    InputRGB: 1 << 27,  // ColorEdit, ColorPicker: input and output data in RGB format.
    InputHSV: 1 << 28,  // ColorEdit, ColorPicker: input and output data in HSV format.
};

// Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to
// override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
ColorEditFlags.OptionsDefault = ColorEditFlags.Uint8 |
                    ColorEditFlags.DisplayRGB | ColorEditFlags.InputRGB |
                    ColorEditFlags.PickerHueBar;

// [Internal] Masks
ColorEditFlags.DisplayMask = ColorEditFlags.DisplayRGB |
                              ColorEditFlags.DisplayHSV |
                              ColorEditFlags.DisplayHex;
ColorEditFlags.DataTypeMask = ColorEditFlags.Uint8 | ColorEditFlags.Float;
ColorEditFlags.PickerMask = ColorEditFlags.PickerHueWheel | ColorEditFlags.PickerHueBar;
ColorEditFlags.InputMask = ColorEditFlags.InputRGB | ColorEditFlags.InputHSV;


var NavDirSourceFlags =
{
    None: 0,
    Keyboard: 1 << 0,
    PadDPa: 1 << 1,
    PadLStic: 1 << 2
};

// In your function calls you may use ~0 (= all bits sets) instead of
// CornerFlags.All
var CornerFlags =
{
    TopLeft: 1 << 0, // 0x1
    TopRight: 1 << 1, // 0x2
    BotLeft: 1 << 2, // 0x4
    BotRight: 1 << 3, // 0x8
};
f = CornerFlags;
f.Top = f.TopLeft | f.TopRight;   // 0x3
f.Bot = f.BotLeft | f.BotRight;   // 0xC
f.Left = f.TopLeft | f.BotLeft;    // 0x5
f.Right = f.TopRight |f.BotRight;  // 0xA
f.All = 0xF;

var DrawListFlags =
{
    None: 0,
    AntiAliasedLines: 1 << 0,  // Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)
    AntiAliasedFill: 1 << 1   // Filled shapes have anti-aliased edges (*2 the number of vertices)
};

// =====================================================================================================================
// flags.js END
// =====================================================================================================================
// =====================================================================================================================
// misc.js BEGIN
// =====================================================================================================================

//
// Just a way to keep miscellaneous private methods of imgui cleanly
// separated.  We employ mixins for separable/constituent parts.
//




class ItemHoveredDataBackup
{
    constructor(guictx)
    {
        this.guictx = guictx;
        this.Backup();
    }
    Backup()
    {
        let win = this.guictx.CurrentWindow;
        this.LastItemId = win.DC.LastItemId;
        this.LastItemStatusFlags = win.DC.LastItemStatusFlags;
        this.LastItemRect = win.DC.LastItemRect.Clone();
        this.LastItemDisplayRect = win.DC.LastItemDisplayRect.Clone();
    }
    Restore()
    {
        let win = this.guictx.CurrentWindow;
        win.DC.LastItemId = this.LastItemId;
        win.DC.LastItemStatusFlags = this.LastItemStatusFlags;
        win.DC.LastItemRect = this.LastItemRect; // no need to clone
        win.DC.LastItemDisplayRect = this.LastItemDisplayRect; // ditto
    }
}

var ImguiMiscMixin =
{
    // --- Init ---
    init(ctx)
    {},

    shutdown(ctx)
    {},

    // --- NewFrame ---

    startMouseMovingWindow(win)
    {
        // Set ActiveId even if the _NoMove flag is set. Without it, dragging
        // away from a window with _NoMove would activate hover on other windows.
        // We _also_ call this when clicking in a window empty space when
        // io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow
        // afterward. This is because we want ActiveId to be set even when the
        // window is not permitted to move.
        let g = this.guictx;
        this.FocusWindow(win);
        this.setActiveID(win.MoveId, win);
        g.NavDisableHighlight = true;
        g.ActiveIdClickOffset = Vec2.Subtract(g.IO.MousePos, win.RootWindow.Pos);

        let can_move_window = true;
        if ((win.Flags & WindowFlags.NoMove) ||
            (win.RootWindow.Flags & WindowFlags.NoMove))
        {
            can_move_window = false;
        }
        if (can_move_window)
            g.MovingWindow = win;
    },

    updateMouseMovingWindowNewFrame()
    {
        let g = this.guictx;
        if (g.MovingWindow != null)
        {
            // We actually want to move the root window.
            //  g.MovingWindow == window we clicked on (could be a child window).
            // We track it to preserve Focus and so that generally
            // ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId
            // for consistency.
            this.keepAliveID(g.ActiveId);
            console.assert(g.MovingWindow && g.MovingWindow.RootWindow);
            let moving_window = g.MovingWindow.RootWindow;
            if (g.IO.MouseDown[0] && this.IsMousePosValid(g.IO.MousePos))
            {
                let pos = Vec2.Subtract(g.IO.MousePos, g.ActiveIdClickOffset);
                if (moving_window.Pos.x != pos.x || moving_window.Pos.y != pos.y)
                {
                    this.MarkIniSettingsDirty(moving_window);
                    moving_window.SetWindowPos(pos, CondFlags.Always);
                }
                this.FocusWindow(g.MovingWindow);
            }
            else
            {
                this.clearActiveID();
                g.MovingWindow = null;
            }
        }
        else
        {
            // When clicking/dragging from a window that has the _NoMove flag,
            // we still set the ActiveId in order to prevent hovering others.
            if (g.ActiveIdWindow && g.ActiveIdWindow.MoveId == g.ActiveId)
            {
                this.keepAliveID(g.ActiveId);
                if (!g.IO.MouseDown[0])
                    this.clearActiveID();
            }
        }
    },

    updateMouseMovingWindowEndFrame()
    {
        // Initiate moving window
        let g = this.guictx;
        if (g.ActiveId != 0 || g.HoveredId != 0)
            return;

        // Unless we just made a window/popup appear
        if (g.NavWindow && g.NavWindow.Appearing)
            return;

        // Click to focus window and start moving (after we're done with all our widgets)
        if (g.IO.MouseClicked[0])
        {
            if (g.HoveredRootWindow)
            {
                this.startMouseMovingWindow(g.HoveredWindow);
                if (g.IO.ConfigWindowsMoveFromTitleBarOnly &&
                    !(g.HoveredRootWindow.Flags & WindowFlags.NoTitleBar))
                {
                    if (!g.HoveredRootWindow.TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
                        g.MovingWindow = null;
                }
            }
            else
            if (g.NavWindow  && !this.getFrontMostPopupModal())
            {
                // Clicking on void disable focus
                this.FocusWindow(null);
            }
        }

        // With right mouse button we close popups without changing focus
        // (The left mouse button path calls FocusWindow which will lead NewFrame->ClosePopupsOverWindow to trigger)
        if (g.IO.MouseClicked[1])
        {
            // Find the top-most window between HoveredWindow and the front most Modal Window.
            // This is where we can trim the popup stack.
            let modal = this.getFrontMostPopupModal();
            let hovered_window_above_modal = false;
            if (modal)
                hovered_window_above_modal = true;
            for (let i = g.Windows.length - 1; i >= 0 && hovered_window_above_modal == false; i--)
            {
                let win = g.Windows[i];
                if (win == modal)
                    break;
                if (win == g.HoveredWindow)
                    hovered_window_above_modal = true;
            }
            this.closePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal);
        }
    },

    // Basic accessors ======
    getItemID()
    {
         return this.guictx.CurrentWindow.DC.LastItemId;
    },
    getActiveID()
    {
        return this.guictx.ActiveId;
    },
    getFocusID()
    {
        return this.guictx.NavId;
    },

    setActiveID(id, win)
    {
        let g = this.guictx;
        g.ActiveIdIsJustActivated = (g.ActiveId != id);
        if (g.ActiveIdIsJustActivated)
        {
            g.ActiveIdTimer = 0.;
            g.ActiveIdHasBeenPressed = false;
            g.ActiveIdHasBeenEdited = false;
            if (id != 0)
            {
                g.LastActiveId = id;
                g.LastActiveIdTimer = 0;
            }
        }
        g.ActiveId = id;
        g.ActiveIdAllowNavDirFlags = 0;
        g.ActiveIdBlockNavInputFlags = 0;
        g.ActiveIdAllowOverlap = false;
        g.ActiveIdWindow = win;
        if (id)
        {
            g.ActiveIdIsAlive = id;
            if(g.NavActivateId == id || g.NavInputId == id ||
                g.NavJustTabbedId == id || g.NavJustMovedToId == id)
                g.ActiveIdSource = InputSource.Nav;
            else
                g.ActiveIdSource = InputSource.Mouse;
        }
    },

    setFocusID(id, win)
    {
        let g = this.guictx;
        console.assert(id != 0);

        // Assume that SetFocusID() is called in the context where its
        // NavLayer is the current layer, which is the case everywhere we
        // call it.
        const nav_layer = win.DC.NavLayerCurrent;
        if (g.NavWindow != win)
            g.NavInitRequest = false;
        g.NavId = id;
        g.NavWindow = win;
        g.NavLayer = nav_layer;
        win.NavLastIds[nav_layer] = id;
        if(win.DC.LastItemId == id)
        {
            win.NavRectRel[nav_layer] =
                new Rect(Vec2.Subtract(win.DC.LastItemRect.Min, win.Pos),
                         Vec2.Subtract(win.DC.LastItemRect.Max, win.Pos));
        }
        if (g.ActiveIdSource == InputSource.Nav)
            g.NavDisableMouseHover = true;
        else
            g.NavDisableHighlight = true;
    },

    clearActiveID()
    {
        this.setActiveID(0, null);
    },

    getHoveredID()
    {
        let g = this.guictx;
        return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
    },

    setHoveredID(id)
    {
        let g = this.guictx;
        g.HoveredId = id;
        g.HoveredIdAllowOverlap = false;
        if (id != 0 && g.HoveredIdPreviousFrame != id)
            g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0;
    },

    keepAliveID(id)
    {
        let g = this.guictx;
        if (g.ActiveId == id)
            g.ActiveIdIsAlive = id;
        if (g.ActiveIdPreviousFrame == id)
            g.ActiveIdPreviousFrameIsAlive = true;
    },

    markItemEdited(id)
    {
        // This marking is solely to be able to provide info for
        // IsItemDeactivatedAfterEdit().  ActiveId might have been
        // released by the time we call this (as in the typical
        // press/release button behavior) but still need need to
        // fill the data.
        let g = this.guictx;
        console.assert(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);
        //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
        g.ActiveIdHasBeenEdited = true;
        g.CurrentWindow.DC.LastItemStatusFlags |= ItemStatusFlags.Edited;
    },

    // --- basic helpers for widget code ---

    itemHoverable(bb, id)
    {
        let g = this.guictx;
        if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
            return false;
        let win = g.CurrentWindow;
        if (g.HoveredWindow != win)
            return false;
        if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
            return false;
        if (!this.IsMouseHoveringRect(bb.Min, bb.Max))
            return false;
        if (g.NavDisableMouseHover ||
            !this.isWindowContentHoverable(win, HoveredFlags.None))
        {
            return false;
        }
        if (win.DC.ItemFlags & ItemFlags.Disabled)
            return false;

        this.setHoveredID(id);
        return true;
    },

    // Process TAB/Shift+TAB. Be mindful that this function may _clear_
    // the ActiveID when tabbing out.
    // Return true if focus is requested
    focusableItemRegister(win, id)
    {
        let g = this.guictx;
        // Increment counters
        const is_tab_stop = (win.DC.ItemFlags &
                           (ItemFlags.NoTabStop | ItemFlags.Disabled)) == 0;
        win.DC.FocusCounterAll++;
        if (is_tab_stop)
            win.DC.FocusCounterTab++;

        // Process TAB/Shift-TAB to tab *OUT* of the currently focused item.
        // (Note that we can always TAB out of a widget that doesn't allow tabbing in)
        if (g.ActiveId == id && g.FocusTabPressed &&
            !(g.ActiveIdBlockNavInputFlags & (1 << NavInput.KeyTab)) &&
              g.FocusRequestNextWindow == null)
        {
            g.FocusRequestNextWindow = win;
            g.FocusRequestNextCounterTab = win.DC.FocusCounterTab +
                        (g.IO.KeyShift ? (is_tab_stop ? -1 : 0) : +1);
                        // Modulo on index will be applied at the end of frame
                        // once we've got the total counter of items.
        }

        // Handle focus requests
        if (g.FocusRequestCurrWindow == win)
        {
            if (win.DC.FocusCounterAll == g.FocusRequestCurrCounterAll)
                return true;
            if (is_tab_stop && win.DC.FocusCounterTab == g.FocusRequestCurrCounterTab)
            {
                g.NavJustTabbedId = id;
                return true;
            }

            // If another item is about to be focused, we clear our own active id
            if (g.ActiveId == id)
                this.clearActiveID();
        }

        return false;
    },

    focusableItemUnregister(win)
    {
        win.DC.FocusCounterAll--;
        win.DC.FocusCounterTab--;
    },

    // ----- logging/capture ----
    logBegin(type, auto_open_depth)
    {},
    logToBuffer(auto_open_depth=-1)
    {},


    // inputs -------------------------------------------------------
    isKeyPressedMap(key, repeat=true)
    {
        const key_index = this.guictx.IO.KeyMap[key];
        return (key_index >= 0) ? this.IsKeyPressed(key_index, repeat) : false;
    },

    //  -- draw and drop --
    beginDragDropTargetCustom(bbox, id)
    {console.assert(0);},

    clearDragDrop()
    {console.assert(0);},

    isDragDropPayloadBeingAccepted()
    {console.assert(0);},

    // - Columns API -----
    beginColumns(id, count, flags)
    {console.assert(0);},
    endColumns()
    {console.assert(0);},
    pushColumnClipRect(colIndex)
    {console.assert(0);},


    // Widgets (implemented in widgets/text,scrollbar.js)
    textEx(text, textflags = 0)
    {console.assert(0);},
    scrollbar(axis)
    {console.assert(0);},
    setScrollbarID(win, axis)
    {console.assert(0);},

    //-------
    updateMouseWheel()
    {
        // we currently allow this to reside here since it modifies
        // global (non-IO) state related to scrolling, etc.
        let g = this.guictx;
        if (!g.HoveredWindow || g.HoveredWindow.Collapsed)
            return;
        if (g.IO.MouseWheel == 0. && g.IO.MouseWheelH == 0. &&
            g.IO.TouchDelta.x == 0 && g.IO.TouchDelta.y == 0)
            return;

        // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag,
        // we give a chance to scroll its parent (unless either
        // WindowFlags.NoInputs or WindowFlags.NoScrollbar are also set).
        let win = g.HoveredWindow;
        let scroll_window = win;
        while ((scroll_window.Flags & WindowFlags.ChildWindow) &&
              (scroll_window.Flags & WindowFlags.NoScrollWithMouse) &&
              !(scroll_window.Flags & WindowFlags.NoScrollbar) &&
              !(scroll_window.Flags & WindowFlags.NoMouseInputs) &&
               scroll_window.ParentWindow)
        {
            scroll_window = scroll_window.ParentWindow;
        }
        const scroll_allowed = !(scroll_window.Flags & WindowFlags.NoScrollWithMouse) &&
                               !(scroll_window.Flags & WindowFlags.NoMouseInputs);

        if (g.IO.MouseWheel != 0 || g.IO.TouchDelta.y != 0)
        {
            if (g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
            {
                // Zoom / Scale window
                let new_font_scale = win.FontWindowScale + g.IO.MouseWheel * 0.1;
                if(new_font_scale < .5) new_font_scale = .5;
                else if(new_font_scale > 2.5) new_font_scale = 2.5;
                const scale = new_font_scale / win.FontWindowScale;
                win.FontWindowScale = new_font_scale;

                let dp = Vec2.Subtract(g.IO.MousePos, win.Pos);
                let iws = Vec2.Mult(win.Size, 1-scale);
                let offset = Vec2.Divide(iws, win.Size).Mult(dp);
                win.Pos.Add(offset);
                win.Size.Mult(scale);
                win.SizeFull.Mult(scale);
            }
            else
            if (!g.IO.KeyCtrl && scroll_allowed)
            {
                // Mouse wheel vertical scrolling
                let amt = 5 * scroll_window.CalcLineHeight();
                amt = Math.floor(Math.min(amt,
                            .67*(scroll_window.ContentsRegionRect.GetHeight() +
                                 scroll_window.WindowPadding.y * 2)));
                if(g.IO.MouseWheel != 0)
                    amt *= g.IO.MouseWheel;
                else
                {
                    amt *= g.IO.TouchDelta.y;
                    if(g.IO.TouchActive == 0)
                    {
                        g.IO.TouchDelta.y *= .98; // <-- vertical deceleration
                        if(Math.abs(g.IO.TouchDelta.y) < .15)
                            g.IO.TouchDelta.y = 0;
                    }
                }
                scroll_window.SetWindowScrollY(scroll_window.Scroll.y - amt);
            }
        }
        if (g.IO.MouseWheelH != 0 || g.IO.TouchDelta.x != 0 &&
            scroll_allowed && !g.IO.KeyCtrl)
        {
            // Mouse wheel horizontal scrolling (for hardware that supports it)
            let amt = scroll_window.CalcLineHeight();
            if(g.IO.MouseWheelH != 0)
                amt *= g.IO.MouseWheelH;
            else
            {
                amt *= g.IO.TouchDelta.x;
                if(g.IO.TouchActive == 0)
                {
                    g.IO.TouchDelta.x *= .75; // <-- faster horizontal deceleration
                    if(Math.abs(g.IO.TouchDelta.x) < .15)
                        g.IO.TouchDelta.x = 0;
                }
            }
            scroll_window.SetWindowScrollX(scroll_window.Scroll.x - amt);
        }
    },

    beginListBox(label, size)
    {},

    // terminate the scrolling region. only call EndListBox() if BeginListBox()
    // returned true!
    endListBox()
    {},

    modPositive(a, b)
    {
        return (a + b) % b;
    },


};


// =====================================================================================================================
// misc.js END
// =====================================================================================================================
// =====================================================================================================================
// drawlist.js BEGIN
// =====================================================================================================================


let PathType = {
    Line: 0,
    Rect: 1,
    Arc: 2,
    Bezier: 3,
};

let Angles = [];
for(let i=0;i<13;i++)
    Angles.push(2*Math.PI*i/12);

/**
 * Deferred rendering machinery to support different window sort order.
 * Our goal is to 'capture' a lightweight representation of our public
 * method calls.
 */
 /*
 * NB: we must take care to capture low-level data and not references since
 * these are likely to change throughout frame description. Rules of thumb:
 *    * use javascript closure magic, but only for atomic datatypes (POD).
 *    * produce as light-weight capture as possible since data lifetime
 *      is frame and memory usage ~nwindows*widgets/window (plus additional
 *      global DrawLists for foreground and background).
 */
class DrawList
{
    constructor(imgui, owner)
    {
        this.imgui = imgui;
        this.canvas = imgui.canvas;
        this.canvasCtx = this.canvas.getContext("2d");
        this.owner = owner;
        this.flags = DrawListFlags.None;
        this.Clear();
    }

    Clear(layer=undefined)
    {
        if(layer == undefined)
            this.drawLayers = [[]]; // array of arrays
        else
            this.drawLayers[layer] = [];
        this.path = [];
        this.clipRectStack = [];
        this.LayerStack = [this.drawLayers[0]];
        this.currentLayer = this.drawLayers[0];
    }

    BeginLayer(i)
    {
        let layer = this.drawLayers[i];
        if(layer == undefined)
        {
            layer = [];
            this.drawLayers[i] = layer;
        }
        this.LayerStack.push(layer);
        this.currentLayer = layer;
    }

    EndLayer()
    {
        this.LayerStack.pop();
        this.currentLayer = this.LayerStack[this.LayerStack.length-1];
        console.assert(this.currentLayer != undefined);
    }

    Render(layer) // undefined means render all
    {
        if(layer == undefined)
        {
            for(let layer of this.drawLayers) // layer 0 under layer 1, etc
            {
                for(let i=0;i<layer.length;i++)
                    this.layer[i]();
            }
        }
        else
        {
            let drawlayer = this.drawLayers[layer];
            if(drawlayer != undefined)
            {
                for(let i=0;i<drawlayer.length;i++)
                    drawlayer[i]();
            }
        }
        this.Clear(layer);
    }

    // Render-level scissoring. This is passed down to your render function
    // but not used for CPU-side coarse clipping. Prefer using higher-level
    // ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
    PushClipRect(min, max, intersect_with_current_clip_rect=false)
    {
        let cr = new Rect(min, max);
        if (intersect_with_current_clip_rect && this.clipRectStack.length > 0)
        {
            let current = this.clipRectStack[this.clipRectStack.length-1];
            cr.ClipWith(current);
        }
        this.clipRectStack.push(cr);
    }

    PushClipRectFullScreen()
    {
        this.clipRectStack.push(null); // no clipping
        //this.PushClipRect(Vec2.Zero(false),
         //               new Vec2(this.canvas.width, this.canvas.height));
    }

    UpdateClipRect()
    {
        // intentionally left blank (for now)
    }

    PopClipRect()
    {
        this.clipRectStack.pop();
    }

    GetClipRect()
    {
        return this.clipRectStack[this.clipRectStack.length-1];
    }

    // Primitives
    AddLine(a, b, col, thickness=1.)
    {
        if(typeof(col) != "string")
            col = col.AsStr();
        this.currentLayer.push(this.drawLine.bind(this, a.x, a.y, b.x, b.y,
                                                col, thickness,
                                                this.getClipRect()));
    }

    // Lines assumed to be an array of [Vec2, Vec2, colorstr]
    AddLines(lines, thickness)
    {
        this.currentLayer.push(this.drawLines.bind(this, lines, thickness,
                                                this.getClipRect()));
    }

    // a: upper-left, b: lower-right,
    AddRect(a, b, col, rounding=0., corners=CornerFlags.All, thickness=1)
    {
        let w = b.x - a.x;
        let h = b.y - a.y;
        if(typeof(col) != "string")
            col = col.AsStr();
        this.currentLayer.push(this.drawRect.bind(this, a.x, a.y, w, h, col,
                                                rounding, corners, thickness,
                                                false, this.getClipRect()));
    }

    AddRectRamp(a, b, ramp, ttob) // ttob ? top-to-bottom : left-to-right
    {
        let w = b.x - a.x;
        let h = b.y - a.y;
        // XXX: do we need to "pickle" ramp?
        this.currentLayer.push(this.drawRectRamp.bind(this, a.x, a.y, w, h,
                                ramp, ttob, this.getClipRect()));
    }

    AddRectFilled(a, b, col, rounding=0, corners=CornerFlags.All)
    {
        let w = b.x - a.x;
        let h = b.y - a.y;
        if(typeof(col) != "string")
            col = col.AsStr();
        this.currentLayer.push(this.drawRect.bind(this, a.x, a.y, w, h,
                                col, rounding, corners, 0,
                                true, this.getClipRect()));
    }

    AddRectFilled4(x, y, w, h, fillstyle, rounding=0, corners=CornerFlags.All)
    {
        this.currentLayer.push(this.drawRect.bind(this, x, y, w, h,
                                fillstyle, rounding, corners, 0,
                                true, this.getClipRect()));
    }

    // NB: the entrypoint requires/assumes that the rects will remain
    // valid til the frame-draw is completed.
    //      Rects is an array of [x, y, w, h]
    AddRectsFilled(fill, rects, rounding=0)
    {
        this.currentLayer.push(this.drawRectsFilled.bind(this, fill,
                                rects, rounding, this.getClipRect()));
    }

    // a: upper-left, b: lower-right
    // currently we don't support bilinear interp, rather we expect
    // a vertical or horizontal only ramp which allows us to use
    // linear gradients.
    AddRectFilledMultiColor(a, b, uleftCol, urightCol, brightCol, bleftCol)
    {
        console.assert(uleftCol.Equals(urightCol) ||
                       uleftCol.Equals(bleftCol),
                      "linear gradients only");
        let w = b.x - a.x;
        let h = b.y - a.y;
        let c0 = uleftCol.AsStr();
        let c1;
        let ttob;
        if(uleftCol == urightCol) // top to bottom
        {
            c1 = bleftCol.AsStr();
            ttob = true;
        }
        else
        {
            c1 = urightCol.AsStr(); // left to right
            ttob = false;
        }
        this.currentLayer.push(this.drawRectRamp.bind(this, a.x, a.y, w, h,
                                                    [c0, c1], ttob,
                                                    this.getClipRect()));
    }

    AddQuad(a, b, c, d, col, thickness=1)
    {
        console.log("AddQuad is unimplemented");
    }

    AddQuadFilled(a, b, c, d, col)
    {
        console.log("AddQuad is unimplemented");
    }

    AddTriangle(a, b, c, col, thickness=1.)
    {
        if(typeof(col) != "string")
            col = col.AsStr();
        this.currentLayer.push(this.drawTriangle.bind(this,
                                a.x, a.y, b.x, b.y, c.x, c.y, col,
                                false, this.getClipRect()));
    }

    AddTriangleFilled(a, b, c, col)
    {
        if(typeof(col) != "string")
            col = col.AsStr();
        this.currentLayer.push(this.drawTriangle.bind(this,
                                a.x, a.y, b.x, b.y, c.x, c.y, col,
                                true, this.getClipRect()));
    }

    AddCircle(org, radius, col, thickness=1)
    {
        if(typeof(col) != "string")
            col = col.AsStr();
        this.currentLayer.push(this.drawCircle.bind(this, org.x, org.y,
                                    radius, col, false, thickness,
                                    this.getClipRect()));
    }

    AddCircleFilled(org, radius, col)
    {
        if(typeof(col) != "string")
            col = col.AsStr();
        this.currentLayer.push(this.drawCircle.bind(this, org.x, org.y,
                                    radius, col, true, 0,
                                    this.getClipRect()));
    }

    AddText(text, pos, font, lineHeight, col, wrap_width=0., clipRect=null)
    {
        let clip;
        if(typeof(col) != "string")
            col = col.AsStr();
        if(clipRect!=null)
        {
            /* need to clip the clipRect against the current clipRect */
            clipRect.ClipWith(this.GetClipRect());
            clip = [clipRect.Min.x, clipRect.Min.y,
                    clipRect.GetWidth(), clipRect.GetHeight()];
        }
        else
            clip = this.getClipRect();
        this.currentLayer.push(
            this.drawText.bind(this, text, font, lineHeight, pos.x, pos.y,
                                col, clip, wrap_width));
    }

    FillText(txt, x, y, fillStyle, baseline, align, font=null)
    {
        let clip = this.getClipRect();
        this.currentLayer.push(
            this.fillText.bind(this, txt, x, y, fillStyle, baseline, align,
                               font, clip));
    }

    // attrs is array of [fontstr,fillStyle,textBaseline,textAlign]
    // NB: attrs must persist 'til end of frame
    AddTexts(attrs, tarray)
    {
        let clip = this.getClipRect();
        this.currentLayer.push(
            this.fillTexts.bind(this, attrs, tarray, clip));
    }

    // rect is the target rect and may not be related to the img size.
    // actual image size can be obtained via the width & height properties.
    AddImage(img, rect, uv_a=null, uv_b=null, col=null)
    {
        let clip = this.getClipRect();
        let size = rect.GetSize();
        let cstr = col ? col.AsStr() : null;
        if(uv_a == null || uv_b == null)
        {
            this.currentLayer.push(
                this.drawImage.bind(this, img,
                                rect.Min.x, rect.Min.y,
                                size.x, size.y,
                                cstr, clip));
        }
        else
        {
            // in the 8 param case, dx is the target posision
            let srcPos = new Vec2(img.width*uv_a.x, img.height*uv_a.y);
            let srcSz = new Vec2(img.width * (uv_b.x - uv_a.x),
                                 img.height * (uv_b.x - uv_a.x));
            let dstPos = rect.Min;
            let dstSz = rect.GetSize();

            this.currentLayer.push(
                this.drawSubImage.bind(this, img,
                                srcPos.x, srcPos.y,
                                srcSz.x, srcSz.y,
                                dstPos.x, dstPos.y,
                                dstSz.x, dstSz.y,
                                cstr, clip));

        }
    }

    AddImageQuad(user_texture_id, a, b, c, d,
            uv_a=null, uv_b=null, uv_c=null, uv_d=null, col=null)
    {}

    AddImageRounded(user_texture_id, a, b, uv_a, uv_b, col,
                rounding, rounding_corners=CornerFlags.All)
    {}

    AddPolyline(points, col, closed, thickness)
    {}

    AddConvexPolyFilled(points, num_points, col)
    {}

    // Note: Anti-aliased filling requires points to be in clockwise order.
    AddBezierCurve(pos0, cp0, cp1, pos1, col, thickness, num_segments=0)
    {}

    // Stateful path API, add points then finish with PathFillConvex() or PathStroke()
    PathClear()
    {
        this.path.length = 0;
    }

    PathLineTo(pos)
    {
        this.path.push([PathType.Line, pos]);
    }

    PathLineToMergeDuplicate(pos)
    {
        let lastpt = this.path[this.path.length-1][0];
        if(lastpt == undefined || lastpt.x != pos.x || lastpt.y != pos.y)
            this.path.push([PathType.Line, pos]);
    }

    PathArcTo(org, radius, a_min, a_max, num_segments=10)
    {
        this.path.push([PathType.Arc, org, radius, a_min, a_max]);
    }

    PathArcToFast(org, radius, a_min_of_12, a_max_of_12)
    {
        // Use precomputed angles for a 12 steps circle
        this.path.push([PathType.Arc, org, radius,
                    Angles[a_min_of_12], Angles[a_max_of_12]]);
    }

    PathBezierCurveTo(p1, p2, p3, num_segments=0)
    {
        this.path.push([PathType.Bezier, p1, p2, p3]);
    }

    PathRect(a, b, rounding=0, corners_flags = CornerFlags.All)
    {
        if(rounding == 0 || corners_flags == 0)
        {
            this.PathLineTo(a);
            this.PathLineTo(new Vec2(b.x, a.y));
            this.PathLineTo(b);
            this.PathLineTo(new Vec2(a.x, b.y));
        }
        else
        {
            this.path.push([PathType.Rect, a, b, rounding, corners_flags]);
        }
    }

    PathFillConvex(col)
    {
        if(typeof(col) != "string")
            col = col.AsStr();
        this.currentLayer.push(this.drawPath.bind(this, this.path, col,
                                                "fillConvex"));
        this.path = [];
    }

    PathStroke(col, closed, thickness=1.)
    {
        if(typeof(col) != "string")
            col = col.AsStr();
        this.currentLayer.push(this.drawPath.bind(this, this.path, col,
                                                "stroke", closed, thickness));
        this.path = [];
    }

    // Channels
    // - Use to simulate layers. By switching channels to can render
    //   out-of-order (e.g. submit foreground primitives before background
    //   primitives)
    // - Use to minimize draw calls (e.g. if going back-and-forth between
    //   multiple non-overlapping clipping rectangles, prefer to append into
    //   separate channels then merge at the end)
    ChannelsSplit(channels_count)
    {}

    ChannelsMerge()
    {}

    ChannelsSetCurrent(channel_index)
    {}

    UpdateTextureID()
    {}

    /*-------------------------------------------------------------*/
    getClipRect()
    {
        let cr = this.GetClipRect();
        if(cr)
        {
            return [cr.Min.x, cr.Min.y, cr.GetWidth(), cr.GetHeight()];
        }
        else
            return [];
    }

    doClip(ctx, clip)
    {
        // clip is x,y,sizex,sizey
        ctx.beginPath();
        ctx.rect(clip[0], clip[1], clip[2], clip[3]);
        // ctx.fillStyle = "red";
        // ctx.fill();
        ctx.clip();
    }

    drawLine(ax, ay, bx, by, col, thickness, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        ctx.lineWidth = thickness;
        ctx.strokeStyle = col;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.stroke();
        ctx.restore();
    }

    drawLines(lines, thickness, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        ctx.lineWidth = thickness;
        for(let i=0;i<lines.length;i++)
        {
            let line = lines[i];
            ctx.strokeStyle = line[2];
            ctx.beginPath();
            ctx.moveTo(line[0].x, line[0].y);
            ctx.lineTo(line[1].x, line[1].y);
            ctx.stroke();
        }
        ctx.restore();
    }

    drawImage(img, x0, y0, xsize, ysize, tint, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        ctx.drawImage(img, x0, y0, xsize, ysize);
        ctx.restore();
    }

    drawSubImage(img, srcPosX, srcPosY, srcSizeX, srcSizeY,
                      dstPosX, dstPosY, dstSizeX, dstSizeY,
                      tint, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        ctx.drawImage(img, srcPosX, srcPosY, srcSizeX, srcSizeY,
                        dstPosX, dstPosY, dstSizeX, dstSizeY);
        ctx.restore();
    }

    drawTriangle(ax, ay, bx, by, cx, cy, col, fill, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        if(fill)
            ctx.fillStyle = col;
        else
            ctx.strokeStyle = col;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.lineTo(cx, cy);
        ctx.closePath();
        if(fill)
            ctx.fill();
        else
            ctx.stroke();
        ctx.restore();
    }

    // Rect -----------------------------------------------------------------
    drawRectsFilled(fill, rects, rounding, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        ctx.fillStyle = fill;
        if(rounding == 0)
        {
            for(let r of rects)
                ctx.fillRect(r[0], r[1], r[2], r[3]);
        }
        else
        {
            for(let r of rects)
            {
                this.roundRect(r[0], r[1], r[2], r[3], rounding,
                               CornerFlags.All, false, true);
            }
        }
        ctx.restore();
    }

    drawRect(x, y, w, h, col, rounding, corners, thickness, fill, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        if(fill)
            ctx.fillStyle = col;
        else
        {
            ctx.lineWidth = thickness;
            ctx.strokeStyle = col;
        }
        if(rounding == 0)
        {
            if(fill)
                ctx.fillRect(x, y, w, h);
            else
            {
                ctx.beginPath();
                ctx.rect(x, y, w, h);
                ctx.stroke();
            }
        }
        else
        {
            this.roundRect(x, y, w, h, rounding, corners, !fill, fill);
        }
        ctx.restore();
    }

    drawRectRamp(x, y, w, h, stops, ttob, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        let grd;
        if(ttob)
            grd = ctx.createLinearGradient(x, y, x, y+h);
        else
            grd = ctx.createLinearGradient(x, y, x+w, y);
        let t = 0, dt = 1 / (stops.length-1);
        for(let c of stops)
        {
            grd.addColorStop(t, c);
            t += dt;
        }
        ctx.fillStyle = grd;
        ctx.fillRect(x, y, w, h);
        ctx.restore();
    }

    roundRect(x, y, width, height, radius, corners, stroke=true, fill=true)
    {
        let ctx = this.canvasCtx;
        if(radius == 0)
            ctx.rect(x, y, width, height);
        else
        {
            //    c1---a---------------b----c2
            //     |                         |
            //     h                         c
            //     |                         |
            //     |                         |
            //     g                         d
            //     |                         |
            //    c4---f---------------e----c3
            ctx.beginPath();
            if(corners&CornerFlags.TopLeft)
                ctx.moveTo(x + radius, y); // a
            else
                ctx.moveTo(x, y); // c1
            ctx.lineTo(x + width - radius, y); // b
            if(corners&CornerFlags.TopRight)
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius); // c
            else
                ctx.lineTo(x + width, y); // c2

            ctx.lineTo(x + width, y + height - radius); // d
            if(corners&CornerFlags.BotRight)
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); // e
            else
                ctx.lineTo(x+width, y+height); // c3

            ctx.lineTo(x + radius, y + height); // f
            if(corners&CornerFlags.BotLeft)
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius); // g
            else
                ctx.lineTo(x, y+height); // c4
            if(corners&CornerFlags.TopLeft)
            {
                ctx.lineTo(x, y + radius); // h
                ctx.quadraticCurveTo(x, y, x + radius, y); // a
            }
            ctx.closePath();
        }
        if (stroke)
            ctx.stroke();
        if (fill)
            ctx.fill();
    }

    drawCircle(orgX, orgY, radius, col, fill, thickness, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        ctx.beginPath();
        if(fill)
        {
            ctx.fillStyle = col;
            ctx.lineWidth = 0;
        }
        else
        {
            ctx.strokeStyle = col;
            ctx.lineWidth = thickness;
        }
        ctx.arc(orgX, orgY, radius, 0, 2*Math.PI);
        if(fill)
            ctx.fill();
        else
            ctx.stroke();
        ctx.restore();
    }

    drawPath(path, style, op, closed, thickness, clip)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        ctx.beginPath();
        for(let i=0;i<path.length;i++)
        {
            let el = path[i];
            switch(el[0])
            {
            case PathType.Line:
                {
                    let p = el[1];
                    if(i == 0)
                        ctx.moveTo(p.x, p.y);
                    else
                        ctx.lineTo(p.x, p.y);
                }
                break;
            case PathType.Arc:
                {
                    let org = el[1];
                    let rad = el[2];
                    let amin = el[3];
                    let amax = el[4];
                    ctx.arc(org.x, org.y, rad, amin, amax);
                }
                break;
            case PathType.Bezier:
                {
                    let p1 = el[1];
                    let p2 = el[2];
                    let p3 = el[2];
                    console.assert(i != 0, "bezier move to");
                    if(i != 0)
                        ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                }
                break;
            case PathType.Rect:
                {
                    let min = el[1];
                    let max = el[2];
                    let rounding = el[3];
                    let corners = el[4];
                    this.roundRect(min.x, min.y,
                                    max.x - min.x, max.y - min.y,
                                    rounding, corners,
                                    false, false);
                }
                break;
            }
        }
        if(op == "stroke")
        {
            ctx.lineWidth = thickness;
            ctx.strokeStyle = style;
            ctx.stroke();
        }
        else
        {
            ctx.fillStyle = style;
            ctx.fill();
        }
        ctx.restore();
    }

    // Text ---------------------------------------------------------------
    // basic ideas:
    //    - lineHeight is intra-line spacing.
    //    - (lineHeight - font.Size)/2 + font.Baseline is a reasonable offet
    // see also: https://smad.jmu.edu/shen/webtype/index.html
    drawText(text, font, lineHeight, x, y, col, clip, wrapWidth)
    {
        let ctx = this.canvasCtx;
        let sz = Vec2.Zero();

        ctx.save();
        ctx.font = font.AsStr();
        if(clip) this.doClip(ctx, clip);
        ctx.fillStyle = col;

        let lines = font.MeasureText(text, wrapWidth, lineHeight, sz);
        let i = 0;
        let offset = y + (lineHeight - font.Size) / 2 + font.Baseline;
        for(let line of lines)
        {
            if(line.length > 0)
            {
                /*if(line.charCodeAt(0) <= 32)
                    console.log(`'${line}'`);*/
                ctx.fillText(line, x, offset + (lineHeight*i));
            }
            i++;
        }
        ctx.restore();
    }

    // simple version of drawText, with overridable font
    fillText(txt, x, y, fillStyle, baseline, align, font=null, clip=null)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        if(font)
        {
            if(font.AsStr)
                ctx.font = font.AsStr();
            else
                ctx.font = font;
        }
        ctx.fillStyle = fillStyle;
        ctx.textBaseline = baseline;
        ctx.textAlign = align;
        ctx.fillText(txt, x, y);
        ctx.restore();
    }

    // array of texts that share the same attributes
    // attrs is: [font,fillstyle,baseline,align]
    // tarray is array of [txt, x, y]
    fillTexts(attrs, tarray, clip=null)
    {
        let ctx = this.canvasCtx;
        ctx.save();
        if(clip) this.doClip(ctx, clip);
        ctx.font = attrs[0];
        ctx.fillStyle = attrs[1];
        ctx.textBaseline = attrs[2];
        ctx.textAlign = attrs[3];
        for(let i=0;i<tarray.length;i++)
        {
            let t = tarray[i];
            ctx.fillText(t[0], t[1], t[2]);
        }
        ctx.restore();
    }

}

// =====================================================================================================================
// drawlist.js END
// =====================================================================================================================
// =====================================================================================================================
// types.js BEGIN
// =====================================================================================================================

/*
    This file exports:
        ValRef - support for pass by reference (of POD)
        Vec1 - float utilities, container of a single float
        Vec2 - 2d vector
        Rect - rectangle
        MutableString -
 */

/**
 * used to pass by reference a simple value that can be modified by target.
 * useful for changing various visibility configs.
 */
class ValRef
{
    constructor(val)
    {
        this.value = val;
    }

    get() { return this.value; }
    set(v) { this.value = v; }
    toggle() { this.value = !this.value; }
}

/**
 * Vec1 is an object that is comprised of a single number.
 * It is also a repository for utility functions as static methods.
 */
class Vec1
{
    constructor(x)
    {
        this.x = x;
    }

    Clone()
    {
        return new Vec1(this.x);
    }

    static Lerp(a, b, pct)
    {
        if(typeof(a) == "number")
            return a + (b-a) * pct;
        else
            console.assert(false);
    }

    static Clamp(a, min, max)
    {
        if(a < min) return min;
        if(a > max) return max;
        return a;
    }

    static Saturate(val)
    {
        return (val < 0) ? 0 : (val > 1) ? 1 : val;
    }
}

let sZero;
let sMaxValue;
let sMaxNegValue;

class Vec2
{
    constructor(x, y)
    {
        this.x = x === undefined ? 0 : x;
        this.y = y === undefined ? 0 : y;
    }

    Equals(other)
    {
        return this.x == other.x && this.y == other.y;
    }

    IsNaN()
    {
        return isNaN(this.x) || isNaN(this.y);
    }

    Clone()
    {
        return new Vec2(this.x, this.y);
    }

    Copy(src)
    {
        this.x = src.x;
        this.y = src.y;
    }

    CopyXY(x, y)
    {
        this.x = x;
        this.y = y;
    }

    Add(other)
    {
        if(typeof(other) == "number")
        {
            this.x += other;
            this.y += other;
        }
        else
        {
            this.x += other.x;
            this.y += other.y;
        }
        return this; // chainable
    }

    AddXY(x, y)
    {
        this.x += x;
        this.y += y;
        return this;
    }

    Subtract(other)
    {
        if(typeof(other) == "number")
        {
            this.x -= other;
            this.y -= other;
        }
        else
        {
            this.x -= other.x;
            this.y -= other.y;
        }
        return this; // chainable
    }

    SubtractXY(x, y)
    {
        this.x -= x;
        this.y -= y;
        return this; // chainable
    }

    Mult(other)
    {
        if(typeof(other) == "number")
        {
            this.x *= other;
            this.y *= other;
        }
        else
        {
            this.x *= other.x;
            this.y *= other.y;
        }
        return this; // chainable
    }

    MultXY(x, y)
    {
        this.x *= x;
        this.y *= y;
        return this;
    }

    Divide(other)
    {
        if(typeof(other) == "number")
        {
            this.x /= other;
            this.y /= other;
        }
        else
        {
            this.x /= other.x;
            this.y /= other.y;
        }
        return this; // chainable
    }

    Floor()
    {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }

    LengthSq()
    {
        return this.x * this.x + this.y * this.y;
    }

    static Zero(clone=true)
    {
        if(sZero == undefined)
            sZero = new Vec2(0, 0);
        return clone ? sZero.Clone() : sZero;
    }

    static MAX_VALUE(clone=true)
    {
        if(sMaxValue == undefined)
            sMaxValue = new Vec2(Number.MAX_VALUE, Number.MAX_VALUE);
        return clone ? sMaxValue.Clone() : sMaxValue;
    }

    static MAX_NEGVALUE(clone=true)
    {
        if(sMaxNegValue == undefined)
            sMaxNegValue = new Vec2(-Number.MAX_VALUE, -Number.MAX_VALUE);
        return clone ? sMaxNegValue.Clone() : sMaxNegValue;
    }

    static Add(a, b, c)
    {
        if(typeof(b) == "number")
        {
            if(c==undefined)
                c = b;
            return new Vec2(a.x + b, a.y + c);
        }
        else
            return new Vec2(a.x + b.x, a.y + b.y);
    }

    static AddXY(a, x, y)
    {
        return new Vec2(a.x + x, a.y + y);
    }

    static Subtract(a, b)
    {
        return new Vec2(a.x - b.x, a.y - b.y);
    }

    static SubtractXY(a, x, y)
    {
        return new Vec2(a.x - x, a.y - y);
    }

    static Scale(a, factor)
    {
        return Vec2.Mult(a, factor);
    }

    static Mult(a, factor)
    {
        if(typeof(factor) == "number")
            return new Vec2(a.x*factor, a.y*factor);
        else
            return new Vec2(a.x*factor.x, a.y*factor.y);
    }

    static MultXY(a, mx, my)
    {
        return new Vec2(a.x*mx, a.y*my);
    }

    static Divide(a, factor)
    {
        if(typeof(factor) == "number")
            return new Vec2(a.x/factor, a.y/factor);
        else
            return new Vec2(a.x/factor.x, a.y/factor.y);
    }

    static LengthSq(a, b)
    {
        let dp = Vec2.Subtract(a, b);
        return dp.LengthSq();
    }

    static Dot(a, b)
    {
        return a.x * b.x + a.y + b.y;
    }

    static Min(lhs, rhs)
    {
        return new Vec2(lhs.x < rhs.x ? lhs.x : rhs.x,
                        lhs.y < rhs.y ? lhs.y : rhs.y);
    }

    static Max(lhs, rhs)
    {
        return new Vec2(lhs.x >= rhs.x ? lhs.x : rhs.x,
                        lhs.y >= rhs.y ? lhs.y : rhs.y);
    }

    static Clamp(v, mn, mx)
    {
        return new Vec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x,
                        (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y);
    }

    static Floor(v)
    {
        return new Vec2(Math.floor(v.x), Math.floor(v.y));
    }

    static Lerp(a, b, pct)
    {
        if(typeof(pct) == "number")
            return new Vec2(a.x + (b.x - a.x) * pct,
                            a.y + (b.y - a.y) * pct);
        else
            return new Vec2(a.x + (b.x - a.x) * pct.x,
                            a.y + (b.y - a.y) * pct.y);
    }
}

class Rect
{
    // accept no args, 2 pts, or 4 numbers
    constructor(a=null, b=null, c=null, d=null, clone=true)
    {
        if(a == null)
        {
            // default rect
            this.Min = new Vec2(Number.MAX_VALUE, Number.MAX_VALUE);
            this.Max = new Vec2(-Number.MAX_VALUE, -Number.MAX_VALUE);
        }
        else
        if(typeof(c) == "number")
        {
            // four numbers
            this.Min = new Vec2(a, b);
            this.Max = new Vec2(c, d);
        }
        else
        {
            // two points
            if(clone)
            {
                this.Min = a.Clone();
                this.Max = b.Clone();
            }
            else
            {
                this.Min = a;
                this.Max = b;
            }
        }
    }

    static Expand(r, val)
    {
        return Rect.FromRect(r).Expand(val);
    }

    static FromRect(r)
    {
        return new Rect(r.Min, r.Max);
    }

    static FromXY(x1, y1, x2, y2)
    {
        if(typeof(x1)== "number")
        {
            return new Rect(new Vec2(x1, y1), new Vec2(x2, y2), false);
        }
        else
        {
            // minpt, xmax, ymax
            console.assert(y2 == undefined);
            return new Rect(x1.Clone(), new Vec2(y1, x2));
        }
    }

    Clone()
    {
        return Rect.FromRect(this);
    }

    Copy(src)
    {
        this.Min.Copy(src.Min);
        this.Max.Copy(src.Max);
    }

    IsNaN()
    {
        return this.Min.IsNaN() || this.Max.IsNaN();
    }

    IsValid()
    {
        if(this.Min.x == Number.MAX_VALUE &&
           this.Min.y == Number.MAX_VALUE &&
           this.Max.x == -Number.MAX_VALUE &&
           this.Max.y == -Number.MAX_VALUE)
        {
           return false;
        }
        else
            return true;
    }

    GetTL()
    {
        return this.Min;
    }

    GetTR()
    {
        return new Vec2(this.Max.x, this.Min.y);
    }

    GetBR()
    {
        return this.Max;
    }

    GetBL()
    {
        return new Vec2(this.Min.x, this.Max.y);
    }

    GetMin()
    {
        return this.Min;
    }

    GetMax()
    {
        return this.Max;
    }

    GetSize()
    {
        return new Vec2(this.GetWidth(), this.GetHeight());
    }

    SetSize(sz, szy=undefined) // polymorph Vec2 or x, y
    {
        if(szy != undefined)
        {
            this.Max.x = this.Min.x + sz;
            this.Max.y = this.Min.y + szy;
        }
        else
        {
            this.Max.x = this.Min.x + sz.x;
            this.Max.y = this.Min.y + sz.y;
        }
    }

    GetWidth()
    {
        return (this.Max.x - this.Min.x);
    }

    GetHeight()
    {
        return (this.Max.y - this.Min.y);
    }

    GetCenter()
    {
        return new Vec2(this.Min.x + .5 * this.GetWidth(),
                        this.Min.y + .5 * this.GetHeight());
    }

    Contains(p)
    {
        if(p.x != undefined)
            return this.ContainsPt(p);
        else
        if(p.Min)
            return this.ContainsRect(p);
        else
            console.assert("unexpected parameter");
    }

    ContainsPt(p)
    {
        return p.x >= this.Min.x &&
               p.y >= this.Min.y &&
               p.x < this.Max.x &&
               p.y < this.Max.y;
    }

    ContainsRect(r)
    {
        return r.Min.x >= this.Min.x &&
               r.Min.y >= this.Min.y &&
               r.Max.x <= this.Max.x &&
               r.Max.y <= this.Max.y;
    }

    Overlaps(r)
    {
        return r.Min.y < this.Max.y &&
               r.Max.y > this.Min.y &&
               r.Min.x < this.Max.x &&
               r.Max.x > this.Min.x;
    }

    AddPt(p) // grow the rect to include pt
    {
        if(this.Min.x > p.x) this.Min.x = p.x;
        if(this.Min.y > p.y) this.Min.y = p.y;
        if(this.Max.x < p.x) this.Max.x = p.x;
        if(this.Max.y < p.y) this.Max.y = p.y;
    }

    AddRect(r) // grow the rect to include r
    {
        if(this.Min.x > r.Min.x) this.Min.x = r.Min.x;
        if(this.Min.y > r.Min.y) this.Min.y = r.Min.y;
        if(this.Max.x < r.Max.x) this.Max.x = r.Max.x;
        if(this.Max.y < r.Max.y) this.Max.y = r.Max.y;
    }

    Expand(val)
    {
        if(typeof(val) == "number")
            this.expandF(val);
        else
            this.expandXY(val.x, val.y);
        return this;
    }

    expandF(amount)
    {
        this.Min.x -= amount;
        this.Min.y -= amount;
        this.Max.x += amount;
        this.Max.y += amount;
    }

    expandXY(x, y)
    {
        this.Min.x -= x;
        this.Min.y -= y;
        this.Max.x += x;
        this.Max.y += y;
    }

    Translate(pt)
    {
        this.Min.x += pt.x;
        this.Min.y += pt.y;
        this.Max.x += pt.x;
        this.Max.y += pt.y;
    }

    TranslateX(dx)
    {
        this.Min.x += dx;
        this.Max.x += dx;
    }

    TranslateY(dy)
    {
        this.Min.y += dy;
        this.Max.y += dy;
    }

    ClipWith(r) // r is Rect
    {
        // Simple version, may lead to an inverted rectangle, which is fine
        // for Contains/Overlaps test but not for display.
        this.Min = Vec2.Max(this.Min, r.Min);
        this.Max = Vec2.Min(this.Max, r.Max);
        return this;
    }

    ClipWithFull(r)
    {
        // Full version, ensure both points are fully clipped.
        this.Min = Vec2.Clamp(this.Min, r.Min, r.Max);
        this.Max = Vec2.Clamp(this.Max, r.Min, r.Max);
        return this;
    }

    Floor()
    {
        this.Min.x = Math.floor(this.Min.x);
        this.Min.y = Math.floor(this.Min.y);
        this.Max.x = Math.floor(this.Max.x);
        this.Max.y = Math.floor(this.Max.y);
        return this;
    }

    IsInverted()
    {
        return this.Min.x > this.Max.x || this.Min.y > this.Max.y;
    }
}

class MutableString
{
    constructor(str="")
    {
        this.str = str;
    }

    IsMutable() {}

    Clone()
    {
        // since str's are immutable, it's as simple as this:
        return new MutableString(this.str);
    }

    Copy(mstr)
    {
        console.assert(mstr.IsMutable);
        this.str = mstr.str;
    }

    Equals(str)
    {
        if(str.IsMutable)
            return this.str == str.str;
        else
            return this.str == str;
    }

    Get()
    {
        return this.str;
    }

    toString()
    {
        return this.str;
    }

    Set(str)
    {
        this.str = str ? str : "";
    }

    Length()
    {
        return this.str ? this.str.length : 0;
    }

    CountLines()
    {
        let linecount=1;
        for(let i=0;i<this.str.length;i++)
        {
            if(this.str.charCodeAt(i) == 10) // 0x0a
                linecount++;
        }
        return linecount;
    }

    GetChar(idx)
    {
        return this.str[idx];
    }

    // walk backward from idx, looking for newline
    FindLineBegin(idx)
    {
        for(let i=idx-1;i>=0;i--)
        {
            if(this.str.charCodeAt(i) == 10)
                return i+1;
        }
        return 0;
    }

    IsNewline(idx)
    {
        return this.str.charCodeAt(idx) == 10;
    }

    IsSeparator(idx)
    {
        return /[\s,;(){}|]/.test(this.str[idx]);
    }

    GetCharCode(idx)
    {
        return this.str.charCodeAt(idx);
    }

    GetChars(where, len)
    {
        return this.str.slice(where, where+len);
    }

    DeleteChars(where, len)
    {
        this.Splice(where, len);
    }

    InsertChars(where, chars)
    {
        this.Splice(where, 0, chars);
    }

    /**
     * The splice() method changes the content of a string by removing a range of
     * characters and/or adding new characters.
     *
     * @this {String}
     * @param {number} start Index at which to start changing the string.
     * @param {number} delCount An integer indicating the number of old chars to remove.
     * @param {string} newSubStr The String that is spliced in.
     */
    Splice(start, delCount, newSubStr)
    {
        let str = this.str;
        if(newSubStr)
            this.str = str.slice(0, start) + newSubStr + str.slice(start+delCount);
        else
            this.str = str.slice(0, start) + str.slice(start+delCount);
    }
}


// =====================================================================================================================
// types.js END
// =====================================================================================================================
// =====================================================================================================================
// fontijmap.js BEGIN
// =====================================================================================================================

// this file contains a map from font name to the ijmap for that font
// the ijmap is used to map a unicode number to an icon description.
// we really would like the inverse: find the char code from the icon-name,
// so at load time we append the map with a field: codes that does this.

let materialIconsIJMap = {"icons":{"e84d":{"name":"3d Rotation"},"eb3b":{"name":"Ac Unit"},"e190":{"name":"Access Alarm"},"e191":{"name":"Access Alarms"},"e192":{"name":"Access Time"},"e84e":{"name":"Accessibility"},"e914":{"name":"Accessible"},"e84f":{"name":"Account Balance"},"e850":{"name":"Account Balance Wallet"},"e851":{"name":"Account Box"},"e853":{"name":"Account Circle"},"e60e":{"name":"Adb"},"e145":{"name":"Add"},"e439":{"name":"Add A Photo"},"e193":{"name":"Add Alarm"},"e003":{"name":"Add Alert"},"e146":{"name":"Add Box"},"e147":{"name":"Add Circle"},"e148":{"name":"Add Circle Outline"},"e567":{"name":"Add Location"},"e854":{"name":"Add Shopping Cart"},"e39d":{"name":"Add To Photos"},"e05c":{"name":"Add To Queue"},"e39e":{"name":"Adjust"},"e630":{"name":"Airline Seat Flat"},"e631":{"name":"Airline Seat Flat Angled"},"e632":{"name":"Airline Seat Individual Suite"},"e633":{"name":"Airline Seat Legroom Extra"},"e634":{"name":"Airline Seat Legroom Normal"},"e635":{"name":"Airline Seat Legroom Reduced"},"e636":{"name":"Airline Seat Recline Extra"},"e637":{"name":"Airline Seat Recline Normal"},"e195":{"name":"Airplanemode Active"},"e194":{"name":"Airplanemode Inactive"},"e055":{"name":"Airplay"},"eb3c":{"name":"Airport Shuttle"},"e855":{"name":"Alarm"},"e856":{"name":"Alarm Add"},"e857":{"name":"Alarm Off"},"e858":{"name":"Alarm On"},"e019":{"name":"Album"},"eb3d":{"name":"All Inclusive"},"e90b":{"name":"All Out"},"e859":{"name":"Android"},"e85a":{"name":"Announcement"},"e5c3":{"name":"Apps"},"e149":{"name":"Archive"},"e5c4":{"name":"Arrow Back"},"e5db":{"name":"Arrow Downward"},"e5c5":{"name":"Arrow Drop Down"},"e5c6":{"name":"Arrow Drop Down Circle"},"e5c7":{"name":"Arrow Drop Up"},"e5c8":{"name":"Arrow Forward"},"e5d8":{"name":"Arrow Upward"},"e060":{"name":"Art Track"},"e85b":{"name":"Aspect Ratio"},"e85c":{"name":"Assessment"},"e85d":{"name":"Assignment"},"e85e":{"name":"Assignment Ind"},"e85f":{"name":"Assignment Late"},"e860":{"name":"Assignment Return"},"e861":{"name":"Assignment Returned"},"e862":{"name":"Assignment Turned In"},"e39f":{"name":"Assistant"},"e3a0":{"name":"Assistant Photo"},"e226":{"name":"Attach File"},"e227":{"name":"Attach Money"},"e2bc":{"name":"Attachment"},"e3a1":{"name":"Audiotrack"},"e863":{"name":"Autorenew"},"e01b":{"name":"Av Timer"},"e14a":{"name":"Backspace"},"e864":{"name":"Backup"},"e19c":{"name":"Battery Alert"},"e1a3":{"name":"Battery Charging Full"},"e1a4":{"name":"Battery Full"},"e1a5":{"name":"Battery Std"},"e1a6":{"name":"Battery Unknown"},"eb3e":{"name":"Beach Access"},"e52d":{"name":"Beenhere"},"e14b":{"name":"Block"},"e1a7":{"name":"Bluetooth"},"e60f":{"name":"Bluetooth Audio"},"e1a8":{"name":"Bluetooth Connected"},"e1a9":{"name":"Bluetooth Disabled"},"e1aa":{"name":"Bluetooth Searching"},"e3a2":{"name":"Blur Circular"},"e3a3":{"name":"Blur Linear"},"e3a4":{"name":"Blur Off"},"e3a5":{"name":"Blur On"},"e865":{"name":"Book"},"e866":{"name":"Bookmark"},"e868":{"name":"Bookmark Border"},"e228":{"name":"Border All"},"e229":{"name":"Border Bottom"},"e22a":{"name":"Border Clear"},"e22b":{"name":"Border Color"},"e22c":{"name":"Border Horizontal"},"e22d":{"name":"Border Inner"},"e22e":{"name":"Border Left"},"e22f":{"name":"Border Outer"},"e230":{"name":"Border Right"},"e231":{"name":"Border Style"},"e232":{"name":"Border Top"},"e233":{"name":"Border Vertical"},"e06b":{"name":"Branding Watermark"},"e3a6":{"name":"Brightness 1"},"e3a7":{"name":"Brightness 2"},"e3a8":{"name":"Brightness 3"},"e3a9":{"name":"Brightness 4"},"e3aa":{"name":"Brightness 5"},"e3ab":{"name":"Brightness 6"},"e3ac":{"name":"Brightness 7"},"e1ab":{"name":"Brightness Auto"},"e1ac":{"name":"Brightness High"},"e1ad":{"name":"Brightness Low"},"e1ae":{"name":"Brightness Medium"},"e3ad":{"name":"Broken Image"},"e3ae":{"name":"Brush"},"e6dd":{"name":"Bubble Chart"},"e868":{"name":"Bug Report"},"e869":{"name":"Build"},"e43c":{"name":"Burst Mode"},"e0af":{"name":"Business"},"eb3f":{"name":"Business Center"},"e86a":{"name":"Cached"},"e7e9":{"name":"Cake"},"e0b0":{"name":"Call"},"e0b1":{"name":"Call End"},"e0b2":{"name":"Call Made"},"e0b3":{"name":"Call Merge"},"e0b4":{"name":"Call Missed"},"e0e4":{"name":"Call Missed Outgoing"},"e0b5":{"name":"Call Received"},"e0b6":{"name":"Call Split"},"e06c":{"name":"Call To Action"},"e3af":{"name":"Camera"},"e3b0":{"name":"Camera Alt"},"e8fc":{"name":"Camera Enhance"},"e3b1":{"name":"Camera Front"},"e3b2":{"name":"Camera Rear"},"e3b3":{"name":"Camera Roll"},"e5c9":{"name":"Cancel"},"e8f6":{"name":"Card Giftcard"},"e8f7":{"name":"Card Membership"},"e8f8":{"name":"Card Travel"},"eb40":{"name":"Casino"},"e307":{"name":"Cast"},"e308":{"name":"Cast Connected"},"e3b4":{"name":"Center Focus Strong"},"e3b5":{"name":"Center Focus Weak"},"e86b":{"name":"Change History"},"e0b7":{"name":"Chat"},"e0ca":{"name":"Chat Bubble"},"e0cb":{"name":"Chat Bubble Outline"},"e5ca":{"name":"Check"},"e834":{"name":"Check Box"},"e835":{"name":"Check Box Outline Blank"},"e86c":{"name":"Check Circle"},"e5cb":{"name":"Chevron Left"},"e5cc":{"name":"Chevron Right"},"eb41":{"name":"Child Care"},"eb42":{"name":"Child Friendly"},"e86d":{"name":"Chrome Reader Mode"},"e86e":{"name":"Class"},"e14c":{"name":"Clear"},"e0b8":{"name":"Clear All"},"e5cd":{"name":"Close"},"e01c":{"name":"Closed Caption"},"e2bd":{"name":"Cloud"},"e2be":{"name":"Cloud Circle"},"e2bf":{"name":"Cloud Done"},"e2c0":{"name":"Cloud Download"},"e2c1":{"name":"Cloud Off"},"e2c2":{"name":"Cloud Queue"},"e2c3":{"name":"Cloud Upload"},"e86f":{"name":"Code"},"e3b6":{"name":"Collections"},"e431":{"name":"Collections Bookmark"},"e3b7":{"name":"Color Lens"},"e3b8":{"name":"Colorize"},"e0b9":{"name":"Comment"},"e3b9":{"name":"Compare"},"e915":{"name":"Compare Arrows"},"e30a":{"name":"Computer"},"e638":{"name":"Confirmation Number"},"e0d0":{"name":"Contact Mail"},"e0cf":{"name":"Contact Phone"},"e0ba":{"name":"Contacts"},"e14d":{"name":"Content Copy"},"e14e":{"name":"Content Cut"},"e14f":{"name":"Content Paste"},"e3ba":{"name":"Control Point"},"e3bb":{"name":"Control Point Duplicate"},"e90c":{"name":"Copyright"},"e150":{"name":"Create"},"e2cc":{"name":"Create New Folder"},"e870":{"name":"Credit Card"},"e3be":{"name":"Crop"},"e3bc":{"name":"Crop 16 9"},"e3bd":{"name":"Crop 3 2"},"e3bf":{"name":"Crop 5 4"},"e3c0":{"name":"Crop 7 5"},"e3c1":{"name":"Crop Din"},"e3c2":{"name":"Crop Free"},"e3c3":{"name":"Crop Landscape"},"e3c4":{"name":"Crop Original"},"e3c5":{"name":"Crop Portrait"},"e437":{"name":"Crop Rotate"},"e3c6":{"name":"Crop Square"},"e871":{"name":"Dashboard"},"e1af":{"name":"Data Usage"},"e916":{"name":"Date Range"},"e3c7":{"name":"Dehaze"},"e872":{"name":"Delete"},"e92b":{"name":"Delete Forever"},"e16c":{"name":"Delete Sweep"},"e873":{"name":"Description"},"e30b":{"name":"Desktop Mac"},"e30c":{"name":"Desktop Windows"},"e3c8":{"name":"Details"},"e30d":{"name":"Developer Board"},"e1b0":{"name":"Developer Mode"},"e335":{"name":"Device Hub"},"e1b1":{"name":"Devices"},"e337":{"name":"Devices Other"},"e0bb":{"name":"Dialer Sip"},"e0bc":{"name":"Dialpad"},"e52e":{"name":"Directions"},"e52f":{"name":"Directions Bike"},"e532":{"name":"Directions Boat"},"e530":{"name":"Directions Bus"},"e531":{"name":"Directions Car"},"e534":{"name":"Directions Railway"},"e566":{"name":"Directions Run"},"e533":{"name":"Directions Subway"},"e535":{"name":"Directions Transit"},"e536":{"name":"Directions Walk"},"e610":{"name":"Disc Full"},"e875":{"name":"Dns"},"e612":{"name":"Do Not Disturb"},"e611":{"name":"Do Not Disturb Alt"},"e643":{"name":"Do Not Disturb Off"},"e644":{"name":"Do Not Disturb On"},"e30e":{"name":"Dock"},"e7ee":{"name":"Domain"},"e876":{"name":"Done"},"e877":{"name":"Done All"},"e917":{"name":"Donut Large"},"e918":{"name":"Donut Small"},"e151":{"name":"Drafts"},"e25d":{"name":"Drag Handle"},"e613":{"name":"Drive Eta"},"e1b2":{"name":"Dvr"},"e3c9":{"name":"Edit"},"e568":{"name":"Edit Location"},"e8fb":{"name":"Eject"},"e0be":{"name":"Email"},"e63f":{"name":"Enhanced Encryption"},"e01d":{"name":"Equalizer"},"e000":{"name":"Error"},"e001":{"name":"Error Outline"},"e926":{"name":"Euro Symbol"},"e56d":{"name":"Ev Station"},"e878":{"name":"Event"},"e614":{"name":"Event Available"},"e615":{"name":"Event Busy"},"e616":{"name":"Event Note"},"e903":{"name":"Event Seat"},"e879":{"name":"Exit To App"},"e5ce":{"name":"Expand Less"},"e5cf":{"name":"Expand More"},"e01e":{"name":"Explicit"},"e87a":{"name":"Explore"},"e3ca":{"name":"Exposure"},"e3cb":{"name":"Exposure Neg 1"},"e3cc":{"name":"Exposure Neg 2"},"e3cd":{"name":"Exposure Plus 1"},"e3ce":{"name":"Exposure Plus 2"},"e3cf":{"name":"Exposure Zero"},"e87b":{"name":"Extension"},"e87c":{"name":"Face"},"e01f":{"name":"Fast Forward"},"e020":{"name":"Fast Rewind"},"e87d":{"name":"Favorite"},"e87e":{"name":"Favorite Border"},"e06d":{"name":"Featured Play List"},"e06e":{"name":"Featured Video"},"e87f":{"name":"Feedback"},"e05d":{"name":"Fiber Dvr"},"e061":{"name":"Fiber Manual Record"},"e05e":{"name":"Fiber New"},"e06a":{"name":"Fiber Pin"},"e062":{"name":"Fiber Smart Record"},"e2c4":{"name":"File Download"},"e2c6":{"name":"File Upload"},"e3d3":{"name":"Filter"},"e3d0":{"name":"Filter 1"},"e3d1":{"name":"Filter 2"},"e3d2":{"name":"Filter 3"},"e3d4":{"name":"Filter 4"},"e3d5":{"name":"Filter 5"},"e3d6":{"name":"Filter 6"},"e3d7":{"name":"Filter 7"},"e3d8":{"name":"Filter 8"},"e3d9":{"name":"Filter 9"},"e3da":{"name":"Filter 9 Plus"},"e3db":{"name":"Filter B And W"},"e3dc":{"name":"Filter Center Focus"},"e3dd":{"name":"Filter Drama"},"e3de":{"name":"Filter Frames"},"e3df":{"name":"Filter Hdr"},"e152":{"name":"Filter List"},"e3e0":{"name":"Filter None"},"e3e2":{"name":"Filter Tilt Shift"},"e3e3":{"name":"Filter Vintage"},"e880":{"name":"Find In Page"},"e881":{"name":"Find Replace"},"e90d":{"name":"Fingerprint"},"e5dc":{"name":"First Page"},"eb43":{"name":"Fitness Center"},"e153":{"name":"Flag"},"e3e4":{"name":"Flare"},"e3e5":{"name":"Flash Auto"},"e3e6":{"name":"Flash Off"},"e3e7":{"name":"Flash On"},"e539":{"name":"Flight"},"e904":{"name":"Flight Land"},"e905":{"name":"Flight Takeoff"},"e3e8":{"name":"Flip"},"e882":{"name":"Flip To Back"},"e883":{"name":"Flip To Front"},"e2c7":{"name":"Folder"},"e2c8":{"name":"Folder Open"},"e2c9":{"name":"Folder Shared"},"e617":{"name":"Folder Special"},"e167":{"name":"Font Download"},"e234":{"name":"Format Align Center"},"e235":{"name":"Format Align Justify"},"e236":{"name":"Format Align Left"},"e237":{"name":"Format Align Right"},"e238":{"name":"Format Bold"},"e239":{"name":"Format Clear"},"e23a":{"name":"Format Color Fill"},"e23b":{"name":"Format Color Reset"},"e23c":{"name":"Format Color Text"},"e23d":{"name":"Format Indent Decrease"},"e23e":{"name":"Format Indent Increase"},"e23f":{"name":"Format Italic"},"e240":{"name":"Format Line Spacing"},"e241":{"name":"Format List Bulleted"},"e242":{"name":"Format List Numbered"},"e243":{"name":"Format Paint"},"e244":{"name":"Format Quote"},"e25e":{"name":"Format Shapes"},"e245":{"name":"Format Size"},"e246":{"name":"Format Strikethrough"},"e247":{"name":"Format Textdirection L To R"},"e248":{"name":"Format Textdirection R To L"},"e249":{"name":"Format Underlined"},"e0bf":{"name":"Forum"},"e154":{"name":"Forward"},"e056":{"name":"Forward 10"},"e057":{"name":"Forward 30"},"e058":{"name":"Forward 5"},"eb44":{"name":"Free Breakfast"},"e5d0":{"name":"Fullscreen"},"e5d1":{"name":"Fullscreen Exit"},"e24a":{"name":"Functions"},"e927":{"name":"G Translate"},"e30f":{"name":"Gamepad"},"e021":{"name":"Games"},"e90e":{"name":"Gavel"},"e155":{"name":"Gesture"},"e884":{"name":"Get App"},"e908":{"name":"Gif"},"eb45":{"name":"Golf Course"},"e1b3":{"name":"Gps Fixed"},"e1b4":{"name":"Gps Not Fixed"},"e1b5":{"name":"Gps Off"},"e885":{"name":"Grade"},"e3e9":{"name":"Gradient"},"e3ea":{"name":"Grain"},"e1b8":{"name":"Graphic Eq"},"e3eb":{"name":"Grid Off"},"e3ec":{"name":"Grid On"},"e7ef":{"name":"Group"},"e7f0":{"name":"Group Add"},"e886":{"name":"Group Work"},"e052":{"name":"Hd"},"e3ed":{"name":"Hdr Off"},"e3ee":{"name":"Hdr On"},"e3f1":{"name":"Hdr Strong"},"e3f2":{"name":"Hdr Weak"},"e310":{"name":"Headset"},"e311":{"name":"Headset Mic"},"e3f3":{"name":"Healing"},"e023":{"name":"Hearing"},"e887":{"name":"Help"},"e8fd":{"name":"Help Outline"},"e024":{"name":"High Quality"},"e25f":{"name":"Highlight"},"e888":{"name":"Highlight Off"},"e889":{"name":"History"},"e88a":{"name":"Home"},"eb46":{"name":"Hot Tub"},"e53a":{"name":"Hotel"},"e88b":{"name":"Hourglass Empty"},"e88c":{"name":"Hourglass Full"},"e902":{"name":"Http"},"e88d":{"name":"Https"},"e3f4":{"name":"Image"},"e3f5":{"name":"Image Aspect Ratio"},"e0e0":{"name":"Import Contacts"},"e0c3":{"name":"Import Export"},"e912":{"name":"Important Devices"},"e156":{"name":"Inbox"},"e909":{"name":"Indeterminate Check Box"},"e88e":{"name":"Info"},"e88f":{"name":"Info Outline"},"e890":{"name":"Input"},"e24b":{"name":"Insert Chart"},"e24c":{"name":"Insert Comment"},"e24d":{"name":"Insert Drive File"},"e24e":{"name":"Insert Emoticon"},"e24f":{"name":"Insert Invitation"},"e250":{"name":"Insert Link"},"e251":{"name":"Insert Photo"},"e891":{"name":"Invert Colors"},"e0c4":{"name":"Invert Colors Off"},"e3f6":{"name":"Iso"},"e312":{"name":"Keyboard"},"e313":{"name":"Keyboard Arrow Down"},"e314":{"name":"Keyboard Arrow Left"},"e315":{"name":"Keyboard Arrow Right"},"e316":{"name":"Keyboard Arrow Up"},"e317":{"name":"Keyboard Backspace"},"e318":{"name":"Keyboard Capslock"},"e31a":{"name":"Keyboard Hide"},"e31b":{"name":"Keyboard Return"},"e31c":{"name":"Keyboard Tab"},"e31d":{"name":"Keyboard Voice"},"eb47":{"name":"Kitchen"},"e892":{"name":"Label"},"e893":{"name":"Label Outline"},"e3f7":{"name":"Landscape"},"e894":{"name":"Language"},"e31e":{"name":"Laptop"},"e31f":{"name":"Laptop Chromebook"},"e320":{"name":"Laptop Mac"},"e321":{"name":"Laptop Windows"},"e5dd":{"name":"Last Page"},"e895":{"name":"Launch"},"e53b":{"name":"Layers"},"e53c":{"name":"Layers Clear"},"e3f8":{"name":"Leak Add"},"e3f9":{"name":"Leak Remove"},"e3fa":{"name":"Lens"},"e02e":{"name":"Library Add"},"e02f":{"name":"Library Books"},"e030":{"name":"Library Music"},"e90f":{"name":"Lightbulb Outline"},"e919":{"name":"Line Style"},"e91a":{"name":"Line Weight"},"e260":{"name":"Linear Scale"},"e157":{"name":"Link"},"e438":{"name":"Linked Camera"},"e896":{"name":"List"},"e0c6":{"name":"Live Help"},"e639":{"name":"Live Tv"},"e53f":{"name":"Local Activity"},"e53d":{"name":"Local Airport"},"e53e":{"name":"Local Atm"},"e540":{"name":"Local Bar"},"e541":{"name":"Local Cafe"},"e542":{"name":"Local Car Wash"},"e543":{"name":"Local Convenience Store"},"e556":{"name":"Local Dining"},"e544":{"name":"Local Drink"},"e545":{"name":"Local Florist"},"e546":{"name":"Local Gas Station"},"e547":{"name":"Local Grocery Store"},"e548":{"name":"Local Hospital"},"e549":{"name":"Local Hotel"},"e54a":{"name":"Local Laundry Service"},"e54b":{"name":"Local Library"},"e54c":{"name":"Local Mall"},"e54d":{"name":"Local Movies"},"e54e":{"name":"Local Offer"},"e54f":{"name":"Local Parking"},"e550":{"name":"Local Pharmacy"},"e551":{"name":"Local Phone"},"e552":{"name":"Local Pizza"},"e553":{"name":"Local Play"},"e554":{"name":"Local Post Office"},"e555":{"name":"Local Printshop"},"e557":{"name":"Local See"},"e558":{"name":"Local Shipping"},"e559":{"name":"Local Taxi"},"e7f1":{"name":"Location City"},"e1b6":{"name":"Location Disabled"},"e0c7":{"name":"Location Off"},"e0c8":{"name":"Location On"},"e1b7":{"name":"Location Searching"},"e897":{"name":"Lock"},"e898":{"name":"Lock Open"},"e899":{"name":"Lock Outline"},"e3fc":{"name":"Looks"},"e3fb":{"name":"Looks 3"},"e3fd":{"name":"Looks 4"},"e3fe":{"name":"Looks 5"},"e3ff":{"name":"Looks 6"},"e400":{"name":"Looks One"},"e401":{"name":"Looks Two"},"e028":{"name":"Loop"},"e402":{"name":"Loupe"},"e16d":{"name":"Low Priority"},"e89a":{"name":"Loyalty"},"e158":{"name":"Mail"},"e0e1":{"name":"Mail Outline"},"e55b":{"name":"Map"},"e159":{"name":"Markunread"},"e89b":{"name":"Markunread Mailbox"},"e322":{"name":"Memory"},"e5d2":{"name":"Menu"},"e252":{"name":"Merge Type"},"e0c9":{"name":"Message"},"e029":{"name":"Mic"},"e02a":{"name":"Mic None"},"e02b":{"name":"Mic Off"},"e618":{"name":"Mms"},"e253":{"name":"Mode Comment"},"e254":{"name":"Mode Edit"},"e263":{"name":"Monetization On"},"e25c":{"name":"Money Off"},"e403":{"name":"Monochrome Photos"},"e7f2":{"name":"Mood"},"e7f3":{"name":"Mood Bad"},"e619":{"name":"More"},"e5d3":{"name":"More Horiz"},"e5d4":{"name":"More Vert"},"e91b":{"name":"Motorcycle"},"e323":{"name":"Mouse"},"e168":{"name":"Move To Inbox"},"e02c":{"name":"Movie"},"e404":{"name":"Movie Creation"},"e43a":{"name":"Movie Filter"},"e6df":{"name":"Multiline Chart"},"e405":{"name":"Music Note"},"e063":{"name":"Music Video"},"e55c":{"name":"My Location"},"e406":{"name":"Nature"},"e407":{"name":"Nature People"},"e408":{"name":"Navigate Before"},"e409":{"name":"Navigate Next"},"e55d":{"name":"Navigation"},"e569":{"name":"Near Me"},"e1b9":{"name":"Network Cell"},"e640":{"name":"Network Check"},"e61a":{"name":"Network Locked"},"e1ba":{"name":"Network Wifi"},"e031":{"name":"New Releases"},"e16a":{"name":"Next Week"},"e1bb":{"name":"Nfc"},"e641":{"name":"No Encryption"},"e0cc":{"name":"No Sim"},"e033":{"name":"Not Interested"},"e06f":{"name":"Note"},"e89c":{"name":"Note Add"},"e7f4":{"name":"Notifications"},"e7f7":{"name":"Notifications Active"},"e7f5":{"name":"Notifications None"},"e7f6":{"name":"Notifications Off"},"e7f8":{"name":"Notifications Paused"},"e90a":{"name":"Offline Pin"},"e63a":{"name":"Ondemand Video"},"e91c":{"name":"Opacity"},"e89d":{"name":"Open In Browser"},"e89e":{"name":"Open In New"},"e89f":{"name":"Open With"},"e7f9":{"name":"Pages"},"e8a0":{"name":"Pageview"},"e40a":{"name":"Palette"},"e925":{"name":"Pan Tool"},"e40b":{"name":"Panorama"},"e40c":{"name":"Panorama Fish Eye"},"e40d":{"name":"Panorama Horizontal"},"e40e":{"name":"Panorama Vertical"},"e40f":{"name":"Panorama Wide Angle"},"e7fa":{"name":"Party Mode"},"e034":{"name":"Pause"},"e035":{"name":"Pause Circle Filled"},"e036":{"name":"Pause Circle Outline"},"e8a1":{"name":"Payment"},"e7fb":{"name":"People"},"e7fc":{"name":"People Outline"},"e8a2":{"name":"Perm Camera Mic"},"e8a3":{"name":"Perm Contact Calendar"},"e8a4":{"name":"Perm Data Setting"},"e8a5":{"name":"Perm Device Information"},"e8a6":{"name":"Perm Identity"},"e8a7":{"name":"Perm Media"},"e8a8":{"name":"Perm Phone Msg"},"e8a9":{"name":"Perm Scan Wifi"},"e7fd":{"name":"Person"},"e7fe":{"name":"Person Add"},"e7ff":{"name":"Person Outline"},"e55a":{"name":"Person Pin"},"e56a":{"name":"Person Pin Circle"},"e63b":{"name":"Personal Video"},"e91d":{"name":"Pets"},"e0cd":{"name":"Phone"},"e324":{"name":"Phone Android"},"e61b":{"name":"Phone Bluetooth Speaker"},"e61c":{"name":"Phone Forwarded"},"e61d":{"name":"Phone In Talk"},"e325":{"name":"Phone Iphone"},"e61e":{"name":"Phone Locked"},"e61f":{"name":"Phone Missed"},"e620":{"name":"Phone Paused"},"e326":{"name":"Phonelink"},"e0db":{"name":"Phonelink Erase"},"e0dc":{"name":"Phonelink Lock"},"e327":{"name":"Phonelink Off"},"e0dd":{"name":"Phonelink Ring"},"e0de":{"name":"Phonelink Setup"},"e410":{"name":"Photo"},"e411":{"name":"Photo Album"},"e412":{"name":"Photo Camera"},"e43b":{"name":"Photo Filter"},"e413":{"name":"Photo Library"},"e432":{"name":"Photo Size Select Actual"},"e433":{"name":"Photo Size Select Large"},"e434":{"name":"Photo Size Select Small"},"e415":{"name":"Picture As Pdf"},"e8aa":{"name":"Picture In Picture"},"e911":{"name":"Picture In Picture Alt"},"e6c4":{"name":"Pie Chart"},"e6c5":{"name":"Pie Chart Outlined"},"e55e":{"name":"Pin Drop"},"e55f":{"name":"Place"},"e037":{"name":"Play Arrow"},"e038":{"name":"Play Circle Filled"},"e039":{"name":"Play Circle Outline"},"e906":{"name":"Play For Work"},"e03b":{"name":"Playlist Add"},"e065":{"name":"Playlist Add Check"},"e05f":{"name":"Playlist Play"},"e800":{"name":"Plus One"},"e801":{"name":"Poll"},"e8ab":{"name":"Polymer"},"eb48":{"name":"Pool"},"e0ce":{"name":"Portable Wifi Off"},"e416":{"name":"Portrait"},"e63c":{"name":"Power"},"e336":{"name":"Power Input"},"e8ac":{"name":"Power Settings New"},"e91e":{"name":"Pregnant Woman"},"e0df":{"name":"Present To All"},"e8ad":{"name":"Print"},"e645":{"name":"Priority High"},"e80b":{"name":"Public"},"e255":{"name":"Publish"},"e8ae":{"name":"Query Builder"},"e8af":{"name":"Question Answer"},"e03c":{"name":"Queue"},"e03d":{"name":"Queue Music"},"e066":{"name":"Queue Play Next"},"e03e":{"name":"Radio"},"e837":{"name":"Radio Button Checked"},"e836":{"name":"Radio Button Unchecked"},"e560":{"name":"Rate Review"},"e8b0":{"name":"Receipt"},"e03f":{"name":"Recent Actors"},"e91f":{"name":"Record Voice Over"},"e8b1":{"name":"Redeem"},"e15a":{"name":"Redo"},"e5d5":{"name":"Refresh"},"e15b":{"name":"Remove"},"e15c":{"name":"Remove Circle"},"e15d":{"name":"Remove Circle Outline"},"e067":{"name":"Remove From Queue"},"e417":{"name":"Remove Red Eye"},"e928":{"name":"Remove Shopping Cart"},"e8fe":{"name":"Reorder"},"e040":{"name":"Repeat"},"e041":{"name":"Repeat One"},"e042":{"name":"Replay"},"e059":{"name":"Replay 10"},"e05a":{"name":"Replay 30"},"e05b":{"name":"Replay 5"},"e15e":{"name":"Reply"},"e15f":{"name":"Reply All"},"e160":{"name":"Report"},"e8b2":{"name":"Report Problem"},"e56c":{"name":"Restaurant"},"e561":{"name":"Restaurant Menu"},"e8b3":{"name":"Restore"},"e929":{"name":"Restore Page"},"e0d1":{"name":"Ring Volume"},"e8b4":{"name":"Room"},"eb49":{"name":"Room Service"},"e418":{"name":"Rotate 90 Degrees Ccw"},"e419":{"name":"Rotate Left"},"e41a":{"name":"Rotate Right"},"e920":{"name":"Rounded Corner"},"e328":{"name":"Router"},"e921":{"name":"Rowing"},"e0e5":{"name":"Rss Feed"},"e642":{"name":"Rv Hookup"},"e562":{"name":"Satellite"},"e161":{"name":"Save"},"e329":{"name":"Scanner"},"e8b5":{"name":"Schedule"},"e80c":{"name":"School"},"e1be":{"name":"Screen Lock Landscape"},"e1bf":{"name":"Screen Lock Portrait"},"e1c0":{"name":"Screen Lock Rotation"},"e1c1":{"name":"Screen Rotation"},"e0e2":{"name":"Screen Share"},"e623":{"name":"Sd Card"},"e1c2":{"name":"Sd Storage"},"e8b6":{"name":"Search"},"e32a":{"name":"Security"},"e162":{"name":"Select All"},"e163":{"name":"Send"},"e811":{"name":"Sentiment Dissatisfied"},"e812":{"name":"Sentiment Neutral"},"e813":{"name":"Sentiment Satisfied"},"e814":{"name":"Sentiment Very Dissatisfied"},"e815":{"name":"Sentiment Very Satisfied"},"e8b8":{"name":"Settings"},"e8b9":{"name":"Settings Applications"},"e8ba":{"name":"Settings Backup Restore"},"e8bb":{"name":"Settings Bluetooth"},"e8bd":{"name":"Settings Brightness"},"e8bc":{"name":"Settings Cell"},"e8be":{"name":"Settings Ethernet"},"e8bf":{"name":"Settings Input Antenna"},"e8c0":{"name":"Settings Input Component"},"e8c1":{"name":"Settings Input Composite"},"e8c2":{"name":"Settings Input Hdmi"},"e8c3":{"name":"Settings Input Svideo"},"e8c4":{"name":"Settings Overscan"},"e8c5":{"name":"Settings Phone"},"e8c6":{"name":"Settings Power"},"e8c7":{"name":"Settings Remote"},"e1c3":{"name":"Settings System Daydream"},"e8c8":{"name":"Settings Voice"},"e80d":{"name":"Share"},"e8c9":{"name":"Shop"},"e8ca":{"name":"Shop Two"},"e8cb":{"name":"Shopping Basket"},"e8cc":{"name":"Shopping Cart"},"e261":{"name":"Short Text"},"e6e1":{"name":"Show Chart"},"e043":{"name":"Shuffle"},"e1c8":{"name":"Signal Cellular 4 Bar"},"e1cd":{"name":"Signal Cellular Connected No Internet 4 Bar"},"e1ce":{"name":"Signal Cellular No Sim"},"e1cf":{"name":"Signal Cellular Null"},"e1d0":{"name":"Signal Cellular Off"},"e1d8":{"name":"Signal Wifi 4 Bar"},"e1d9":{"name":"Signal Wifi 4 Bar Lock"},"e1da":{"name":"Signal Wifi Off"},"e32b":{"name":"Sim Card"},"e624":{"name":"Sim Card Alert"},"e044":{"name":"Skip Next"},"e045":{"name":"Skip Previous"},"e41b":{"name":"Slideshow"},"e068":{"name":"Slow Motion Video"},"e32c":{"name":"Smartphone"},"eb4a":{"name":"Smoke Free"},"eb4b":{"name":"Smoking Rooms"},"e625":{"name":"Sms"},"e626":{"name":"Sms Failed"},"e046":{"name":"Snooze"},"e164":{"name":"Sort"},"e053":{"name":"Sort By Alpha"},"eb4c":{"name":"Spa"},"e256":{"name":"Space Bar"},"e32d":{"name":"Speaker"},"e32e":{"name":"Speaker Group"},"e8cd":{"name":"Speaker Notes"},"e92a":{"name":"Speaker Notes Off"},"e0d2":{"name":"Speaker Phone"},"e8ce":{"name":"Spellcheck"},"e838":{"name":"Star"},"e83a":{"name":"Star Border"},"e839":{"name":"Star Half"},"e8d0":{"name":"Stars"},"e0d3":{"name":"Stay Current Landscape"},"e0d4":{"name":"Stay Current Portrait"},"e0d5":{"name":"Stay Primary Landscape"},"e0d6":{"name":"Stay Primary Portrait"},"e047":{"name":"Stop"},"e0e3":{"name":"Stop Screen Share"},"e1db":{"name":"Storage"},"e8d1":{"name":"Store"},"e563":{"name":"Store Mall Directory"},"e41c":{"name":"Straighten"},"e56e":{"name":"Streetview"},"e257":{"name":"Strikethrough S"},"e41d":{"name":"Style"},"e5d9":{"name":"Subdirectory Arrow Left"},"e5da":{"name":"Subdirectory Arrow Right"},"e8d2":{"name":"Subject"},"e064":{"name":"Subscriptions"},"e048":{"name":"Subtitles"},"e56f":{"name":"Subway"},"e8d3":{"name":"Supervisor Account"},"e049":{"name":"Surround Sound"},"e0d7":{"name":"Swap Calls"},"e8d4":{"name":"Swap Horiz"},"e8d5":{"name":"Swap Vert"},"e8d6":{"name":"Swap Vertical Circle"},"e41e":{"name":"Switch Camera"},"e41f":{"name":"Switch Video"},"e627":{"name":"Sync"},"e628":{"name":"Sync Disabled"},"e629":{"name":"Sync Problem"},"e62a":{"name":"System Update"},"e8d7":{"name":"System Update Alt"},"e8d8":{"name":"Tab"},"e8d9":{"name":"Tab Unselected"},"e32f":{"name":"Tablet"},"e330":{"name":"Tablet Android"},"e331":{"name":"Tablet Mac"},"e420":{"name":"Tag Faces"},"e62b":{"name":"Tap And Play"},"e564":{"name":"Terrain"},"e262":{"name":"Text Fields"},"e165":{"name":"Text Format"},"e0d8":{"name":"Textsms"},"e421":{"name":"Texture"},"e8da":{"name":"Theaters"},"e8db":{"name":"Thumb Down"},"e8dc":{"name":"Thumb Up"},"e8dd":{"name":"Thumbs Up Down"},"e62c":{"name":"Time To Leave"},"e422":{"name":"Timelapse"},"e922":{"name":"Timeline"},"e425":{"name":"Timer"},"e423":{"name":"Timer 10"},"e424":{"name":"Timer 3"},"e426":{"name":"Timer Off"},"e264":{"name":"Title"},"e8de":{"name":"Toc"},"e8df":{"name":"Today"},"e8e0":{"name":"Toll"},"e427":{"name":"Tonality"},"e913":{"name":"Touch App"},"e332":{"name":"Toys"},"e8e1":{"name":"Track Changes"},"e565":{"name":"Traffic"},"e570":{"name":"Train"},"e571":{"name":"Tram"},"e572":{"name":"Transfer Within A Station"},"e428":{"name":"Transform"},"e8e2":{"name":"Translate"},"e8e3":{"name":"Trending Down"},"e8e4":{"name":"Trending Flat"},"e8e5":{"name":"Trending Up"},"e429":{"name":"Tune"},"e8e6":{"name":"Turned In"},"e8e7":{"name":"Turned In Not"},"e333":{"name":"Tv"},"e169":{"name":"Unarchive"},"e166":{"name":"Undo"},"e5d6":{"name":"Unfold Less"},"e5d7":{"name":"Unfold More"},"e923":{"name":"Update"},"e1e0":{"name":"Usb"},"e8e8":{"name":"Verified User"},"e258":{"name":"Vertical Align Bottom"},"e259":{"name":"Vertical Align Center"},"e25a":{"name":"Vertical Align Top"},"e62d":{"name":"Vibration"},"e070":{"name":"Video Call"},"e071":{"name":"Video Label"},"e04a":{"name":"Video Library"},"e04b":{"name":"Videocam"},"e04c":{"name":"Videocam Off"},"e338":{"name":"Videogame Asset"},"e8e9":{"name":"View Agenda"},"e8ea":{"name":"View Array"},"e8eb":{"name":"View Carousel"},"e8ec":{"name":"View Column"},"e42a":{"name":"View Comfy"},"e42b":{"name":"View Compact"},"e8ed":{"name":"View Day"},"e8ee":{"name":"View Headline"},"e8ef":{"name":"View List"},"e8f0":{"name":"View Module"},"e8f1":{"name":"View Quilt"},"e8f2":{"name":"View Stream"},"e8f3":{"name":"View Week"},"e435":{"name":"Vignette"},"e8f4":{"name":"Visibility"},"e8f5":{"name":"Visibility Off"},"e62e":{"name":"Voice Chat"},"e0d9":{"name":"Voicemail"},"e04d":{"name":"Volume Down"},"e04e":{"name":"Volume Mute"},"e04f":{"name":"Volume Off"},"e050":{"name":"Volume Up"},"e0da":{"name":"Vpn Key"},"e62f":{"name":"Vpn Lock"},"e1bc":{"name":"Wallpaper"},"e002":{"name":"Warning"},"e334":{"name":"Watch"},"e924":{"name":"Watch Later"},"e42c":{"name":"Wb Auto"},"e42d":{"name":"Wb Cloudy"},"e42e":{"name":"Wb Incandescent"},"e436":{"name":"Wb Iridescent"},"e430":{"name":"Wb Sunny"},"e63d":{"name":"Wc"},"e051":{"name":"Web"},"e069":{"name":"Web Asset"},"e16b":{"name":"Weekend"},"e80e":{"name":"Whatshot"},"e1bd":{"name":"Widgets"},"e63e":{"name":"Wifi"},"e1e1":{"name":"Wifi Lock"},"e1e2":{"name":"Wifi Tethering"},"e8f9":{"name":"Work"},"e25b":{"name":"Wrap Text"},"e8fa":{"name":"Youtube Searched For"},"e8ff":{"name":"Zoom In"},"e900":{"name":"Zoom Out"},"e56b":{"name":"Zoom Out Map"}}};

function fixupMap(m)
{
    m.nameToCode = {};
    m.knownCodes = [];
    for(let code in m.icons)
    {
       m.nameToCode[m.icons[code].name] = code;
       m.knownCodes.push(Number("0x"+code));
    }
    return m;
}

var FontIJMap =
{
    "Material Icons": fixupMap(materialIconsIJMap)
};
// =====================================================================================================================
// fontijmap.js END
// =====================================================================================================================
// =====================================================================================================================
// logging.js BEGIN
// =====================================================================================================================


var ImguiLoggingMixin =
{
    // - All text output from the interface can be captured into
    //   tty/file/clipboard. By default, tree nodes are automatically
    //   opened during logging.

    // start logging to tty (stdout)
    LogToTTY(auto_open_depth)
    {
    },

    // start logging to file
    LogToFile(auto_open_dept =-1, filename=null)
    {},

    // start logging to OS clipboard
    LogToClipboard(auto_open_depth = -1)
    {},

    // stop logging (close file, etc.)
    LogFinish()
    {},

    // helper to display buttons for logging to tty/file/clipboard
    LogButtons()
    {},

    // pass text data straight to log (without being displayed)
    LogText(str)
    {},
};
// =====================================================================================================================
// logging.js END
// =====================================================================================================================
// =====================================================================================================================
// enums.js BEGIN
// =====================================================================================================================



var LayoutType = // enum
{
    Horizontal: 0,
    Vertical: 1
};

var MouseCursor = // enum
{
    None: -1,
    Arrow: 0,
    TextInput: 1,         // When hovering over InputText, etc.
    ResizeAll: 2,         // (Unused by imgui functions)
    ResizeNS: 3,          // When hovering over an horizontal border
    ResizeEW: 4,          // When hovering over a vertical border or a column
    ResizeNESW: 5,        // When hovering over the bottom-left corner of a window
    ResizeNWSE: 6,        // When hovering over the bottom-right corner of a window
    Hand: 7,              // (Unused by imgui functions. Use for e.g. hyperlinks)
    COUNT: 8
};

var Key = // enum
{
    Tab:0,
    LeftArrow:1,
    RightArrow:2,
    UpArrow:3,
    DownArrow:4,
    PageUp:5,
    PageDown:6,
    Home:7,
    End:8,
    Insert:9,
    Delete:10,
    Backspace:11,
    Space:12,
    Enter:13,
    Escape:14,
    A:15,         // for text edit CTRL+A: select all
    C:16,         // for text edit CTRL+C: copy
    V:17,         // for text edit CTRL+V: paste
    X:18,         // for text edit CTRL+X: cut
    Y:19,         // for text edit CTRL+Y: redo
    Z:20,         // for text edit CTRL+Z: undo
    COUNT:21
};

var Dir = // enum
{
    None:-1,
    Left:0,
    Right:1,
    Up:2,
    Down:3,
    COUNT:4
};

var InputSource = // enum
{
    None:0,
    Mouse:1,
    Nav:2,
    NavKeyboard:3,
    NavGampad:4,
    COUNT:5
};

// FIXME-NAV: Clarify/expose various repeat delay/rate
var InputReadMode =
{
    Down:0,
    Pressed:1,
    Released:2,
    Repeat:3,
    RepeatSlow:4,
    RepeatFast:5
};

// Gamepad/Keyboard directional navigation
// Keyboard: Set io.ConfigFlags |= ConfigFlags_NavEnableKeyboard to enable.
//  NewFrame() will automatically fill io.NavInputs[] based on your
//  io.KeysDown[] + io.KeyMap[] arrays.
// Gamepad:  Set io.ConfigFlags |= ConfigFlags_NavEnableGamepad to enable.
//  Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[]
//  fields before calling NewFrame(). Note that io.NavInputs[] is cleared by
//  EndFrame().
// Read instructions in imgui.cpp for more details. Download PNG/PSD
// at http://goo.gl/9LgVZW.
let i=0;
var NavInput =
{
    // Gamepad Mapping
    Activate:i++,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)
    Cancel:i++,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)
    Input:i++,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)
    Menu:i++,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)
    DpadLeft:i++,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)
    DpadRight:i++,     //
    DpadUp:i++,        //
    DpadDown:i++,      //
    LStickLeft:i++,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down
    LStickRight:i++,   //
    LStickUp:i++,      //
    LStickDown:i++,    //
    FocusPrev:i++,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    FocusNext:i++,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
    TweakSlow:i++,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    TweakFast:i++,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)

    // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.
    // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeysDown[] instead of io.NavInputs[].
    KeyMenu_:i++,      // toggle menu                                  // = io.KeyAlt
    KeyTab_:i++,       // tab                                          // = Tab key
    KeyLeft_:i++,      // move left                                    // = Arrow keys
    KeyRight_:i++,     // move right
    KeyUp_:i++,        // move up
    KeyDown_:i++,      // move down
    COUNT:i,
};
NavInput.InternalStart_ = NavInput.KeyMenu_;

var NavLayer = // enum
{
    Main:0,
    Menu:1,
    COUNT:2
};

var NavForward = // enum
{
    None:0,
    ForwardQueued:1,
    ForwardActive:2
};

var LogType = // enum
{
    None: 0,
    TTY: 1,
    File: 2,
    Buffer: 3,
    Clipboard: 4
};

var Axis = // enum
{
    None: -1,
    X: 0,
    Y: 1
};

// =====================================================================================================================
// enums.js END
// =====================================================================================================================
// =====================================================================================================================
// window.js BEGIN
// =====================================================================================================================



var WindowFlags =
{
    None: 0,
    NoTitleBar: 1 << 0,   // Disable title-bar
    NoResize: 1 << 1,   // Disable user resizing with the lower-right grip
    NoMove: 1 << 2,   // Disable user moving the window
    NoScrollbar: 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programmatically)
    NoScrollWithMouse: 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
    NoCollapse: 1 << 5,   // Disable user collapsing window by double-clicking on it
    AlwaysAutoResize: 1 << 6,   // Resize every window to its content every frame
    NoBackground: 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
    NoSavedSettings: 1 << 8,   // Never load/save settings in .ini file
    NoMouseInputs: 1 << 9,   // Disable catching mouse, hovering test with pass through.
    MenuBar: 1 << 10,  // Has a menu-bar
    HorizontalScrollbar: 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
    NoFocusOnAppearing: 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
    NoBringToFrontOnFocus: 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
    AlwaysVerticalScrollbar: 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
    AlwaysHorizontalScrollbar: 1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
    AlwaysUseWindowPadding: 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
    NoNavInputs: 1 << 18,  // No gamepad/keyboard navigation within the window
    NoNavFocus: 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
    UnsavedDocument: 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.
    LockScrollingContentSize: 1 << 21, // disallow content-size adjustment while scrolling

    // [Internal]
    NavFlattened: 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
    ChildWindow: 1 << 24,  // Don't use! For internal use by BeginChild()
    Tooltip: 1 << 25,  // Don't use! For internal use by BeginTooltip()
    Popup: 1 << 26,  // Don't use! For internal use by BeginPopup()
    Modal: 1 << 27,  // Don't use! For internal use by BeginPopupModal()
    ChildMenu: 1 << 28   // Don't use! For internal use by BeginMenu()
};

// composite window flags
f = WindowFlags;
f.NoNav = f.NoNavInputs | f.NoNavFocus;
f.NoDecoration = f.NoTitleBar | f.NoResize | f.NoScrollbar | f.NoCollapse;
f.NoInputs = f.NoMouseInputs | f.NoNavInputs | f.NoNavFocus;

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true
// and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by back-end)

// Extend outside and inside windows. Affect FindHoveredWindow().
const WindowResizeFromEdge = 4; // was WindowResizeFromEdge
// Reduce visual noise by only highlighting the border after a certain time.
const WindowResizeFromEdgeTimer = .04; // was WindowResizeFromEdgeTimer

class ResizeGripDef
{
    constructor(corner, innerDir, min12, max12)
    {
        this.CornerPosN = corner;
        this.InnerDir = innerDir;
        this.AngleMin12 = min12;
        this.AngleMax12 = max12;
    }
}

const ResizeGripDefs =
[
    new ResizeGripDef( // Lower right
        new Vec2(1,1), new Vec2(-1,-1), 0, 3,
    ),
    new ResizeGripDef( // Lower left
        new Vec2(0,1), new Vec2(+1,-1), 3, 6,
    ),
    new ResizeGripDef( // Upper left
        new Vec2(0,0), new Vec2(+1,+1), 6, 9,
    ),
    new ResizeGripDef( // Upper right
        new Vec2(1,0), new Vec2(-1,+1), 9,12,
    )
];

class ResizeBorderDef
{
    constructor(innerDir, n1, n2, ang)
    {
        this.InnerDir = innerDir;   // Vec2
        this.CornerPosN1 = n1;      // Vec2
        this.CornerPosN2 = n2;      // Vec2
        this.OuterAngle = ang;
    }
}

const s_resizeBorderDefs = [
    // Top
    new ResizeBorderDef(new Vec2(0,+1), new Vec2(0,0), new Vec2(1,0), Math.PI*1.5),
    // Right
    new ResizeBorderDef(new Vec2(-1,0), new Vec2(1,0), new Vec2(1,1), 0 ),
    // Bottom
    new ResizeBorderDef(new Vec2(0,-1), new Vec2(1,1), new Vec2(0,1), Math.PI*0.5),
    // Left
    new ResizeBorderDef(new Vec2(+1,0), new Vec2(0,1), new Vec2(0,0), Math.PI),
];

/*----------------------------------------------------------------------------*/
class Window
{
    constructor(name, imgui)
    {
        this.imgui = imgui;
        this.Name = name;
        this.ID = GetHash(name, 0);
        this.IDStack = new ArrayEx(this.ID); // must precede GetID calls
        this.Flags = WindowFlags.None;
        this.Pos = new Vec2(0., 0.);
        this.Size = new Vec2(0, 0);
        this.SizeFull = new Vec2(0, 0);
        this.SizeFullAtLastBegin = new Vec2(0, 0);
        this.SizeContents = new Vec2(0, 0);
        this.SizeContentsExplicit = new Vec2(0,0);
        this.WindowPadding = new Vec2(0,0);
        this.WindowRounding = 0;
        this.WindowBorderSize = 0.;
        this.NameBufLen = name.length + 1; // vestigial
        this.MoveId = this.GetID("#MOVE");
        this.ChildId = 0;
        this.Scroll = new Vec2(0, 0);
        this.ScrollTarget = Vec2.MAX_VALUE();
        this.ScrollTargetCenterRatio = new Vec2(0.5, 0.5);
        this.ScrollbarSizes = new Vec2(0., 0.);
        this.ScrollbarX = false;
        this.ScrollbarY = false;
        this.Active = false;
        this.WasActive = false;
        this.WriteAccessed = false;
        this.Collapsed = false;
        this.WantCollapseToggle = false;
        this.SkipItems = false;
        this.Appearing = false;
        this.Hidden = false;
        this.HasCloseButton = false; // controlled by optional p_open, in winmgr
        this.ResizeBorderHeld = -1;
        this.BeginCount = 0;
        this.BeginOrderWithinParent = -1;
        this.BeginOrderWithinContext = -1;
        this.PopupId = 0;
        this.AutoFitFramesX = -1;
        this.AutoFitFramesY = -1;
        this.AutoFitOnlyGrows = false;
        this.AutoFitChildAxises = 0x00;
        this.AutoPosLastDirection = Dir.None;
        this.HiddenFramesCanSkipItems = 0;
        this.HiddenFramesCannotSkipItems = 0;
        this.SetWindowPosAllowFlags =
        this.SetWindowSizeAllowFlags =
        this.SetWindowCollapsedAllowFlags = CondFlags.Always | CondFlags.Once |
                                CondFlags.FirstUseEver | CondFlags.Appearing;
        this.SetWindowPosVal = Vec2.MAX_VALUE();
        this.SetWindowPosPivot = Vec2.MAX_VALUE();

        this.DC = new WindowTempData();
        // IDStack initialized above
        this.ClipRect = new Rect();
        this.OuterRectClipped = new Rect();
        this.InnerMainRect = new Rect();
        this.InnerClipRect = new Rect();
        this.ContentsRegionRect = new Rect();
        this.LastFrameActive = -1;
        this.ItemWidthDefault = 0.;
        this.MenuColumns = new MenuColumns();
        this.StateStorage = new Storage();
        this.ColumnsStorage =  new ArrayEx();
        this.FontWindowScale = 1.;
        this.SettingsIdx = -1;

        this.DrawList = new DrawList(imgui, this.Name);
        // no DrawListInst
        this.ParentWindow = null;
        this.RootWindow = null;
        this.RootWindowForTitleBarHighlight = null;
        this.RootWindowForNav = null;

        this.NavLastChildNavWindow = null;
        this.NavLastIds = new ArrayEx();
        this.NavLastIds[0] = this.NavLastIds[1] = 0;
        this.NavRectRel = new ArrayEx();
        this.NavRectRel[0] = new Rect();
        this.NavRectRel[1] = new Rect();

        this.ZIndex = 0;
    }

    destructor() // not called, here for ref
    {
        for (let i = 0; i != this.ColumnsStorage.length; i++)
            this.ColumnsStorage[i] = null;
        this.ColumnsStorage.resize(0);
    }

    PushID(id)
    {
        this.IDStack.push(this.GetIDNoKeepAlive(id));
    }

    PopID()
    {
        this.IDStack.pop();
    }

    GetID(str)
    {
        const seed = this.IDStack.back();
        const id = GetHash(str, seed);
        this.imgui.keepAliveID(id);
        return id;
    }

    GetIDNoKeepAlive(str)
    {
        const seed = this.IDStack.back();
        return GetHash(str, seed);
    }

    GetIDFromRectangle(r_abs)
    {
        const seed = this.IDStack.back();
        const r_rel = [ Math.floor(r_abs.Min.x - this.Pos.x),
                        Math.floor(r_abs.Min.y - this.Pos.y),
                        Math.floor(r_abs.Max.x - this.Pos.x),
                        Math.floor(r_abs.Max.y - this.Pos.y) ];
        const id = HashData(r_rel, seed);
        this.imgui.keepAliveID(id);
        return id;
    }

    IsActiveAndVisible()
    {
        return this.Active && !this.Hidden;
    }

    // We don't use g.FontSize because the window may be != g.CurrentWidow.
    Rect()
    {
        return Rect.FromXY(this.Pos.x, this.Pos.y,
            this.Pos.x+this.Size.x, this.Pos.y+this.Size.y);
    }

    MakeCurrent()
    {
        // Establish our font as the current font, no stacking here,
        // since each window is made current before drawing,
        // so we must call SetFont in all cases.
        if(this.Font)
            this.imgui.SetFont(this.Font);
        else
            this.imgui.SetFont(this.imgui.GetFont(null, this.FontWindowScale));
    }

    Render(layer) // layer undefined: draw layers 0, 1
    {
        this.DrawList.Render(layer);
    }

    CalcLineHeight()
    {
        return this.imgui.GetLineHeight() * this.FontWindowScale;
    }

    TitleBarHeight()
    {
        if(this.Flags & WindowFlags.NoTitleBar)
            return 0;
        else
            return this.CalcLineHeight() + this.imgui.guictx.Style.FramePadding.y * 2;
    }

    TitleBarRect()
    {
        return Rect.FromXY(this.Pos.x, this.Pos.y,
                    this.Pos.x + this.SizeFull.x,
                    this.Pos.y + this.TitleBarHeight());
    }

    MenuBarHeight()
    {
        if(this.Flags & WindowFlags.MenuBar)
        {
            return this.DC.MenuBarOffset.y + this.CalcLineHeight() +
                    this.imgui.guictx.Style.FramePadding.y * 2;
        }
        else
            return 0;
    }

    MenuBarRect()
    {
        let y1 = this.Pos.y + this.TitleBarHeight();
        let y2 = y1+this.MenuBarHeight();
        return Rect.FromXY(this.Pos.x, y1, this.Pos.x+this.SizeFull.x, y2);
    }

    UpdateWindowParentAndRootLinks(flags, parent)
    {
        this.ParentWindow = parent;
        this.RootWindow = this.RootWindowForTitleBarHighlight = this.RootWindowForNav = this;
        if (parent && (flags & WindowFlags.ChildWindow) && !(flags & WindowFlags.Tooltip))
            this.RootWindow = parent.RootWindow;
        if (parent && !(flags & WindowFlags.Modal) &&
           (flags & (WindowFlags.ChildWindow | WindowFlags.Popup)))
        {
            this.RootWindowForTitleBarHighlight = parent.RootWindowForTitleBarHighlight;
        }
        while (this.RootWindowForNav.Flags & WindowFlags.NavFlattened)
        {
            console.assert(this.RootWindowForNav.ParentWindow);
            this.RootWindowForNav = this.RootWindowForNav.ParentWindow;
        }
    }

    getResizeBorderRect(border_n, perp_padding, thickness)
    {
        let rect = this.Rect();
        if (thickness == 0) rect.Max.SubtractXY(1,1);
        if (border_n == 0) // Top
            return new Rect(rect.Min.x + perp_padding, rect.Min.y - thickness,
                        rect.Max.x - perp_padding, rect.Min.y + thickness);
        if (border_n == 1) // Right
            return new Rect(rect.Max.x - thickness, rect.Min.y + perp_padding,
                            rect.Max.x + thickness, rect.Max.y - perp_padding);
        if (border_n == 2) // Bottom
            return new Rect(rect.Min.x + perp_padding, rect.Max.y - thickness,
                            rect.Max.x - perp_padding, rect.Max.y + thickness);
        if (border_n == 3) // Left
            return new Rect(rect.Min.x - thickness, rect.Min.y + perp_padding,
                            rect.Min.x + thickness, rect.Max.y - perp_padding);
        console.assert(0);
        return new Rect();
    }

    SetWindowPos(pos, cond)
    {
        if (cond && (this.SetWindowPosAllowFlags & cond) == 0)
            return;

        this.SetWindowPosAllowFlags &= ~(CondFlags.Once|CondFlags.FirstUseEver|CondFlags.Appearing);
        this.SetWindowPosVal = new Vec2(Number.MAX_VALUE, Number.MAX_VALUE);

        // Set
        let old_pos = this.Pos;
        this.Pos = Vec2.Floor(pos);
        // As we happen to move the window while it is being appended to
        // (which is a bad idea - will smear) let's at least offset the cursor
        this.DC.CursorPos.Add(Vec2.Subtract(this.Pos, old_pos));
        // And more importantly we need to adjust this so size calculation
        // doesn't get affected.
        this.DC.CursorMaxPos.Add(Vec2.Subtract(this.Pos, old_pos));
    }

    SetWindowSize(size, cond)
    {
        // Test condition (NB: bit 0 is always true) and clear flags for next time
        if (cond && (this.SetWindowSizeAllowFlags & cond) == 0)
            return;

        this.SetWindowSizeAllowFlags &=
            ~(CondFlags.Once | CondFlags.FirstUseEver | CondFlags.Appearing);

        // Set
        if (size.x > 0.)
        {
            this.AutoFitFramesX = 0;
            this.SizeFull.x = Math.floor(size.x);
        }
        else
        {
            this.AutoFitFramesX = 2;
            this.AutoFitOnlyGrows = false;
        }
        if (size.y > 0.)
        {
            this.AutoFitFramesY = 0;
            this.SizeFull.y = Math.floor(size.y);
        }
        else
        {
            this.AutoFitFramesY = 2;
            this.AutoFitOnlyGrows = false;
        }
    }

    SetWindowCollapsed(collapsed, cond)
    {
        // Test condition (NB: bit 0 is always true) and clear flags for next time
        if (cond && (this.SetWindowCollapsedAllowFlags & cond) == 0)
            return;
        this.SetWindowCollapsedAllowFlags &=
            ~(CondFlags.Once | CondFlags.FirstUseEver |CondFlags.Appearing);
        // Set
        this.Collapsed = collapsed;
    }

    SetScrollX(x)
    {
        this.ScrollTarget.x = x;
        this.ScrollTargetCenterRatio.x = 0;
    }

    SetScrollY(y)
    {
        // title bar height canceled out when using ScrollTargetRelY
        this.ScrollTarget.y = y + this.TitleBarHeight() + this.MenuBarHeight();
        this.ScrollTargetCenterRatio.y = 0;
    }

    SetWindowScrollX(x)
    {
        // SizeContents is generally computed based on CursorMaxPos which is
        // affected by scroll position, so we need to apply our change to it.
        this.DC.CursorMaxPos.x += this.Scroll.x;
        this.Scroll.x = x;
        this.DC.CursorMaxPos.x -= this.Scroll.x;
    }

    SetWindowScrollY(y)
    {
        // SizeContents is generally computed based on CursorMaxPos which is
        // affected by scroll position, so we need to apply our change to it.
        this.DC.CursorMaxPos.y += this.Scroll.y;
        this.Scroll.y = y;
        this.DC.CursorMaxPos.y -= this.Scroll.y;
    }

    GetScrollMaxX()
    {
        return Math.max(0, this.SizeContents.x - (this.SizeFull.x - this.ScrollbarSizes.x));
    }

    GetScrollMaxY()
    {
        return Math.max(0, this.SizeContents.y - (this.SizeFull.y - this.ScrollbarSizes.y));
    }

    CalcSizeContents()
    {
        if (this.Collapsed)
        {
            if (this.AutoFitFramesX <= 0 && this.AutoFitFramesY <= 0)
                return this.SizeContents;
        }
        if (this.Hidden && this.HiddenFramesCannotSkipItems == 0
            && this.HiddenFramesCanSkipItems > 0)
        {
            return this.SizeContents;
        }
        let sz = new Vec2();
        sz.x = Math.floor((this.SizeContentsExplicit.x != 0) ?
                         this.SizeContentsExplicit.x :
                         (this.DC.CursorMaxPos.x - this.Pos.x + this.Scroll.x));
        sz.y = Math.floor((this.SizeContentsExplicit.y != 0) ?
                         this.SizeContentsExplicit.y :
                         (this.DC.CursorMaxPos.y - this.Pos.y + this.Scroll.y));
        if(sz.y == 0)
        {
            // happens on first create
            // console.log("nothing here: " + this.Name);
        }
        return Vec2.Add(sz, this.WindowPadding);
    }

    CalcSizeAutoFit(size_contents)
    {
        let g = this.imgui.guictx;
        let style = g.Style;
        if (this.Flags & WindowFlags.Tooltip)
        {
            // Tooltip always resize
            return size_contents;
        }
        else
        {
            // Maximum window size is determined by the display size
            const is_popup = (this.Flags & WindowFlags.Popup) != 0;
            const is_menu = (this.Flags & WindowFlags.ChildMenu) != 0;
            let size_min = style.WindowMinSize;
            // Popups and menus bypass style.WindowMinSize by default, but
            // we give then a non-zero minimum size to facilitate understanding
            // problematic cases (e.g. empty popups)
            if (is_popup || is_menu)
                size_min = Vec2.Min(size_min, new Vec2(4., 4.));
            let size_max = Vec2.Max(size_min,
                                    Vec2.Subtract(g.IO.DisplaySize,
                                    Vec2.Mult(style.DisplaySafeAreaPadding, 2)));
            let size_auto_fit = Vec2.Clamp(size_contents, size_min, size_max);

            // When the window cannot fit all contents (either because of
            // constraints, either because screen is too small), we are growing
            // the size on the other axis to compensate for expected scrollbar.
            // FIXME: Might turn bigger than ViewportSize-WindowPadding.
            let sz3 = this.CalcSizeAfterConstraint(size_auto_fit);
            if (sz3.x < size_contents.x &&
                !(this.Flags & WindowFlags.NoScrollbar) &&
                (this.Flags & WindowFlags.HorizontalScrollbar))
            {
                size_auto_fit.y += style.ScrollbarSize;
            }
            if (sz3.y < size_contents.y &&
               !(this.Flags & WindowFlags.NoScrollbar))
            {
                size_auto_fit.x += style.ScrollbarSize;
            }
            return size_auto_fit;
        }
    }

    CalcSizeAfterConstraint(new_size)
    {
        let g = this.imgui.guictx;
        if (g.NextWindowData.SizeConstraintCond != 0)
        {
            // Using -1,-1 on either X/Y axis to preserve the current size.
            let cr = g.NextWindowData.SizeConstraintRect;
            new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ?
                Vec1.Clamp(new_size.x, cr.Min.x, cr.Max.x) :
                this.SizeFull.x;
            new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ?
                Vec1.Clamp(new_size.y, cr.Min.y, cr.Max.y) :
                this.SizeFull.y;
            if (g.NextWindowData.SizeCallback)
            {
                let data = {};
                data.UserData = g.NextWindowData.SizeCallbackUserData;
                data.Pos = this.Pos;
                data.CurrentSize = this.SizeFull.Clone();
                data.DesiredSize = new_size.Clone();
                g.NextWindowData.SizeCallback(data);
                new_size = data.DesiredSize;
            }
        }

        // Minimum size
        if (!(this.Flags & (WindowFlags.ChildWindow | WindowFlags.AlwaysAutoResize)))
        {
            new_size = Vec2.Max(new_size, g.Style.WindowMinSize);
            // Reduce artifacts with very small windows
            new_size.y = Math.max(new_size.y,
                    this.TitleBarHeight() + this.MenuBarHeight() +
                    Math.max(0., g.Style.WindowRounding - 1.));
        }
        return new_size;
    }

    getBgColor(flag, alpha)
    {
        let key;
        if (flag & (WindowFlags.Tooltip | WindowFlags.Popup))
            key = "PopupBg";
        else
        if (flag & WindowFlags.ChildWindow)
            key = "ChildBg";
        else
            key = "WindowBg";
        return this.imgui.GetStyleColor(key, alpha);
    }

    CalcNextScrollFromScrollTargetAndClamp(snap_on_edges)
    {
        let scroll = this.Scroll;
        let g = this.imgui.guictx;
        if (this.ScrollTarget.x < Number.MAX_VALUE)
        {
            let cr_x = this.ScrollTargetCenterRatio.x;
            scroll.x = this.ScrollTarget.x -
                        cr_x * (this.SizeFull.x - this.ScrollbarSizes.x);
        }
        if (this.ScrollTarget.y < Number.MAX_VALUE)
        {
            // 'snap_on_edges' allows for a discontinuity at the edge of
            // scrolling limits to take account of WindowPadding so that
            // scrolling to make the last item visible scroll far enough to
            // see the padding.
            let cr_y = this.ScrollTargetCenterRatio.y;
            let target_y = this.ScrollTarget.y;
            if (snap_on_edges && cr_y <= 0 && target_y <= this.WindowPadding.y)
                target_y = 0;
            if (snap_on_edges && cr_y >= 1 &&
                target_y >= this.SizeContents.y - this.WindowPadding.y + g.Style.ItemSpacing.y)
            {
                target_y = this.SizeContents.y;
            }
            scroll.y = target_y - (1-cr_y) *
                (this.TitleBarHeight() + this.MenuBarHeight()) -
                cr_y * (this.SizeFull.y - this.ScrollbarSizes.y);
        }
        scroll = Vec2.Max(scroll, Vec2.Zero());
        if (!this.Collapsed && !this.SkipItems)
        {
            scroll.x = Math.min(scroll.x, this.GetScrollMaxX());
            scroll.y = Math.min(scroll.y, this.GetScrollMaxY());
        }
        this.Scroll = scroll;
        this.ScrollTarget = new Vec2(Number.MAX_VALUE, Number.MAX_VALUE);
    }

    ClampWindowRect(rect, padding)
    {
        let g = this.imgui.guictx;
        let sz;
        if(g.IO.ConfigWindowsMoveFromTitleBarOnly &&
            !(this.Flags & WindowFlags.NoTitleBar))
        {
            sz = new Vec2(this.Size.x, this.TitleBarHeight());
        }
        else
            sz = this.Size;

        this.Pos = Vec2.Min(
                    Vec2.Subtract(rect.Max, padding),
                    Vec2.Subtract(Vec2.Max(Vec2.Add(this.Pos, sz),
                                           Vec2.Add(rect.Min, padding)),
                                  sz)
                             );
    }

    calcResizePosSizeFromAnyCorner(corner_target, corner_norm, out_pos, out_size)
    {
        // Expected window upper-left
        let pos_min = Vec2.Lerp(corner_target, this.Pos, corner_norm);
        // Expected window lower-right
        let pos_max = Vec2.Lerp(Vec2.Add(this.Pos, this.Size), corner_target, corner_norm);
        let size_expected = Vec2.Subtract(pos_max, pos_min);
        let size_constrained = this.CalcSizeAfterConstraint(size_expected);
        out_pos.Copy(pos_min);
        if (corner_norm.x == 0)
            out_pos.x -= (size_constrained.x - size_expected.x);
        if (corner_norm.y == 0)
            out_pos.y -= (size_constrained.y - size_expected.y);
        out_size.Copy(size_constrained);
    }

    UpdateManualResize(autofit, borderheld, resize_grip_count, resize_grip_col)
    {
        let imgui = this.imgui;
        let g = this.imgui.guictx;
        let flags = this.Flags;
        if ((flags & WindowFlags.NoResize) || (flags & WindowFlags.AlwaysAutoResize) ||
            this.AutoFitFramesX > 0 || this.AutoFitFramesY > 0)
        {
            return;
        }
        // Early out to avoid running this code for e.g. an hidden
        // implicit/fallback Debug window.
        if (this.WasActive == false)
            return;

        const resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
        const grip_draw_size = Math.floor(Math.max(g.FontSize * 1.35,
                                this.WindowRounding + 1 + g.FontSize * 0.2));
        const grip_hover_innersize = Math.floor(grip_draw_size * 0.75);
        const grip_hover_outersize = g.IO.ConfigWindowsResizeFromEdges ?
                        WindowResizeFromEdge : 0.;
        let hovered = new ValRef();
        let held = new ValRef();

        let pos_target = Vec2.MAX_VALUE().Clone();
        let size_target = Vec2.MAX_VALUE().Clone();

        // Manual resize grips
        this.PushID("#RESIZE");
        for (let resize_grip_n=0; resize_grip_n<resize_grip_count; resize_grip_n++)
        {
            const grip = ResizeGripDefs[resize_grip_n];
            const corner = Vec2.Lerp(this.Pos, Vec2.Add(this.Pos, this.Size),
                                      grip.CornerPosN);
            // Using the FlattenChilds button flag we make the resize button
            // accessible even if we are hovering over a child window
            let resize_rect = new Rect(Vec2.Subtract(corner,
                                        Vec2.Mult(grip.InnerDir, grip_hover_outersize)),
                                   Vec2.Add(corner,
                                        Vec2.Mult(grip.InnerDir, grip_hover_innersize)));
            if (resize_rect.Min.x > resize_rect.Max.x)
            {
                // swap
                let tmp = resize_rect.Min.x;
                resize_rect.Min.x = resize_rect.Max.x;
                resize_rect.Max.x = tmp;
            }
            if (resize_rect.Min.y > resize_rect.Max.y)
            {
                // swap
                let tmp = resize_rect.Min.y;
                resize_rect.Min.y = resize_rect.Max.y;
                resize_rect.Max.y = tmp;
            }
            imgui.ButtonBehavior(resize_rect, this.GetID(resize_grip_n),
                        hovered, held,
                        ButtonFlags.FlattenChildren | ButtonFlags.NoNavFocus);
            //GetForegroundDrawList(this)->AddRect(resize_rect.Min,
            // resize_rect.Max, IM_COL32(255, 255, 0, 255));
            if (hovered.get() || held.get())
            {
                g.MouseCursor = (resize_grip_n & 1) ?
                    MouseCursor.ResizeNESW : MouseCursor.ResizeNWSE;
            }

            if (held.get() && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)
            {
                // Manual auto-fit when double-clicking
                size_target = this.CalcSizeAfterConstraint(autofit);
                imgui.clearActiveID();
            }
            else
            if (held.get())
            {
                // Resize from any of the four corners
                // We don't use an incremental MouseDelta but rather compute an
                // absolute target size based on mouse position
                let corner_target = Vec2.Subtract(g.IO.MousePos, g.ActiveIdClickOffset);
                corner_target.Add(Vec2.Lerp(
                                    Vec2.Mult(grip.InnerDir, grip_hover_outersize),
                                    Vec2.Mult(grip.InnerDir, -grip_hover_outersize),
                                    grip.CornerPosN));
                this.calcResizePosSizeFromAnyCorner(corner_target, grip.CornerPosN,
                                    pos_target/*output*/, size_target/*output*/);
            }
            if (resize_grip_n == 0 || held.get() || hovered.get())
            {
                let col = g.Style.GetColor(held.get() ? "ResizeGripActive" :
                                         hovered.get() ? "ResizeGripHovered" :
                                         "ResizeGrip");
                resize_grip_col[resize_grip_n] = col;
            }
        }
        for (let border_n=0; border_n<resize_border_count; border_n++)
        {
            let border_rect = this.getResizeBorderRect(border_n,
                                grip_hover_innersize,
                                WindowResizeFromEdge);
            imgui.ButtonBehavior(border_rect, this.GetID(border_n + 4), hovered, held,
                            ButtonFlags.FlattenChildren);
            if ((hovered.get() && g.HoveredIdTimer > WindowResizeFromEdgeTimer)
                || held.get())
            {
                g.MouseCursor = (border_n & 1) ? MouseCursor.ResizeEW : MouseCursor.ResizeNS;
                if (held.get())
                    borderheld.set(border_n);
            }
            if (held.get())
            {
                let border_target = this.Pos.Clone();
                let border_posn = new Vec2();
                if (border_n == 0)  // Top
                {
                    border_posn = Vec2.Zero();
                    border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y
                                + WindowResizeFromEdge);
                }
                if (border_n == 1) // Right
                {
                    border_posn = new Vec2(1, 0);
                    border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x
                                + WindowResizeFromEdge);
                }
                if (border_n == 2) // Bottom
                {
                    border_posn = new Vec2(0, 1);
                    border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y
                                + WindowResizeFromEdge);
                }
                if (border_n == 3) // Left
                {
                    border_posn = Vec2.Zero();
                    border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x
                                + WindowResizeFromEdge);
                }
                this.calcResizePosSizeFromAnyCorner(border_target,
                        border_posn, pos_target/*output*/, size_target/*output*/);
            }
        }
        imgui.PopID();

        // Navigation resize (keyboard/gamepad)
        if (g.NavWindowingTarget && g.NavWindowingTarget.RootWindow == this)
        {
            let nav_resize_delta; // Vec2
            if (g.NavInputSource == InputSource.NavKeyboard && g.IO.KeyShift)
                nav_resize_delta = imgui.getNavInputAmount2d(
                                                NavDirSourceFlags.Keyboard,
                                                InputReadMode.Down);
            if (g.NavInputSource == InputSource.NavGamepad)
                nav_resize_delta = imgui.getNavInputAmount2d(
                                                NavDirSourceFlags.PadDPad,
                                                InputReadMode.Down);
            if (nav_resize_delta &&
                (nav_resize_delta.x != 0 || nav_resize_delta.y != 0))
            {
                const NAV_RESIZE_SPEED = 600;
                nav_resize_delta.Mult(Math.floor(NAV_RESIZE_SPEED*g.IO.DeltaTime *
                                        Math.min(g.IO.DisplayFramebufferScale.x,
                                                g.IO.DisplayFramebufferScale.y)));
                g.NavWindowingToggleLayer = false;
                g.NavDisableMouseHover = true;
                resize_grip_col[0] = g.Style.GetColor("ResizeGripActive");
                // FIXME-NAV: Should store and accumulate into a separate size
                // buffer to handle sizing constraints properly, right now a
                // constraint will make us stuck.
                size_target = this.CalcSizeAfterConstraint(
                                Vec2.Add(this.SizeFull, nav_resize_delta));
            }
        }

        // Apply back modified position/size to window
        if (size_target.x != Number.MAX_VALUE)
        {
            this.SizeFull = size_target;
            imgui.MarkIniSettingsDirty(this);
        }
        if (pos_target.x != Number.MAX_VALUE)
        {
            this.Pos = pos_target.Floor();
            imgui.MarkIniSettingsDirty(this);
        }
        this.Size = this.SizeFull;
    } // UpdateManualResize

    SetWindowConditionAllowFlags(flags, enabled)
    {
        if(enabled)
        {
            this.SetWindowPosAllowFlags = this.SetWindowPosAllowFlags | flags;
            this.SetWindowSizeAllowFlags = this.SetWindowSizeAllowFlags | flags;
            this.SetWindowCollapsedAllowFlags = this.SetWindowCollapsedAllowFlags | flags;
        }
        else
        {
            this.SetWindowPosAllowFlags = this.SetWindowPosAllowFlags & ~flags;
            this.SetWindowSizeAllowFlags = this.SetWindowSizeAllowFlags & ~flags;
            this.SetWindowCollapsedAllowFlags = this.SetWindowCollapsedAllowFlags & ~flags;
        }
    }

    RenderOuterBorders()
    {
        let imgui = this.imgui;
        let g = this.imgui.guictx;
        let rounding = this.WindowRounding;
        let border_size = this.WindowBorderSize;
        if (border_size > 0. && !(this.Flags & WindowFlags.NoBackground))
        {
            // the outer border of all windows
            this.DrawList.AddRect(this.Pos,
                            Vec2.Add(this.Pos, this.Size),
                            imgui.GetStyleColor("Border"),
                            rounding, CornerFlags.All, border_size);
        }

        const border_held = this.ResizeBorderHeld;
        if (border_held != -1)
        {
            const half = new Vec2(.5, .5);
            const def = s_resizeBorderDefs[border_held];
            const border_r = this.getResizeBorderRect(border_held, rounding, 0.);
            let p0 = Vec2.Lerp(border_r.Min, border_r.Max, def.CornerPosN1);
            this.DrawList.PathArcTo(
                Vec2.Add(Vec2.Add(p0, half),
                         Vec2.Mult(def.InnerDir, rounding)),
                rounding, def.OuterAngle - Math.PI*0.25, def.OuterAngle);
            p0 = Vec2.Lerp(border_r.Min, border_r.Max, def.CornerPosN2);
            this.DrawList.PathArcTo(
                Vec2.Add(Vec2.Add(p0, half),
                        Vec2.Mult(def.InnerDir, rounding)),
                rounding, def.OuterAngle, def.OuterAngle + Math.PI*0.25);
            this.DrawList.PathStroke(imgui.GetStyleColor("SeparatorActive"),
                false, Math.max(2.0, border_size)); // Thicker than usual
        }
        if (g.Style.FrameBorderSize > 0 &&
              !(this.Flags & WindowFlags.NoTitleBar))
        {
            let y = this.Pos.y + this.TitleBarHeight() - 1;
            this.DrawList.AddLine(
                new Vec2(this.Pos.x + border_size, y),
                new Vec2(this.Pos.x + this.Size.x - border_size, y),
                imgui.GetStyleColor("Border"),
                g.Style.FrameBorderSize);
        }
    }

    RenderResizeGrips(resize_grip_col, resize_grip_count, grip_draw_size,
                      window_border_size, window_rounding)
    {
        for (let resize_grip_n = 0; resize_grip_n < resize_grip_count;
                resize_grip_n++)
        {
            let col = resize_grip_col[resize_grip_n];
            if(col == null) continue;
            const grip = ResizeGripDefs[resize_grip_n];
            const corner = Vec2.Lerp(this.Pos,
                            Vec2.Add(this.Pos, this.Size),
                            grip.CornerPosN);
            let offset = ((resize_grip_n & 1) ?
                new Vec2(window_border_size, grip_draw_size) :
                new Vec2(grip_draw_size, window_border_size));
            this.DrawList.PathLineTo(
                Vec2.Add(corner, Vec2.Mult(offset, grip.InnerDir)));
            offset = (resize_grip_n & 1) ?
                new Vec2(grip_draw_size, window_border_size) :
                new Vec2(window_border_size, grip_draw_size);
            this.DrawList.PathLineTo(
                Vec2.Add(corner, Vec2.Mult(offset, grip.InnerDir)));

            this.DrawList.PathArcToFast(
                new Vec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size),
                            corner.y + grip.InnerDir.y * (window_rounding + window_border_size)),
                window_rounding, grip.AngleMin12, grip.AngleMax12);
            this.DrawList.PathFillConvex(col);
        }
    }

}

class NextWindowData
{
    constructor()
    {
        this.Clear();
        this.PosVal = new Vec2(0, 0);
        this.PosPivotVal = new Vec2(0,0);
        this.SizeVal = new Vec2(0,0);
        this.ContentSizeVal = new Vec2(0,0);
        this.CollapsedVal = false;
        this.SizeConstraintRect = new Rect();
        this.SizeCallback = null;
        this.SizeCallbackUserData = null;
        this.BgAlphaVal = Number.MAX_VALUE;
        this.ZIndex = 0;
        // This is not exposed publicly, so we don't clear it.
        this.MenuBarOffsetMinVal = new Vec2(0,0);
    }

    Clear()
    {
        this.PosCond = CondFlags.None;
        this.SizeCond = CondFlags.None;
        this.ContentSizeCond = CondFlags.None;
        this.CollapsedCond = CondFlags.None;
        this.SizeConstraintCond = CondFlags.None;
        this.FocusCond = CondFlags.None;
        this.BgAlphaCond = CondFlags.None;
        this.ZIndexCond = CondFlags.None;
    }
}

class WindowGroupData
{
    constructor(win, guictx)
    {
        this.BackupCursorPos = win.DC.CursorPos.Clone(); // Vec2
        this.BackupCursorMaxPos = win.DC.CursorMaxPos.Clone(); // Vec2
        this.BackupIndent = win.DC.Indent.Clone(); // Vec1
        this.BackupGroupOffset = win.DC.GroupOffset.Clone(); // Vec1
        this.BackupCurrentLineHeight = win.DC.CurrentLineHeight;
        this.BackupCurrentLineHeightMax = win.DC.CurrentLineHeightMax;
        this.BackupCurrentLineTextBaseOffset = win.DC.CurrentLineTextBaseOffset;
        this.BackupActiveIdIsAlive = guictx.ActiveIdIsAlive;
        this.BackupActiveIdPreviousFrameIsAlive = guictx.ActiveIdPreviousFrameIsAlive;
        this.AdvanceCursor = true;
    }
}

class WindowTempData
{
    constructor()
    {
        let DC = this;
        DC.CursorPos = new Vec2(0,0);
        DC.CursorPosPrevLine = new Vec2(0,0);
        // Initial position in client area with padding
        DC.CursorStartPos = new Vec2(0,0);
        // Used to implicitly calculate the size of our contents, always
        // growing during the frame. Turned into window.SizeContents at the
        // beginning of next frame
        DC.CursorMaxPos = new Vec2(0,0);
        DC.CurrentLineHeight = 0;
        DC.CurrentLineHeightMax = 0;
        DC.PrevLineHeight = 0;
        DC.PrevLineHeightMax = 0;
        DC.CurrentLineTextBaseOffset = 0.;
        DC.PrevLineTextBaseOffset = 0.;
        DC.TreeDepth = 0;
        // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31
        DC.TreeDepthMayJumpToParentOnPop = 0;
        DC.LastItemId = 0;
        DC.LastItemStatusFlags = 0;
        // Interaction rect
        DC.LastItemRect = new Rect();
        // End-user display rect (only valid if
        // LastItemStatusFlags & ItemStatusFlags.HasDisplayRect)
        DC.LastItemDisplayRect = new Rect();
        // Current layer, 0..31 (we currently only use 0..1)
        DC.NavLayerCurrent = NavLayer.Main;
        // = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.
        DC.NavLayerCurrentMask = (1 << NavLayer.Main);
        // Which layer have been written to (result from previous frame)
        DC.NavLayerActiveMask = 0;
        // Which layer have been written to (buffer for current frame)
        DC.NavLayerActiveMaskNext = 0;
        DC.NavHideHighlightOneFrame = false;
        // Set when scrolling can be used (ScrollMax > 0.0f)
        DC.NavHasScroll = false;
        DC.MenuBarAppending = false; // FIXME: Remove this
        // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x,
        // saved/restored as we switch to the menu bar. The only situation when
        // MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y),
        // often used on TVs.
        DC.MenuBarOffset = new Vec2(0,0);
        DC.ChildWindows = new ArrayEx();
        DC.StateStorage = null;
        DC.LayoutType = LayoutType.Vertical;
        // Layout type of parent window at the time of Begin()
        DC.ParentLayoutType = LayoutType.Vertical;
        // Counter for focus/tabbing system. Start at -1 and increase as
        // assigned via FocusableItemRegister() (FIXME-NAV: Needs redesign)
        DC.FocusCounterAll = -1;
        // (same, but only count widgets which you can Tab through)
        DC.FocusCounterTab = -1;

        // We store the current settings outside of the vectors to increase
        // memory locality (reduce cache misses). The vectors are rarely
        // modified. Also it allows us to not heap allocate for short-lived
        // windows which are not using those settings.
        // == ItemFlagsStack.back() [empty == ItemFlags_Default]
        DC.ItemFlags = ItemFlags.Default;
        // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels,
        // <0.0: align xx pixels to the right of window
        DC.ItemWidth = 0.;
        DC.NextItemWidth = Number.MAX_VALUE; // == ItemWidthStack.back()
        DC.TextWrapPos = -1.;  // == TextWrapPosStack.back() [empty == -1.0f]
        DC.ItemFlagsStack = new ArrayEx();
        DC.ItemWidthStack = new ArrayEx();
        DC.TextWrapPosStack = new ArrayEx();
        DC.GroupStack = new ArrayEx();
        DC.StackSizesBackup = {}; // Store size of various stacks for asserting

        // Indentation / start position from left of window (increased by
        // TreePush/TreePop, etc.)
        DC.Indent = new Vec1(0);
        DC.GroupOffset = new Vec1(0);
        // Offset to the current column (if ColumnsCurrent > 0).
        // FIXME: This and the above should be a stack to allow use cases
        // like Tree->Column->Tree. Need revamp columns API.
        DC.ColumnsOffset = new Vec1(0);
        DC.CurrentColumns = null;// Current Columns
    }
}
// =====================================================================================================================
// window.js END
// =====================================================================================================================
// =====================================================================================================================
// datatype.js BEGIN
// =====================================================================================================================

//-------------------------------------------------------------------------
// [SECTION] Data Type and Data Formatting Helpers [Internal]
//-------------------------------------------------------------------------
// - FormatValue(v, format, precision=0)
// - DataTypeFormatString()
// - DataTypeApplyOp()
// - DataTypeApplyOpFromText()
// - GetMinimumStepAtDecimalPrecision
// - RoundScalarWithFormat<>()
//-------------------------------------------------------------------------

i = 0;
var DataType =
{
    S8:i++,       // char
    U8:i++,       // unsigned char
    S16:i++,      // short
    U16:i++,      // unsigned short
    S32:i++,      // int
    U32:i++,      // unsigned int
    S64:i++,      // long long / __int64
    U64:i++,      // unsigned long long / unsigned __int64
    Float:i++,
    Double:i++,
    Count:i
};

// per-datatype: [size, fmt, [min, max]]
const GDataTypeInfo =
[
    [ 1, "%d", [-128, 127]],
    [ 1, "%u", [0, 255]],
    [ 2, "%d", [-32768, 32767]],
    [ 2, "%u", [0, 65535]],
    [ 4, "%d", [-2147483648, 2147483647]],
    [ 4, "%u", [0, 0xFFFFFFFF]],
    [ 8, "%lld", [-Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]],
    [ 8, "%llu", [0, 0xFFFFFFFFFFFFFFFF]],
    [ 4, "%f", [-Number.MAX_VALUE*.5, Number.Max_VALUE*.5]],
    [ 8, "%f",[-Number.MAX_VALUE*.5, Number.Max_VALUE*.5]],
];

const KnownFormats =/%d|%[0-9]d|%e|%[fg]|%.[0-9][fg]|%[0-9].[0-9][fg]|%s/g;
function FormatValues(format, args)
{
    let i=0;
    return format.replace(KnownFormats, function(match, capture)
    {
        // match is the substring of format that matched,
        // capture is the string offset into format
        // console.log(`match:${match}, capture:${capture} i:${i}`);
        let arg = args[i++];
        switch(match)
        {
        case "%d":
            if(typeof(arg) == "boolean")
                return arg ? "1" : "0";
            else
            if(typeof(arg) == "number")
                return arg.toFixed();
            else
                return arg.toString();
        case "%f":
        case "%g":
            return arg.toString();
        case "%e":
            return arg.toExponential();
        case "%s":
            return arg;
        default:
            if(match[2] == "d") // %5d
            {
                let p = Number(match[1]);
                return ("     " + arg.toString()).slice(-p);
            }
            else
            if(match[1] == ".") // %.3f/g
            {
                let p = format[capture+2]; // expect 0-9 (char)
                return arg.toFixed(p);
            }
            else // %5.3f
            if(match[2] == ".")
            {
                let w = match[1]; // expect 0-9 (char)
                let p = match[3]; // expect 0-9 (char)
                if(w == 0) w = 10;
                return ("          " + arg.toFixed(p)).slice(-w);
            }
            else
                return match;
        }
    });
}

// TODO: a more javascripty formatting solution
function FormatValue(v, format, precision=0)
{
    // fmt "R:%3d"
    let i = format.indexOf("%");
    let j, digits;
    if(i != -1)
    {
        for(j=0;j<format.length;j++)
        {
            let c = format[j];
            switch(c)
            {
            case "f": // %f, %0.3f, ..
                precision = Number(format[j-1]);
                break;
            case "d": // %d, %03d %3d
                {
                    digits = (j == (i+1)) ? 0 : Number(format[j-1]);
                    precision = 0;
                }
                break;
            case " ":
                break;
            }
        }
    }
    let vstr;
    if(typeof(v) != "number")
    {
        console.assert(0, typeof(v), v);
        vstr = v;
    }
    else
        vstr = v.toFixed(precision);
    if(digits)
        vstr = ("000" + vstr).slice(-digits);
    if(j)
        return format.slice(0, i) + vstr + format.slice(j+1);
    else
        return vstr;
}

function DataTypeFormatString(val, data_type, format)
{
    if(format == null)
        format = GDataTypeInfo[data_type][1]; // default format
    return FormatValue(val, format);
}

function addClampOverflow(v1, v2, minmax)
{
    let x = Number(v1) + Number(v2);
    if(x < minmax[0]) return minmax[0];
    if(x > minmax[1]) return minmax[1];
    return x;
}

function subClampOverflow(v1, v2, minmax)
{
    let x = Number(v1) - Number(v2);
    if(x < minmax[0]) return minmax[0];
    if(x > minmax[1]) return minmax[1];
    return x;
}

// output is returned
function DataTypeApplyOp(data_type, op, arg1, arg2)
{
    console.assert(op == "+" | op == "-");
    let minmax = GDataTypeInfo[data_type][2];
    if (op == "+")
        return addClampOverflow(arg1, arg2, minmax);
    else
        return subClampOverflow(arg1, arg2, minmax);
}

// User can input math operators (e.g. +100) to edit a numerical values.
// This is interpretted as an operator relative to the initial value.
function DataTypeApplyOpFromText(buf, buforig, data_type, format, onChange=null)
{
    // warning eval isn't safe, but heck this is javascript running in
    // a browser
    let result;
    try
    {
        // option 1:
        // expression in buf could include val (val + Math.cos(2.1))
        // this would require that we disable character filtering.
        // option 2:
        //  assume that
        if("*/+".indexOf(buf[0]) != -1)
            result = eval(buforig+buf); // eg: "123"+"*2"
        else
            result = Number(buf);
        // XXX: should we apply format/clamping here?
        if(result != buforig)
        {
            if(onChange)
                onChange(result);
            return true;
        }
    }
    catch(err)
    {
        // this happens while the user is typing
        // console.error(err);
    }
    return false;  // no change
}

const MinStep = [1., 0.1, 0.01, 0.001, 0.0001, 0.00001,
                0.000001, 0.0000001, 0.00000001, 0.000000001 ];

function GetMinStepAtFloatPrecision(precision)
{
    if (precision< 0)
        return Number.MIN_VALUE;
    return (precision)< MinStep.length ? MinStep[precision] :
                Math.pow(10, -precision);
}

function RoundScalarToPrecision(val, precision)
{
    if(precision == 0)
        return Math.round(val);
    else
    {
        let scale = Math.pow(10, precision);
        let nv = Math.round(scale*val) / scale;
        return nv;
    }
}

function ParseFormatPrecision(fmt)
{
    // XXX:
    if(fmt[0] != "%")
    {
        let i = fmt.indexOf("%");
        if(i != -1)
            fmt = fmt.slice(i);
    }
    switch(fmt)
    {
    case "%d":
    case "%.0f":
        return 0;
    case "%.1f":
        return 1;
    case "%.2f":
        return 2;
    case "%.3f":
    default:
        return 3;
    }
}
// =====================================================================================================================
// datatype.js END
// =====================================================================================================================
// =====================================================================================================================
// font.js BEGIN
// =====================================================================================================================


// exports:
//   Font
//   FontAtlas

const StandardCharCodes = Array.from({length: 512}, (x, i) => i);

class Font
{
    constructor(canvctx, metrics, str)
    {
        this.Metrics = metrics;
        this.Family = metrics.fontFamily;
        this.Size = metrics.fontSize;
        this.Weight = metrics.fontWeight;
        // Metrics currently place top at 0 with +y down
        this.Ascent = this.Metrics.ascent;
        this.Baseline = this.Metrics.baseline;
        this.Descent = this.Metrics.descent;
        this.str = str;
        this.measuring = 0;
        this.ctx = canvctx;
        this.ijmap = FontIJMap[this.Family]; // often undefined, used for icons
    }

    IsLoaded() { return true; }

    // 'maxWidth' stops rendering after a certain width (could be turned into
    // a 2d size). Number.MAX_VALUE to disable. 'wrapWidth' enable automatic
    // word-wrapping across multiple lines to fit into given width. <= 0 to disable.
    CalcTextSizeA(max_width, wrap_width, text, lineHeight)
    {
        // more todo!
        let sz = Vec2.Zero();
        this.MeasureText(text, wrap_width, lineHeight, sz);
        return sz;
    }

    MeasureBegin()
    {
        if(this.measuring == 0)
        {
            this.ctx.save();
            this.ctx.font = this.AsStr();
        }
        this.measuring++;
    }

    MeasureWidth(char)
    {
        if(this.measuring == 0)
        {
            this.ctx.save();
            this.ctx.font = this.AsStr();
        }
        let w =  this.ctx.measureText(char).width; // canvas measure method
        if(this.measuring == 0)
        {
            this.ctx.restore();
        }
        return w;
    }

    MeasureEnd()
    {
        this.measuring--;
        if(this.measuring == 0)
            this.ctx.restore();
        if(this.measuring < 0)
        {
            console.assert(0, "measure block botch");
        }
    }

    // returns a list of lines, wrapWidth<0 to disable, fills in sz
    // used, for example, for tooltip layout
    MeasureText(text, wrapWidth, lineHeight, sz)
    {
        let lines = [];
        if(!text) text = "";
        if(this.measuring == 0)
        {
            this.ctx.save();
            this.ctx.font = this.AsStr();
        }
        if(wrapWidth <= 0)
        {
            lines = text.split("\n");  // >=2 spaces or newlines
            for(let l of lines)
            {
                sz.x = Math.max(sz.x, this.ctx.measureText(l).width);
            }
            sz.y = lines.length * lineHeight;
        }
        else
        {
            for(let line of text.split("\n"))
            {
                let currentLine = "";
                for (let word of line.split(/ +/))
                {
                    let potentialLine = currentLine.length ? currentLine + " " + word : word;
                    let width = this.ctx.measureText(potentialLine).width;
                    if (width < wrapWidth)
                    {
                        currentLine = potentialLine;
                        sz.x = Math.max(sz.x, width);
                    }
                    else
                    {
                        // wrap word
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
            }
            sz.y = lines.length * lineHeight;
        }
        if(this.measuring == 0)
            this.ctx.restore();
        return lines;
    }

    RenderChar(draw_list, size, pos, col, c)
    {
        console.assert(0, "RenderChar");
    }

    RenderText(draw_list, size, pos, col, clip_rect, text, wrapwidth=0)
    {
        console.assert(0, "RenderText");
    }

    AsStr()
    {
        return this.str;
    }

    // icon support -------------------------------
    GetKnownCodes()
    {
        if(!this.ijmap)
            return StandardCharCodes;
        else
            return this.ijmap.knownCodes;
    }

    GetCodeName(code)
    {
        if(!this.ijmap) return null;
        return this.ijmap.icons[code.toString(16)].name;
    }

    GetCodeFor(name)
    {
        if(!this.ijmap) return null;
        return this.ijmap.namesToCode[name];
    }

    GetCharFor(name)
    {
        if(!this.ijmap) return null;
        return String.fromCharCode(this.ijmap.namesToCode[name]);
    }

}

class FontAtlas
{
    // Porting construct, we don't currently have need of a font atlas
    // so this can go away.
    constructor(imgui)
    {
        this.Locked = false;
        this.Flags = 0;
        this.canvasCtx = imgui.canvas.getContext("2d");
        this.fontsInUse = {};
        this.fontMetrics = new FontMetrics();
        this.defaultFontFamily = "Verdana";
        this.defaultFontSize = 12;
        this.defaultFontWeight = "normal";
        this.defaultFontStyle = "normal"; // italic, oblique
        this.availableFonts = [
            // icons/special
            "Material Icons",

            // sans-serif
            "Arial",
            "Arial Black",
            "Arial Narrow",
            "Exo",
            "Gill Sans",
            "Helvetica",
            "Impact",
            "Verdana",
            "Noto Sans",
            "Open Sans",
            "Optima",
            "Roboto",
            "Trebuchet MS",

            // serif
            "American Typewriter",
            "Bookman",
            "Didot",
            "Georgia",
            "New Century Schoolbook",
            "Palatino",
            "Times",
            "Times New Roman",
            "Ultra",

            // monospace
            "Andale Mono",
            "Courier New",
            "Courier",
            "FreeMono",
            "Lucida Console",
            "Roboto Mono",
            "SourceCodePro",

            // handwriting (sans-serif)
            "Comic Sans MS",
       ];
    }

    fontToStr(family, size, weight, style)
    {
        return `${style} ${weight} ${size}px ${family}`;
    }

    FontLoaded(family, size=null, weight=null, style=null)
    {
        if(!family || family == "default")
            family = this.defaultFontFamily;
        if(!size)
            size = this.defaultFontSize;
        if(!weight)
            weight = this.defaultFontWeight;
        if(!style)
            style = this.defaultFontStyle;
        let str = this.fontToStr(family, size, weight, style);
        return this.fontsInUse[str]; // may be undefined
    }

    EnumerateFonts()
    {
        return this.availableFonts;
    }

    // family may include a size: Arial 12
    GetFont(family, size=null, weight=null, style=null)
    {
        if(!family || family == "default")
            family = this.defaultFontFamily;
        if(!size)
            size = this.defaultFontSize;
        if(!weight)
            weight = this.defaultFontWeight;
        if(!style)
            style = this.defaultFontStyle;

        let f = this.FontLoaded(family, size, weight, style);
        if(f == undefined)
        {
            let str = this.fontToStr(family, size, weight, style);
            let bypass = (str.indexOf("Icon") == -1) ? false : true;
            let metrics = this.fontMetrics.MeasureFont(family, size, weight,
                                                        style, bypass);
            f = new Font(this.canvasCtx, metrics, str);
            this.fontsInUse[str] = f;
        }
        return f;
    }

    Size()
    {
        return Object.keys(this.fontsInUse).length;
    }

    ClearFonts()
    {
        this.fontsInUse = {};
    }

    Clear()
    {}

}


// =====================================================================================================================
// font.js END
// =====================================================================================================================
// =====================================================================================================================
// render.js BEGIN
// =====================================================================================================================


let _i = 0;
var RenderIcons =
{
    None: _i++,
    Square: _i++,
    Stop: _i++,
    Play: _i++,
    Pause: _i++,
    RightArrow: _i++,
    LeftArrow: _i++,
    UpArrow: _i++,
    DownArrow: _i++,
};

var ImguiRenderMixin =
{
    // --- render helpers ----
    // (internal-use only)
    // NB: All position are in absolute pixels coordinates (we are never
    // using window coordinates internally)
    renderText(pos, text, hide_text_after_hash=true)
    {
        let g = this.guictx;
        let window = g.CurrentWindow;
        if (hide_text_after_hash)
            text = text.split("##")[0];
        window.DrawList.AddText(text, pos, g.Font, g.FontLineHeight,
                            g.Style.GetColor("Text"));
        if (g.LogEnabled)
            this.logRenderedText(pos, text);
    },

    renderTextWrapped(pos, text, wrap_width)
    {
        let g = this.guictx;
        let window = g.CurrentWindow;
        window.DrawList.AddText(text, pos, g.Font, g.FontLineHeight,
                                g.Style.GetColor("Text"), wrap_width);
        if (g.LogEnabled)
            this.logRenderedText(pos, text);
    },

    renderTextClipped(posMin, posMax, text, text_size_if_known=null,
                    align=null, clipRect=null)
    {
        let g = this.guictx;
        let window = g.CurrentWindow;
        this.renderTextClippedEx(window.DrawList, posMin, posMax, text,
                            text_size_if_known, align, clipRect);
    },

    renderTextClippedEx(draw_list, pos_min, pos_max, text,
                        text_size_if_known=null,
                        align=null, clip_rect=null)
    {
        // Perform CPU side clipping for single clipped element to avoid using
        // scissor state
        let g = this.guictx;
        let pos = pos_min;
        let text_size = text_size_if_known ? text_size_if_known :
                        this.CalcTextSize(text, false, 0);

        const clip_min = clip_rect ? clip_rect.Min : pos_min;
        const clip_max = clip_rect ? clip_rect.Max : pos_max;
        let need_clipping = (pos.x + text_size.x >= clip_max.x) ||
                            (pos.y + text_size.y >= clip_max.y);
        if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
            need_clipping |= (pos.x < clip_min.x) || (pos.y < clip_min.y);

        // Align whole block. We should defer that to the better rendering
        // function when we'll have support for individual line alignment.
        if(align)
        {
            if (align.x > 0)
                pos.x  = Math.max(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
            if (align.y > 0)
                pos.y = Math.max(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);
        }

        // Render
        if (need_clipping)
        {
            let fine_clip_rect = Rect.FromXY(clip_min.x, clip_min.y,
                                            clip_max.x, clip_max.y);
            draw_list.AddText(text, pos, g.Font, g.FontLineHeight,
                    g.Style.GetColor("Text"), 0, /* wrapwidth*/ fine_clip_rect);
        }
        else
        {
            draw_list.AddText(text, pos, g.Font, g.FontLineHeight,
                    g.Style.GetColor("Text"), 0, null);
        }
    },

    // Render a rectangle shaped with optional rounding and borders
    renderFrame(p_min, p_max, fill_col, border=true, rounding=0)
    {
        let g = this.guictx;
        let window = g.CurrentWindow;
        window.DrawList.AddRectFilled(p_min, p_max, fill_col, rounding);
        if(border)
            this.renderFrameBorder(p_min, p_max, rounding);
    },

    renderFrameBorder(p_min, p_max, rounding, size=0)
    {
        let g = this.guictx;
        let window = g.CurrentWindow;
        const border_size = size == 0 ? g.Style.FrameBorderSize : size;
        if (border_size > 0)
        {
            window.DrawList.AddRect(Vec2.AddXY(p_min,1,1),
                                    Vec2.AddXY(p_max, 1, 1),
                                    g.Style.GetColor("BorderShadow"),
                                    rounding, CornerFlags.All, border_size);
            window.DrawList.AddRect(p_min, p_max,
                                    g.Style.GetColor("Border"),
                                    rounding, CornerFlags.All, border_size);
        }
    },

    // Helper for ColorPicker4()
    // NB: This is rather brittle and will show artifact when rounding
    // this enabled if rounded corners overlap multiple cells. Caller
    // currently responsible for avoiding that. I spent a non reasonable
    // amount of time trying to getting this right for ColorButton with
    // rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag +
    // various grid sizes and offsets, and eventually gave up... probably
    // more reasonable to disable rounding alltogether.
    renderColorRectWithAlphaCheckerboard(p_min, p_max, fill_col,
        grid_step, grid_off, rounding, rounding_corners_flags=~0)
    {
        let win = this.getCurrentWindow();
        let g = this.guictx;
        const style = g.Style;
        let on = style.GetColor("CheckerOff");
        let off = style.GetColor("CheckerOn");
        if(fill_col.a > 0)
        {
            on = Color.Blend(on, fill_col);
            off = Color.Blend(off, fill_col);
        }
        if(on.Equals(off))
        {
            win.DrawList.AddRectFilled(p_min, p_max, on, rounding,
                                        rounding_corners_flags);
        }
        else
        {
            // first one big rect representing bg/off
            win.DrawList.AddRectFilled(p_min, p_max, off, rounding,
                                        rounding_corners_flags);
            // next little rects representing fg/on
            let yi = 0;
            let p1 = new Vec2(), p2 = new Vec2();
            for (let y= p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)
            {
                p1.y = Vec1.Clamp(y, p_min.y, p_max.y);
                p2.y = Math.min(y + grid_step, p_max.y);
                if (p2.y <= p1.y)
                    continue;
                for (let x = p_min.x + grid_off.x + (yi & 1) * grid_step;
                     x < p_max.x; x += grid_step * 2)
                {
                    p1.x = Vec1.Clamp(x, p_min.x, p_max.x);
                    p2.x = Math.min(x + grid_step, p_max.x);
                    if (p2.x <= p1.x)
                        continue;
                    let rounding_corners_flags_cell = 0;
                    if (p1.y <= p_min.y)
                    {
                        if (p1.x <= p_min.x)
                            rounding_corners_flags_cell |= CornerFlags.TopLeft;
                        if (p2.x >= p_max.x)
                            rounding_corners_flags_cell |= CornerFlags.TopRight;
                    }
                    if (p2.y >= p_max.y)
                    {
                        if (p1.x <= p_min.x)
                            rounding_corners_flags_cell |= CornerFlags.BotLeft;
                        if (p2.x >= p_max.x)
                            rounding_corners_flags_cell |= CornerFlags.BotRight;
                    }
                    rounding_corners_flags_cell &= rounding_corners_flags;
                    win.DrawList.AddRectFilled(p1, p2, on,
                                rounding_corners_flags_cell ? rounding : 0,
                                    rounding_corners_flags_cell);
                }
            }
        }
    },

    // simple/common icons that we draw manually.  For more complex
    // icons we recommend using an icon font.
    renderIcon(icon, p_min, scale=1)
    {
        let g = this.guictx;
        switch(icon)
        {
        case RenderIcons.Play:
        case RenderIcons.Arrow:
        case RenderIcons.RightArrow:
            this.renderArrow(p_min, Dir.Right, scale);
            break;
        case RenderIcons.LeftArrow:
            this.renderArrow(p_min, Dir.Left, scale);
            break;
        case RenderIcons.UpArrow:
            this.renderArrow(p_min, Dir.Up, scale);
            break;
        case RenderIcons.DownArrow:
            this.renderArrow(p_min, Dir.Down, scale);
            break;
        case RenderIcons.Stop:
        case RenderIcons.Square:
            {
                const h = g.FontSize;
                let col = g.Style.GetColor("Text");
                let r = h * 0.3 * scale;
                let center = Vec2.AddXY(p_min, h*0.5, h*0.5*scale);
                let p0 = Vec2.AddXY(center, -r, -r);
                let p1 = Vec2.AddXY(center, r, r);
                g.CurrentWindow.DrawList.AddRectFilled(p0, p1, col, 0.);
            }
            break;
        case RenderIcons.Pause:
            {
                /* implementme */
            }
            break;
        }
    },

    renderArrow(p_min, dir, scale=1, disabled=false)
    {
        let g = this.guictx;
        const h = g.FontSize;
        let r = h * 0.4 * scale;
        let center = Vec2.AddXY(p_min, h*0.5, h*0.5*scale);

        let a, b, c;
        switch (dir)
        {
        case Dir.Up:
        case Dir.Down:
            if (dir == Dir.Up) r = -r;
            a = new Vec2( 0.0, 0.75*r);
            b = new Vec2(-0.866*r, -0.75*r);
            c = new Vec2( 0.866*r, -0.75*r);
            break;
        case Dir.Left:
        case Dir.Right:
            if (dir == Dir.Left) r = -r;
            a = new Vec2( 0.750*r, 0.);
            b = new Vec2(-0.750*r, 0.866*r);
            c = new Vec2(-0.750*r,-0.866*r);
            break;
        case Dir.None:
        case Dir.COUNT:
            console.assert(0);
            break;
        }

        g.CurrentWindow.DrawList.AddTriangleFilled(
            Vec2.Add(center, a), Vec2.Add(center, b), Vec2.Add(center, c),
            disabled ? g.Style.GetColor("TextDisabled") : g.Style.GetColor("Text")
        );
    },

    renderBullet(pos)
    {
        let g = this.guictx;
        let window = g.CurrentWindow;
        window.DrawList.AddCircleFilled(pos, g.FontSize*0.2,
                                        g.Style.GetColor("Text"), 9);
    },

    renderCheckMark(pos, col, sz)
    {
        let g = this.guictx;
        let window = g.CurrentWindow;
        let thickness = Math.max(sz / 5., 1);
        sz -= thickness*0.5;
        pos = Vec2.AddXY(pos, thickness*0.25, thickness*0.25);
        let third = sz / 3;
        let bx = pos.x + third;
        let by = pos.y + sz - third*0.5;
        window.DrawList.PathLineTo(new Vec2(bx - third, by - third));
        window.DrawList.PathLineTo(new Vec2(bx, by));
        window.DrawList.PathLineTo(new Vec2(bx + third*2, by - third*2));
        window.DrawList.PathStroke(col, false, thickness);
    },

    renderNavHighlight(bb, id, flags=NavHighlightFlags.TypeDefault)
    {
        let g = this.guictx;
        if (id != g.NavId)
            return;
        if (g.NavDisableHighlight && !(flags & NavHighlightFlags.AlwaysDraw))
            return;
        let window = g.CurrentWindow;
        if (window.DC.NavHideHighlightOneFrame)
            return;

        let rounding = (flags & NavHighlightFlags.NoRounding) ? 0: g.Style.FrameRounding;
        let display_rect = bb.Clone().ClipWith(window.ClipRect);
        if (flags & NavHighlightFlags.TypeDefault)
        {
            const thickness = 2.;
            const distance = 3. + thickness * 0.5;
            display_rect.Expand(distance);
            let fully_visible = window.ClipRect.Contains(display_rect);
            if (!fully_visible)
                window.DrawList.PushClipRect(display_rect.Min, display_rect.Max);
            window.DrawList.AddRect(Vec2.Add(display_rect.Min,thickness*0.5),
                                    Vec2.Subtract(display_rect.Max,thickness*.5),
                                    g.Style.GetColor("NavHighlight"),
                                    rounding, CornerFlags.All, thickness);
            if (!fully_visible)
                window.DrawList.PopClipRect();
        }
        if (flags & NavHighlightFlags.TypeThin)
        {
            window.DrawList.AddRect(display_rect.Min, display_rect.Max,
                            this.Style.GetColor("NavHighlight"),
                            rounding, ~0, 1);
        }
    },

    logRenderedText(ref_pos, text)
    {},

    // Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length
    /// from base to tip. half_sz.y is length on each side.
    renderArrowPointingAt(draw_list, pos, half_sz, direction, col)
    {
        switch (direction)
        {
        case Dir.Left:
            draw_list.AddTriangleFilled(
                        new Vec2(pos.x + half_sz.x, pos.y - half_sz.y),
                        new Vec2(pos.x + half_sz.x, pos.y + half_sz.y),
                        pos, col);
            return;
        case Dir.Right:
            draw_list.AddTriangleFilled(
                        new Vec2(pos.x - half_sz.x, pos.y + half_sz.y),
                        new Vec2(pos.x - half_sz.x, pos.y - half_sz.y),
                        pos, col);
            return;
        case Dir.Up:
            draw_list.AddTriangleFilled(
                        new Vec2(pos.x + half_sz.x, pos.y + half_sz.y),
                        new Vec2(pos.x - half_sz.x, pos.y + half_sz.y),
                        pos, col);
            return;
        case Dir.Down:
            draw_list.AddTriangleFilled(
                        new Vec2(pos.x - half_sz.x, pos.y - half_sz.y),
                        new Vec2(pos.x + half_sz.x, pos.y - half_sz.y),
                        pos, col);
            return;
        case Dir.None:
        case Dir.COUNT:
            break; // Fix warnings
        }
    },

    // fill a horizontal portion of a rect (progress bar)
    // move to DrawList?
    renderRectFilledRangeH(draw_list, rect, col, x_start_norm, x_end_norm, rounding)
    {
        const half_pi = Math.PI * 0.5;
        let acos01 = function(x)
        {
            if(x <= 0) return half_pi;
            if(x >= 1) return 0;
            return Math.acos(x);
        };

        if (x_end_norm == x_start_norm)
            return;
        if (x_start_norm > x_end_norm)
        {
            // swap
            let x = x_end_norm;
            x_end_norm = x_start_norm;
            x_start_norm = x;
        }

        let p0 = new Vec2(Vec1.Lerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);
        let p1 = new Vec2(Vec1.Lerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);
        if (rounding == 0)
        {
            draw_list.AddRectFilled(p0, p1, col, 0.);
            return;
        }

        rounding = Vec1.Clamp(Math.min((rect.Max.x - rect.Min.x) * 0.5,
                                    (rect.Max.y - rect.Min.y) * 0.5) - 1.,
                                0, rounding);
        const inv_rounding = 1. / rounding;
        const arc0_b = acos01(1. - (p0.x - rect.Min.x) * inv_rounding);
        const arc0_e = acos01(1 - (p1.x - rect.Min.x) * inv_rounding);
        const x0 = Math.max(p0.x, rect.Min.x + rounding);
        if (arc0_b == arc0_e)
        {
            draw_list.PathLineTo(new Vec2(x0, p1.y));
            draw_list.PathLineTo(new Vec2(x0, p0.y));
        }
        else
        if (arc0_b == 0 && arc0_e == half_pi)
        {
            draw_list.PathArcToFast(new Vec2(x0, p1.y - rounding), rounding, 3, 6); // BL
            draw_list.PathArcToFast(new Vec2(x0, p0.y + rounding), rounding, 6, 9); // TR
        }
        else
        {
            draw_list.PathArcTo(new Vec2(x0, p1.y - rounding), rounding,
                    Math.PI - arc0_e, Math.PI - arc0_b, 3); // BL
            draw_list.PathArcTo(new Vec2(x0, p0.y + rounding), rounding,
                    Math.PI + arc0_b, Math.PI + arc0_e, 3); // TR
        }
        if (p1.x > rect.Min.x + rounding)
        {
            const arc1_b = acos01(1 - (rect.Max.x - p1.x) * inv_rounding);
            const arc1_e = acos01(1 - (rect.Max.x - p0.x) * inv_rounding);
            const x1 = Math.min(p1.x, rect.Max.x - rounding);
            if (arc1_b == arc1_e)
            {
                draw_list.PathLineTo(new Vec2(x1, p0.y));
                draw_list.PathLineTo(new Vec2(x1, p1.y));
            }
            else
            if (arc1_b == 0 && arc1_e == half_pi)
            {
                draw_list.PathArcToFast(new Vec2(x1, p0.y + rounding), rounding, 9, 12); // TR
                draw_list.PathArcToFast(new Vec2(x1, p1.y - rounding), rounding, 0, 3);  // BR
            }
            else
            {
                draw_list.PathArcTo(new Vec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR
                draw_list.PathArcTo(new Vec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR
            }
        }
        draw_list.PathFillConvex(col);
    },

    renderPixelEllipsis(draw_list, pos, count, col)
    {
        // should be able to output font "..."
        console.assert(0, "ellipsis");
    },
}; // end mixin
// =====================================================================================================================
// render.js END
// =====================================================================================================================
// =====================================================================================================================
// dragdrop.js BEGIN
// =====================================================================================================================


var DragDropFlags =
{
    None: 0,
    // BeginDragDropSource() flags
    SourceNoPreviewTooltip: 1 << 0,   
        // By default, a successful call to BeginDragDropSource opens a tooltip 
        // so you can display a preview or description of the source contents. 
        // This flag disable this behavior.
    SourceNoDisableHover: 1 << 1,   
        // By default, when dragging we clear data so that IsItemHovered() will 
        // return false, to avoid subsequent user code submitting tooltips. 
        // This flag disable this behavior so you can still call IsItemHovered() 
        // on the source item.
    SourceNoHoldToOpenOthers: 1 << 2,   
        // Disable the behavior that allows to open tree nodes and collapsing 
        //header by holding over them while dragging a source item.
    SourceAllowNullID: 1 << 3,   
        // Allow items such as Text(), Image() that have no unique identifier 
        // to be used as drag source, by manufacturing a temporary identifier 
        // based on their window-relative position. This is extremely unusual 
        // within the dear imgui ecosystem and so we made it explicit.
    SourceExtern: 1 << 4,   
        // External source (from outside of imgui), won't attempt to read 
        // current item/window info. Will always return true. Only one Extern 
        // source can be active simultaneously.
    SourceAutoExpirePayload: 1 << 5,   
        // Automatically expire the payload if the source cease to be submitted 
        // (otherwise payloads are persisting while being dragged)

    // AcceptDragDropPayload() flags
    AcceptBeforeDelivery: 1 << 10,  
        // AcceptDragDropPayload() will returns true even before the mouse 
        // button is released. You can then call IsDelivery() to test if the 
        // payload needs to be delivered.
    AcceptNoDrawDefaultRect: 1 << 11,  
        // Do not draw the default highlight rectangle when hovering over target.
    AcceptNoPreviewTooltip: 1 << 12,  
        // Request hiding the BeginDragDropSource tooltip from the 
        // BeginDragDropTarget site.
};
f = DragDropFlags;
// For peeking ahead and inspecting the payload before delivery.
f.AcceptPeekOnly = f.AcceptBeforeDelivery | f.AcceptNoDrawDefaultRect;

// Data payload for Drag and Drop operations: 
//      AcceptDragDropPayload(), GetDragDropPayload()
class Payload
{
    constructor()
    {
        this.Clear();
    }

    IsDataType(typ)
    {
        return this.DataFrameCount != -1 && this.DataType === typ;
    }

    IsPreview() { return this.Preview; }
    IsDelivery() { return this.Delivery; }

    Clear()
    {
        this.SourceId = 0;
        this.SourceParentId = 0;
        this.DataType = "";
        this.Data = null;
        this.DataFrameCount = -1;
        this.Preview = false;
        this.Delivery = false;
    }
}

var ImguiDragDropMixin =
{
    // [BETA API] API may evolve!
    ClearDragDrop()
    {
        let g = this.guictx;
        g.DragDropActive = false;
        g.DragDropPayload.Clear();
        g.DragDropAcceptFlags = DragDropFlags.None;
        g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
        g.DragDropAcceptIdCurrRectSurface = Number.MAX_VALUE;
        g.DragDropAcceptFrameCount = -1;
    },

    // call when the current item is active. If this returns true, you can
    //  call SetDragDropPayload() + EndDragDropSource()
    BeginDragDropSource(flags = 0)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        let source_drag_active = false;
        let source_id = 0;
        let source_parent_id = 0;
        let mouse_button = 0;
        if (!(flags & DragDropFlags.SourceExtern))
        {
            source_id = win.DC.LastItemId;
            // Early out for most common case
            if (source_id != 0 && g.ActiveId != source_id) 
                return false;
            if (g.IO.MouseDown[mouse_button] == false)
                return false;

            if (source_id == 0)
            {
                // If you want to use BeginDragDropSource() on an item with no 
                // unique identifier for interaction, such as Text() or Image(), 
                // you need to:
                //  A) Read the explanation below, 
                //  B) Use the DragDropFlags.SourceAllowNullID flag, 
                //  C) Swallow your programmer pride.
                if (!(flags & DragDropFlags.SourceAllowNullID))
                {
                    console.assert(0);
                    return false;
                }

                // Magic fallback (=somehow reprehensible) to handle items with 
                // no assigned ID, e.g. Text(), Image()
                // We build a throwaway ID based on current ID stack + relative 
                // AABB of items in window.
                // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, 
                // so if your widget moves your dragging operation will be canceled.
                // We don't need to maintain/call ClearActiveID() as releasing 
                // the button will early out this function and trigger !ActiveIdIsAlive.
                let is_hovered = (win.DC.LastItemStatusFlags & ItemStatusFlags.HoveredRect) != 0;
                if (!is_hovered && (g.ActiveId == 0 || g.ActiveIdWindow != win))
                    return false;
                source_id = win.DC.LastItemId = win.GetIDFromRectangle(win.DC.LastItemRect);
                if (is_hovered)
                    this.setHoveredID(source_id);
                if (is_hovered && g.IO.MouseClicked[mouse_button])
                {
                    this.setActiveID(source_id, win);
                    this.FocusWindow(win);
                }
                // Allow the underlying widget to display/return hovered 
                // during the mouse release frame, else we would get a flicker.
                if (g.ActiveId == source_id) 
                    g.ActiveIdAllowOverlap = is_hovered;
            }
            else
            {
                g.ActiveIdAllowOverlap = false;
            }
            if (g.ActiveId != source_id)
                return false;
            source_parent_id = win.IDStack.back();
            source_drag_active = this.IsMouseDragging(mouse_button);
        }
        else
        {
            win = null;
            source_id = GetHash("#SourceExtern");
            source_drag_active = true;
        }

        if (source_drag_active)
        {
            if (!g.DragDropActive)
            {
                console.assert(source_id != 0);
                this.ClearDragDrop();
                let payload = g.DragDropPayload;
                payload.SourceId = source_id;
                payload.SourceParentId = source_parent_id;
                g.DragDropActive = true;
                g.DragDropSourceFlags = flags;
                g.DragDropMouseButton = mouse_button;
            }
            g.DragDropSourceFrameCount = g.FrameCount;
            g.DragDropWithinSourceOrTarget = true;

            if (!(flags & DragDropFlags.SourceNoPreviewTooltip))
            {
                // Target can request the Source to not display its tooltip 
                // (we use a dedicated flag to make this request explicit)
                // We unfortunately can't just modify the source flags and 
                // skip the call to BeginTooltip, as caller may be emitting contents.
                this.BeginTooltip();
                if (g.DragDropAcceptIdPrev && 
                    (g.DragDropAcceptFlags & DragDropFlags.AcceptNoPreviewTooltip))
                {
                    let tooltip_win = g.CurrentWindow;
                    tooltip_win.SkipItems = true;
                    tooltip_win.HiddenFramesCanSkipItems = 1;
                }
            }

            if (!(flags & DragDropFlags.SourceNoDisableHover) && 
                !(flags & DragDropFlags.SourceExtern))
            {
                win.DC.LastItemStatusFlags &= ~ItemStatusFlags.HoveredRect;
            }

            return true;
        }
        return false;
    },

    // only call EndDragDropSource() if BeginDragDropSource() returns true!
    EndDragDropSource()
    {
        let g = this.guictx;
        console.assert(g.DragDropActive);
        console.assert(g.DragDropWithinSourceOrTarget, "Not after a BeginDragDropSource()?");

        if (!(g.DragDropSourceFlags & DragDropFlags.SourceNoPreviewTooltip))
            this.EndTooltip();

        // Discard the drag if have not called SetDragDropPayload()
        if (g.DragDropPayload.DataFrameCount == -1)
            this.ClearDragDrop();
        g.DragDropWithinSourceOrTarget = false;
    },

    // type is a user defined string of maximum 32 characters. Strings
    // starting with '_' are reserved for dear imgui internal types. Data
    // is copied and held by imgui.
    // Use 'cond' to choose to submit payload on drag start or every frame
    SetDragDropPayload(type, data, cond = 0)
    {
        let g = this.guictx;
        let payload = g.DragDropPayload;
        if (cond == 0)
            cond = CondFlags.Always;

        console.assert(type != null);
        console.assert(type.length < 32, "Payload type can be at most 32 characters long");
        console.assert(cond == CondFlags.Always || cond == CondFlags.Once);
        console.assert(payload.SourceId != 0);
            // Not called between BeginDragDropSource() and EndDragDropSource()

        if (cond == CondFlags.Always || payload.DataFrameCount == -1)
        {
            payload.DataType = type;
            payload.Data = data; // XXX: data.Clone, JSON.stringify?
        }
        payload.DataFrameCount = g.FrameCount;

        return (g.DragDropAcceptFrameCount == g.FrameCount) || 
               (g.DragDropAcceptFrameCount == g.FrameCount - 1);
    },

    // call after submitting an item that may receive a payload. If this
    //  returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
    // We don't use BeginDragDropTargetCustom() and duplicate its code because:
    //  1) we use LastItemRectHoveredRect which handles items that pushes a 
    //     temporarily clip rectangle in their code. Calling 
    //     BeginDragDropTargetCustom(LastItemRect) would not handle them.
    // 2) and it's faster. as this code may be very frequently called, we want 
    //     to early out as fast as we can. Also note how the HoveredWindow test 
    //     is positioned differently in both functions (in both functions 
    //     we optimize for the cheapest early out case)
    BeginDragDropTarget()
    {
        let g = this.guictx;
        if (!g.DragDropActive)
            return false;

        let  win = g.CurrentWindow;
        if (!(win.DC.LastItemStatusFlags & ItemStatusFlags.HoveredRect))
            return false;
        if (g.HoveredWindow == null || 
            win.RootWindow != g.HoveredWindow.RootWindow)
        {
            return false;
        }

        const display_rect = (win.DC.LastItemStatusFlags & ItemStatusFlags.HasDisplayRect) ? 
                                win.DC.LastItemDisplayRect : win.DC.LastItemRect;
        let id = win.DC.LastItemId;
        if (id == 0)
            id = win.GetIDFromRectangle(display_rect);
        if (g.DragDropPayload.SourceId == id)
            return false;

        console.assert(g.DragDropWithinSourceOrTarget == false);
        g.DragDropTargetRect = display_rect.Clone();
        g.DragDropTargetId = id;
        g.DragDropWithinSourceOrTarget = true;
        return true;
    },

    BeginDragDropTargetCustom(bb, id)
    {
        let g = this.guictx;
        if (!g.DragDropActive)
            return false;

        let win = g.CurrentWindow;
        if (g.HoveredWindow == null || win.RootWindow != g.HoveredWindow.RootWindow)
            return false;
        console.assert(id != 0);
        if (!this.IsMouseHoveringRect(bb.Min, bb.Max) || 
            (id == g.DragDropPayload.SourceId))
        {
            return false;
        }
        if (win.SkipItems)
            return false;

        console.assert(g.DragDropWithinSourceOrTarget == false);
        g.DragDropTargetRect = bb;
        g.DragDropTargetId = id;
        g.DragDropWithinSourceOrTarget = true;
        return true;
    },

    isDragDropPayloadBeingAccepted() // unused?
    {
        let g = this.guictx;
        return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
    },

    // accept contents of a given type. If DragDropFlags.AcceptBeforeDelivery
    // is set you can peek into the payload before the mouse button is released.
    // returns payload.
    AcceptDragDropPayload(type, flags = 0)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        let payload = g.DragDropPayload;
        console.assert(g.DragDropActive, 
                "Not called between BeginDragDropTargetand EndDragDropTarget?");
        console.assert(payload.DataFrameCount != -1,
                "Forgot to call EndDragDropTarget?");
        if (type != null && !payload.IsDataType(type))
            return null;

        // Accept smallest drag target bounding box, this allows us to nest 
        // drag targets conveniently without ordering constraints.
        // NB: We currently accept null id as target. However, overlapping 
        // targets requires a unique ID to function!
        const was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
        let r = g.DragDropTargetRect.Clone();
        let r_surface = r.GetWidth() * r.GetHeight();
        if (r_surface < g.DragDropAcceptIdCurrRectSurface)
        {
            g.DragDropAcceptFlags = flags;
            g.DragDropAcceptIdCurr = g.DragDropTargetId;
            g.DragDropAcceptIdCurrRectSurface = r_surface;
        }

        // Render default drop visuals
        payload.Preview = was_accepted_previously;
        flags |= (g.DragDropSourceFlags & DragDropFlags.AcceptNoDrawDefaultRect); 
            // Source can also inhibit the preview (useful for external sources 
            // that lives for 1 frame)
        if (!(flags & DragDropFlags.AcceptNoDrawDefaultRect) && payload.Preview)
        {
            // FIXME-DRAG: Settle on a proper default visuals for drop target.
            r.Expand(3.5);
            let push_clip_rect = win.ClipRect.Contains(r);
            if (push_clip_rect) win.DrawList.PushClipRect(
                                        Vec2.AddXY(r.Min, -1, -1), 
                                        Vec2.AddXY(r.Max, 1, 1));
            win.DrawList.AddRect(r.Min, r.Max, g.Style.GetColor("DragDropTarget"), 
                                0, ~0, 2);
            if (push_clip_rect) 
                win.DrawList.PopClipRect();
        }

        g.DragDropAcceptFrameCount = g.FrameCount;
        // For extern drag sources affecting os window focus, it's easier 
        // to just test !IsMouseDown() instead of IsMouseReleased()
        payload.Delivery = was_accepted_previously && 
                            !this.IsMouseDown(g.DragDropMouseButton); 
        if (!payload.Delivery && !(flags & DragDropFlags.AcceptBeforeDelivery))
            return null;

        return payload;
    },

    // peek directly into the current payload from anywhere. may return null.
    // use Payload::IsDataType() to test for the payload type.
    GetDragDropPayload()
    {
        let g = this.guictx;
        return g.DragDropActive ? g.DragDropPayload : null;
    },

    // only call EndDragDropTarget() if BeginDragDropTarget() returns true!
    // We don't really use/need this now, but added it for the sake of 
    // consistency and because we might need it later.
    EndDragDropTarget()
    {
        let g = this.guictx;
        console.assert(g.DragDropActive);
        console.assert(g.DragDropWithinSourceOrTarget);
        g.DragDropWithinSourceOrTarget = false;
    },

};
// =====================================================================================================================
// dragdrop.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/layout.js BEGIN
// =====================================================================================================================


//-------------------------------------------------------------------------
// [SECTION] Widgets: Low-level Layout helpers
//-------------------------------------------------------------------------
// - Spacing()
// - Dummy()
// - NewLine()
// - AlignTextToFramePadding()
// - Separator()
//  -- SeparatorFlags
// - VerticalSeparator() [Internal]
// - SplitterBehavior() [Internal]
// - GroupBegin/End
//
//  notes:
//      
//-------------------------------------------------------------------------
var SeparatorFlags =
{
    None: 0,
    Horizontal: 1 << 0,
    Vertical: 1 << 1
};

class LayoutGroupData
{
    constructor(win, guictx)
    {
        this.BackupCursorPos = win.DC.CursorPos.Clone(); // Vec2
        this.BackupCursorMaxPos = win.DC.CursorMaxPos.Clone(); // Vec2
        this.BackupIndent = win.DC.Indent.Clone(); // Vec1
        this.BackupGroupOffset = win.DC.GroupOffset.Clone(); // Vec1
        this.BackupCurrentLineHeight = win.DC.CurrentLineHeight;
        this.BackupCurrentLineHeightMax = win.DC.CurrentLineHeightMax;
        this.BackupCurrentLineTextBaseOffset = win.DC.CurrentLineTextBaseOffset;
        this.BackupActiveIdIsAlive = guictx.ActiveIdIsAlive;
        this.BackupActiveIdPreviousFrameIsAlive = guictx.ActiveIdPreviousFrameIsAlive;
        this.AdvanceCursor = true;
    }
}

var ImguiLayoutMixin =
{

    // Gets back to previous line and continue with horizontal layout
    //      offset_from_start_x == 0 : follow right after previous item
    //      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
    //      spacing_w < 0            : use default spacing if pos_x == 0, no spacing if pos_x != 0
    //      spacing_w >= 0           : enforce spacing amount
    SameLine(offset_from_start_x=0, spacing_w=-1)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let g = this.guictx;
        if (offset_from_start_x != 0)
        {
            if (spacing_w < 0.) spacing_w = 0.;
            win.DC.CursorPos.x = win.Pos.x - win.Scroll.x + offset_from_start_x +
                  spacing_w + win.DC.GroupOffset.x + win.DC.ColumnsOffset.x;
            win.DC.CursorPos.y = win.DC.CursorPosPrevLine.y;
        }
        else
        {
            if (spacing_w < 0) spacing_w = g.Style.ItemSpacing.x;
            win.DC.CursorPos.x = win.DC.CursorPosPrevLine.x + spacing_w;
            win.DC.CursorPos.y = win.DC.CursorPosPrevLine.y;
        }
        win.DC.CurrentLineHeight = win.DC.PrevLineHeight;
        win.DC.CurrentLineHeightMax = win.DC.PrevLineHeightMax;
        win.DC.CurrentLineTextBaseOffset = win.DC.PrevLineTextBaseOffset;
    },

    PrevLineHeight()
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return 0;
        return win.DC.PrevLineHeight;
    },

    Indent(indent_w = 0)
    {
        let win = this.getCurrentWindow();
        let g = this.guictx;
        win.DC.Indent.x += (indent_w != 0) ? indent_w : g.Style.IndentSpacing;
        win.DC.CursorPos.x = win.Pos.x + win.DC.Indent.x + win.DC.ColumnsOffset.x;
    },

    Unindent(indent_w = 0)
    {
        let win = this.getCurrentWindow();
        let g = this.guictx;
        win.DC.Indent.x -= (indent_w != 0) ? indent_w : g.Style.IndentSpacing;
        win.DC.CursorPos.x = win.Pos.x + win.DC.Indent.x + win.DC.ColumnsOffset.x;
    },

    Spacing()
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;
        this.itemSize(Vec2.Zero());
    },

    Dummy(size)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let bb = new Rect(win.DC.CursorPos,
                        Vec2.Add(win.DC.CursorPos, size));
        this.itemSize(bb);
        this.itemAdd(bb, 0);
    },

    NextItemWouldBeClipped(size)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return true;
        let bb = new Rect(win.DC.CursorPos,
                        Vec2.Add(win.DC.CursorPos, size));
        return this.isClippedEx(bb);
    },

    // undo a SameLine() or force a new line when in an horizontal-layout context.
    NewLine(fraction=1)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let g = this.guictx;
        let backup_layout_type = win.DC.LayoutType;
        win.DC.LayoutType = LayoutType.Vertical;
        // In the event that we are on a line with items that are smaller than
        // FontLineHeight, we will preserve that height.
        if (win.DC.CurrentLineHeight > 0)
            this.itemSize(Vec2.Zero());
        else
            this.itemSize(new Vec2(0, g.FontLineHeight*fraction));
        win.DC.LayoutType = backup_layout_type;
    },

    // text alignment notes:
    //    CursorPos is the overall arbiter
    //      text_pos = new Vec2(win.DC.CursorPos.x, 
    //                      win.DC.CursorPos.y + win.DC.CurrentLineTextBaseOffset);
    //    Font drawing applies it's font-metrics to "find a baseline".
    //    CurrentLineTextBaseOffset is from the top, ie: 0 is the default.
    //    CurrentLineHeight 
    //          * is managed by this file (though it may be zeroed elsewhere)
    //          * is used by button, text, tree
    //  
    AlignTextToFramePadding()
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let g = this.guictx;
        let next = Math.max(win.DC.CurrentLineHeight,
                        g.FontLineHeight + g.Style.FramePadding.y * 2);
        win.DC.CurrentLineHeight = next;
        win.DC.CurrentLineHeightMax = Math.max(win.DC.CurrentLineHeightMax, next);
        win.DC.CurrentLineTextBaseOffset = Math.max(win.DC.CurrentLineTextBaseOffset,
                                            g.Style.FramePadding.y);
    },

    // AlignTextToFrameCenter may be useful in lines with a variety
    // of font sizes.  The goal is to cause Big and small fonts
    // to share a midline (defined as Baseline / 2). The knob that
    // governs this is "CurrentLineTextBaseOffset", and the method above
    // only increases this value (always takes the max encountered).
    // This method allows the value to grow and to shrink according to
    // the current font.  A problem arises whereby a line begins with
    // a small font, the proceeds to a large one.  In this case the large
    // font may interfere with the previous line. To address this we require
    // an estimated maxFrameHeight which should be shared for all text items
    // that require centering on a line.  This call should be made after a
    // font change occurs.
    //
    //   CursorY <---                          
    //    ^                                   ^
    //    | FramePadding.y                    |
    //    v                                   |
    //    TextBaseOffset  <----               |  Current line height
    //    A line of text <____ baseline       |  (FontLineHeight is Font.size*linespacing)
    //    ^                                   |   
    //    | FramePadding.y                    |
    //    v                                   v
    //
    AlignTextToFrameCenter(maxFontHeight)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let g = this.guictx;
        let ypad = g.Style.FramePadding.y;
        let next = g.FontLineHeight + ypad * 2;
        win.DC.CurrentLineHeight = next;
        win.DC.CurrentLineHeightMax = Math.max(win.DC.CurrentLineHeightMax, next);

        let mid = maxFontHeight / 2; // NB: thiis the font center, not the 
        let fmid = this.GetFontMidline();
        let off = ypad + (mid - fmid); // if fmid is 12 and mid is 24, off is +12
        win.DC.CurrentLineTextBaseOffset = Math.max(ypad, off);
    },

    // Horizontal/vertical separating line
    // Axis default to current layout type, so generally Horizontal unless
    // e.g. in a menu bar
    Separator()
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;
        let g = this.guictx;

        // Those flags should eventually be overridable by the user
        let flags = (win.DC.LayoutType == LayoutType.Horizontal) ?
                    SeparatorFlags.Vertical : SeparatorFlags.Horizontal;
        // console.assert(ImIsPowerOfTwo(flags & (SeparatorFlags_Horizontal | SeparatorFlags_Vertical)));   // Check that only 1 option is selected
        if (flags & SeparatorFlags.Vertical)
        {
            this.VerticalSeparator();
            return;
        }

        // Horizontal Separator
        if (win.DC.CurrentColumns)
            this.PopClipRect();

        let x1 = win.Pos.x;
        let x2 = win.Pos.x + win.Size.x;
        if (win.DC.GroupStack.empty())
            x1 += win.DC.Indent.x;

        const bb = Rect.FromXY(x1, win.DC.CursorPos.y,
                               x2, win.DC.CursorPos.y+1);
        // NB: we don't provide our width so that it doesn't get feed back into
        // AutoFit, we don't provide height to not alter layout.
        this.itemSize(Vec2.Zero());
        if (!this.itemAdd(bb, 0))
        {
            if (win.DC.CurrentColumns)
                this.pushColumnClipRect();
            return;
        }

        win.DrawList.AddLine(bb.Min, new Vec2(bb.Max.x, bb.Min.y),
                                g.Style.GetColor("Separator"));

        if (g.LogEnabled)
            this.LogRenderedText(bb.Min, "--------------------------------");

        if (win.DC.CurrentColumns)
        {
            this.pushColumnClipRect();
            win.DC.CurrentColumns.LineMinY = win.DC.CursorPos.y;
        }
    },

    VerticalSeparator()
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;
        let g = this.guictx;
        let y1 = win.DC.CursorPos.y;
        let y2 = win.DC.CursorPos.y + win.DC.CurrentLineHeightMax;
        const bb = Rect.FromXY(win.DC.CursorPos.x, y1,
                            win.DC.CursorPos.x + 1, y2);
        this.itemSize(new Vec2(bb.GetWidth(), 0.));
        if (!this.itemAdd(bb, 0))
            return;

        win.DrawList.AddLine(new Vec2(bb.Min.x, bb.Min.y),
                                new Vec2(bb.Min.x, bb.Max.y),
                                g.Style.GetColor("Separator"));
        if (g.LogEnabled)
            this.LogText(" |");
    },

    SplitterBehavior(bb, id, axis, size1/*ValRef*/, size2/*ValRef*/,
                min_size1, min_size2, hover_extend, hover_visibility_delay)
    {
        let win = this.getCurrentWindow();
        let g = this.guictx;
        let item_flags_backup = win.DC.ItemFlags;
        win.DC.ItemFlags |= ItemFlags.NoNav | ItemFlags.NoNavDefaultFocus;
        let item_add = this.itemAdd(bb, id);
        win.DC.ItemFlags = item_flags_backup;
        if (!item_add)
            return false;

        let hovered = new ValRef(), held = new ValRef();
        let bb_interact = bb.Clone();
        bb_interact.Expand(axis == Axis.Y ? new Vec2(0., hover_extend) :
                                            new Vec2(hover_extend, 0));
        this.ButtonBehavior(bb_interact, id, hovered, held,
                    ButtonFlags.FlattenChildren | ButtonFlags.AllowItemOverlap);
        if (g.ActiveId != id)
            this.SetItemAllowOverlap();

        if (held.get() ||
            (g.HoveredId == id && g.HoveredIdPreviousFrame == id &&
            g.HoveredIdTimer >= hover_visibility_delay))
        {
            this.SetMouseCursor(axis == Axis.Y ? MouseCursor.ResizeNS : MouseCursor.ResizeEW);
        }

        let bb_render = bb.Clone();
        if (held.get())
        {
            let mouse_delta_2d = Vec2.Subtract(
                                    Vec2.Subtract(g.IO.MousePos, g.ActiveIdClickOffset),
                                    bb_interact.Min);
            let mouse_delta = (axis == Axis.Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

            // Minimum pane size
            let size_1_maximum_delta = Math.max(0., size1.get() - min_size1);
            let size_2_maximum_delta = Math.max(0., size2.get() - min_size2);
            if (mouse_delta < -size_1_maximum_delta)
                mouse_delta = -size_1_maximum_delta;
            if (mouse_delta > size_2_maximum_delta)
                mouse_delta = size_2_maximum_delta;

            // Apply resize
            if (mouse_delta != 0)
            {
                if (mouse_delta < 0)
                    console.assert(size1.get() + mouse_delta >= min_size1);
                if (mouse_delta > 0)
                    console.assert(size2.get() - mouse_delta >= min_size2);
                size1.set(size1.get() + mouse_delta);
                size2.set(size2.get() - mouse_delta);
                bb_render.Translate((axis == Axis.X) ?
                                new Vec2(mouse_delta, 0) :
                                new Vec2(0., mouse_delta));
                this.MarkItemEdited(id);
            }
        }

        // Render
        let col = g.Style.GetColor(held.get() ? "SeparatorActive" :
                            (hovered.get() && g.HoveredIdTimer >= hover_visibility_delay) ?
                            "SeparatorHovered" : "Separator");
        win.DrawList.AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);
        return held.get();
    },

    // lock horizontal starting position
    BeginGroup()
    {
        let g = this.guictx;
        let win = this.getCurrentWindow();
        win.DC.GroupStack.push(new LayoutGroupData(win, g)); // intialized off win & g
        win.DC.GroupOffset.x = win.DC.CursorPos.x - win.Pos.x
                                    - win.DC.ColumnsOffset.x;
        win.DC.Indent = win.DC.GroupOffset;
        win.DC.CursorMaxPos.Copy(win.DC.CursorPos);
        win.DC.CurrentLineHeight = 0;
        win.DC.CurrentLineHeightMax = 0;
        if (g.LogEnabled)
            g.LogLinePosY = -Number.MAX_VALUE; // To enforce Log carriage return
    },

    // unlock horizontal starting position + capture the whole group bounding
    // box into one "item" (so you can use IsItemHovered() or layout primitives
    // such as SameLine() on whole group, etc.)
    EndGroup()
    {
        let g = this.guictx;
        let win = this.getCurrentWindow();
        console.assert(!win.DC.GroupStack.empty(),
                    "Mismatched BeginGroup()/EndGroup() calls");

        let group_data = win.DC.GroupStack.back();
        let group_bb = new Rect(group_data.BackupCursorPos, win.DC.CursorMaxPos);
        group_bb.Max = Vec2.Max(group_bb.Min, group_bb.Max);
        win.DC.CursorPos.Copy(group_data.BackupCursorPos);
        win.DC.CursorMaxPos = Vec2.Max(group_data.BackupCursorMaxPos,
                                          win.DC.CursorMaxPos);
        win.DC.Indent = group_data.BackupIndent;
        win.DC.GroupOffset = group_data.BackupGroupOffset;
        win.DC.CurrentLineHeight = group_data.BackupCurrentLineHeight;
        win.DC.CurrentLineHeightMax = group_data.BackupCurrentLineHeightMax;
        win.DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;
        if (g.LogEnabled)
            g.LogLinePosY = -Number.MAX_VALUE; // To enforce Log carriage return

        if (group_data.AdvanceCursor)
        {
            // FIXME: Incorrect, we should grab the base offset from the
            // *first line* of the group but it is hard to obtain now.
            win.DC.CurrentLineTextBaseOffset = Math.max(win.DC.PrevLineTextBaseOffset,
                                group_data.BackupCurrentLineTextBaseOffset);
            this.itemSize(group_bb.GetSize(), 0);
            this.itemAdd(group_bb, 0);
        }

        // If the current ActiveId was declared within the boundary of our group,
        // we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc.
        // will be functional on the entire group. It would be be neater if we
        // replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but
        // would put a little more burden on individual widgets. (and if you
        // grep for LastItemId you'll notice it is only used in that context.
        if ((group_data.BackupActiveIdIsAlive != g.ActiveId) &&
            (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId) // && g.ActiveIdWindow->RootWindow == win.RootWindow)
        {
            win.DC.LastItemId = g.ActiveId;
        }
        else
        if (!group_data.BackupActiveIdPreviousFrameIsAlive &&
              g.ActiveIdPreviousFrameIsAlive) // && g.ActiveIdPreviousFrameWindow->RootWindow == win->RootWindow)
        {
            win.DC.LastItemId = g.ActiveIdPreviousFrame;
        }
        win.DC.LastItemRect = group_bb;

        win.DC.GroupStack.pop_back();

        //win->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
    },

    // cursor position in window coordinates (relative to window position)
    // User generally sees positions in window coordinates. Internally we
    // store CursorPos in absolute screen coordinates because it is more
    // convenient. Conversion happens as we pass the value to user, but it
    // makes our naming convention confusing because GetCursorPos() ==
    // (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
    GetCursorPos()
    {
        let win = this.getCurrentWindowRead();
        return new Vec2(win.DC.CursorPos.x - win.Pos.x + win.Scroll.x,
                        win.DC.CursorPos.y - win.Pos.y + win.Scroll.y);
    },

    SetCursorPos(local_pos)
    {
        let win = this.getCurrentWindow();
        win.DC.CursorPos.x = win.Pos.x - win.Scroll.x + local_pos.x;
        win.DC.CursorPos.y = win.Pos.y - win.Scroll.y + local_pos.y;
        /*
        win.DC.CursorPos = Vec2.Subtract(win.Pos,
                                Vec2.Add(win.Scroll, local_pos));
        */
        win.DC.CursorMaxPos = Vec2.Max(win.DC.CursorMaxPos,
                                       win.DC.CursorPos);
    },

    //   (some functions are using window-relative coordinates, such as:
    //    GetCursorPos, GetCursorStartPos, GetContentRegionMax,
    //    GetWindowContentRegion* etc. other functions such as
    //    GetCursorScreenPos or everything in ImDrawList::
    //    are using the main, absolute coordinate system.
    //    GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.)
    GetCursorPosX()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.CursorPos.x - win.Pos.x + win.Scroll.x;
    },

    GetCursorPosXLastLine()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.CursorPosPrevLine.x - win.Pos.x + win.Scroll.x;
    },

    GetCursorPosY()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.CursorPos.y - win.Pos.y + win.Scroll.y;
    },

    SetCursorPosX(local_x)
    {
        let win = this.getCurrentWindow();
        win.DC.CursorPos.x = win.Pos.x - win.Scroll.x + local_x;
        win.DC.CursorMaxPos.x = Math.max(win.DC.CursorMaxPos.x,
                                        win.DC.CursorPos.x);
    },

    SetCursorPosY(local_y)
    {
        let win = this.getCurrentWindow();
        win.DC.CursorPos.y = win.Pos.y - win.Scroll.y + local_y;
        win.DC.CursorMaxPos.y = Math.max(win.DC.CursorMaxPos.y,
                                         win.DC.CursorPos.y);
        if(win.DC.CursorPos.IsNaN())
        {
            console.assert(0, "hey!");
        }
    },

    SetCursorPosYAndSetupDummyPrevLine(pos_y, line_height)
    {
        // Set cursor position and a few other things so that SetScrollHereY()
        // and Columns() can work when seeking cursor.
        // FIXME: It is problematic that we have to do that here, because
        // custom/equivalent end-user code would stumble on the same issue.
        // The clipper should probably have a 4th step to display the last
        // item in a regular manner.
        this.SetCursorPosY(pos_y);
        let win = this.getCurrentWindow();
        // Setting those fields so that SetScrollHereY() can properly function
        // after the end of our clipper usage.
        win.DC.CursorPosPrevLine.y = win.DC.CursorPos.y - line_height;
        // If we end up needing more accurate data (to e.g. use SameLine) we
        // may as well make the clipper have a fourth step to let user process
        // and display the last item in their list.
        win.DC.PrevLineHeight = (line_height - this.guictx.Style.ItemSpacing.y);
        win.DC.PrevLineHeightMax = win.DC.PrevLineHeight;
        if (win.DC.CurrentColumns)
        {
            // Setting this so that cell Y position are set properly
            win.DC.CurrentColumns.LineMinY = win.DC.CursorPos.y;
        }
    },

    // initial cursor position in window/local coordinates
    GetCursorStartPos()
    {
        let win = this.getCurrentWindowRead();
        return Vec2.Subtract(win.DC.CursorStartPos, win.Pos);
    },

    // cursor position in absolute screen coordinates [0..io.DisplaySize]
    // (useful to work with ImDrawList API)
    GetCursorScreenPos()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.CursorPos.Clone();
    },

    GetCursorScreenStartPos()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.CursorStartPos;
    },

    // cursor position in absolute screen coordinates [0..io.DisplaySize]
    SetCursorScreenPos(pos)
    {
        let win = this.getCurrentWindow();
        win.DC.CursorPos.Copy(pos);
        win.DC.CursorMaxPos = Vec2.Max(win.DC.CursorMaxPos,
                                       win.DC.CursorPos);
    },

    /*---------------------------------------------------------------*/

    // Advance cursor given item size for layout.
    itemSize(size, text_offset_y=0)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (win.SkipItems)
            return;

        if(size.Max != undefined)
        {
            // we infer that size is a Rect
            size = size.GetSize();
        }

        // Always align ourselves on pixel boundaries
        const line_height = Math.max(win.DC.CurrentLineHeight, size.y);
        const text_base_offset = Math.max(win.DC.CurrentLineTextBaseOffset, text_offset_y);
        if (g.IO.KeyAlt) 
        {
            win.DrawList.AddRect(win.DC.CursorPos, 
                                 Vec2.AddXY(win.DC.CursorPos, size.x, line_height), 
                                 g.Style.GetColor("_DEBUG2"));
        }
        win.DC.CursorPosPrevLine = new Vec2(win.DC.CursorPos.x + size.x,
                                               win.DC.CursorPos.y);
        win.DC.CursorPos.x = Math.floor(win.Pos.x + win.DC.Indent.x +
                                            win.DC.ColumnsOffset.x);
        win.DC.CursorPos.y = Math.floor(win.DC.CursorPos.y + line_height +
                                            g.Style.ItemSpacing.y);
        win.DC.CursorMaxPos.x = Math.max(win.DC.CursorMaxPos.x,
                                            win.DC.CursorPosPrevLine.x);
        win.DC.CursorMaxPos.y = Math.max(win.DC.CursorMaxPos.y,
                                    win.DC.CursorPos.y-g.Style.ItemSpacing.y);
        /* NaN checks */
        if(win.DC.CursorMaxPos.IsNaN() || win.DC.CursorPos.IsNaN())
        {
            console.assert(0, "hey!");
        }
        //if (g.IO.KeyAlt) win.DrawList->AddCircle(window.DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

        win.DC.PrevLineHeight = line_height;
        win.DC.PrevLineHeightMax = Math.max(line_height, win.DC.CurrentLineHeightMax);
        win.DC.PrevLineTextBaseOffset = text_base_offset;
        win.DC.CurrentLineHeight = win.DC.CurrentLineTextBaseOffset = 0;
        win.DC.CurrentLineHeightMax = 0;

        // Horizontal layout mode
        if (win.DC.LayoutType == LayoutType.Horizontal)
            this.SameLine();
    },

    // Declare item bounding box for clipping and interaction.
    // Note that the size can be different than the one provided to ItemSize().
    // Typically, widgets that spread over available surface declare their
    // minimum size requirement to ItemSize() and then use a larger region for
    // drawing/interaction, which is passed to ItemAdd().
    itemAdd(bb, id, nav_bb=null)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (id != 0)
        {
            // Navigation processing runs prior to clipping early-out
            //  (a) So that NavInitRequest can be honored, for newly opened
            //      windows to select a default widget
            //  (b) So that we can scroll up/down past clipped items. This adds
            //      a small O(N) cost to regular navigation requests unfortunately,
            //      but it is still limited to one window. it may not scale very
            //      well for windows with ten of thousands of item, but at least
            //      NavMoveRequest is only set on user interaction, aka maximum
            //      once a frame. We could early out with
            //          "if (is_clipped && !g.NavInitRequest) return false;"
            //      but then we wouldn't be able to reach unclipped widgets.
            //     This would work if user had explicit scrolling control (e.g.
            //     mapped on a stick).
            win.DC.NavLayerActiveMaskNext |= win.DC.NavLayerCurrentMask;
            if (g.NavId == id || g.NavAnyRequest)
            {
                if (g.NavWindow.RootWindowForNav == win.RootWindowForNav)
                {
                    if (win == g.NavWindow ||
                        ((win.Flags | g.NavWindow.Flags) & WindowFlags.NavFlattened))
                    {
                        this.navProcessItem(win, nav_bb ? nav_bb: bb, id);
                    }
                }
            }
        }

        win.DC.LastItemId = id;
        win.DC.LastItemRect.Copy(bb);
        win.DC.LastItemStatusFlags = ItemStatusFlags.None;

        // Clipping test
        const is_clipped = this.isClippedEx(bb, id, false);
        if (is_clipped)
            return false;
        if (g.IO.KeyAlt) 
        {
            win.DrawList.AddRect(bb.Min, bb.Max, g.Style.GetColor("_DEBUG1"));
        }

        // We need to calculate this now to take account of the current clipping
        // rectangle (as items like Selectable may change them)
        if (this.IsMouseHoveringRect(bb.Min, bb.Max))
            win.DC.LastItemStatusFlags |= ItemStatusFlags.HoveredRect;
        return true;
    },

    isClippedEx(bb, id=0, clip_even_when_logged=false)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (!bb.Overlaps(win.ClipRect))
        {
            if (id == 0 || id != g.ActiveId)
            {
                if (clip_even_when_logged || !g.LogEnabled)
                    return true;
            }
        }
        return false;
    },

}; // end mixin

// =====================================================================================================================
// widgets/layout.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/tab.js BEGIN
// =====================================================================================================================


// TODO:
//     fix tab reordering

var TabBarFlags =
{
    None: 0,
    Reorderable: 1 << 0,
        // Allow manually dragging tabs to re-order them + New tabs are
        // appended at the end of list
    AutoSelectNewTabs: 1 << 1,   // Automatically select new tabs when they appear
    TabListPopupButton: 1 << 2,
    NoCloseWithMiddleMouseButton: 1 << 3,
        // Disable behavior of closing tabs (that are submitted with
        // p_open != NULL) with middle mouse button. You can still
        // repro this behavior on user's side with if
        // (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
    NoTabListScrollingButtons: 1 << 4,
    NoTooltip: 1 << 5,   // Disable tooltips when hovering a tab
    FittingPolicyResizeDown: 1 << 6,   // Resize tabs when they don't fit
    FittingPolicyScroll: 1 << 7,   // Add scroll buttons when tabs don't fit
};
f = TabBarFlags;
f.FittingPolicyMask_ =  f.FittingPolicyResizeDown | f.FittingPolicyScroll;
f.FittingPolicyDefault_ =  f.FittingPolicyResizeDown;

// Flags for ImGui::BeginTabItem()
var TabItemFlags =
{
    None: 0,
    UnsavedDocument: 1 << 0,
        // Append '*' to title without affecting the ID, as a convenience to
        // avoid using the ### operator. Also: tab is selected on closure and
        // closure is deferred by one frame to allow code to undo it without flicker.
    SetSelected: 1 << 1,
        // Trigger flag to programmatically make the tab selected when calling
        // BeginTabItem()
    NoCloseWithMiddleMouseButton: 1 << 2,
        // Disable behavior of closing tabs (that are submitted with
        // p_open != NULL) with middle mouse button. You can still repro this
        // behavior on user's side with if (IsItemHovered() && IsMouseClicked(2))
        // *p_open = false.
    NoPushId: 1 << 3
        // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
};

function linearSweep(current, target, speed)
{
    if (current < target)
        return Math.min(current + speed, target);
    if (current > target)
        return Math.max(current - speed, target);
    return current;
}

class TabSortItem
{
    constructor()
    {
        this.Index=-1;
        this.Width=0.;
    }
}

class TabItem
{
    constructor()
    {
        this.ID = this.Flags = 0;
        this.LastFrameVisible = this.LastFrameSelected = -1;
        this.NameOffset = -1;
        this.Offset = this.Width = this.WidthContents = 0.;
    }
}

class TabBar
{
    constructor(id)
    {
        this.Tabs = []; // TabItem
        this.ID = id;
        this.SelectedTabId = this.NextSelectedTabId = this.VisibleTabId = 0;
        this.CurrFrameVisible = this.PrevFrameVisible = -1;
        this.BarRect = null;
        this.ContentsHeight = 0;
        this.OffsetMax = this.OffsetNextTab = 0;
        this.ScrollingAnim = this.ScrollingTarget = 0;
        this.ScrollingTargetDistToVisibility = this.ScrollingSpeed = 0;
        this.Flags = TabBarFlags.None;
        this.ReorderRequestTabId = 0;
        this.ReorderRequestDir = 0;
        this.WantLayout = this.VisibleTabWasSubmitted = false;
        this.LastTabItemIdx = -1;
        this.FramePadding = null; // Vec2
        this.TabsNames = []; // for non-docking tab bar we re-append names
    }

    GetTabOrder(tab)
    {
        let item = this.Tabs.indexOf(tab);
        if(item == undefined)
        {
            console.assert(0);
        }
        return item;
    }

    GetTabName(tab)
    {
        return this.TabsNames[this.GetTabOrder(tab)];
    }
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
//-------------------------------------------------------------------------
// [BETA API] API may evolve! This code has been extracted out of the Docking branch,
// and some of the construct which are not used in Master may be left here to facilitate merging.
//-------------------------------------------------------------------------
// - BeginTabBar()
// - beginTabBarEx() [Internal]
// - EndTabBar()
// - tabBarLayout() [Internal]
// - tabBarCalcTabID() [Internal]
// - tabBarCalcMaxTabWidth() [Internal]
// - tabBarFindTabById() [Internal]
// - tabBarRemoveTab() [Internal]
// - tabBarCloseTab() [Internal]
// - tabBarScrollClamp()v
// - tabBarScrollToTab() [Internal]
// - tabBarQueueChangeTabOrder() [Internal]
// - tabBarScrollingButtons() [Internal]
// - tabBarTabListPopupButton() [Internal]
//-------------------------------------------------------------------------
var ImguiTabBarMixin =
{
   // Popups, Modals  (public methods found in imguiPopup)
    // Tab Bars, Tabs ---------------------------------------
    // [BETA API] API may evolve!

    // create and append into a TabBar
    BeginTabBar(str_id, flags=0)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (win.SkipItems)
            return false;

        let id = win.GetID(str_id);
        let tab_bar = g.TabBars[id];
        if(tab_bar == undefined)
        {
            tab_bar = new TabBar(id);
            g.TabBars[id] = tab_bar;
        }
        let tab_bar_bb = Rect.FromXY(win.DC.CursorPos.x, win.DC.CursorPos.y,
                            win.InnerClipRect.Max.x,
                            win.DC.CursorPos.y+g.FontLineHeight+g.Style.FramePadding.y*2);
        return this.beginTabBarEx(tab_bar, tab_bar_bb, flags|TabBarFlags.IsFocused);
    },

    beginTabBarEx(tab_bar, tab_bar_bb, flags)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (win.SkipItems)
            return false;

        if ((flags & TabBarFlags.DockNode) == 0)
            win.IDStack.push(tab_bar.ID);

        // Add to stack
        g.CurrentTabBarStack.push(tab_bar); //was getTabBarRefFromTabBar
        g.CurrentTabBar = tab_bar;

        if (tab_bar.CurrFrameVisible == g.FrameCount)
        {
            console.assert(0, "beginTabBarEx already called this frame");
            return true;
        }

        // When toggling back from ordered to manually-reorderable, shuffle
        // tabs to enforce the last visible order. Otherwise, the most recently
        // inserted tabs would move at the end of visible list which can be a
        // little too confusing or magic for the user.
        if ((flags & TabBarFlags.Reorderable) &&
            !(tab_bar.Flags & TabBarFlags.Reorderable) &&
            tab_bar.Tabs.length > 1 && tab_bar.PrevFrameVisible != -1)
        {
            tab_bar.Tabs.sort(this._compareTabItemsByVisibleOffset);
        }

        // Flags
        if ((flags & TabBarFlags.FittingPolicyMask_) == 0)
            flags |= TabBarFlags.FittingPolicyDefault_;
        tab_bar.Flags = flags;
        tab_bar.BarRect = tab_bar_bb; // okay to copy
        tab_bar.WantLayout = true; // Layout will be done on the first call to ItemTab()
        tab_bar.PrevFrameVisible = tab_bar.CurrFrameVisible;
        tab_bar.CurrFrameVisible = g.FrameCount;
        tab_bar.FramePadding = g.Style.FramePadding;

        // Layout
        this.itemSize(new Vec2(tab_bar.OffsetMax, tab_bar.BarRect.GetHeight()));
        win.DC.CursorPos.x = tab_bar.BarRect.Min.x;

        // Draw separator
        const col = g.Style.GetColor((flags & TabBarFlags.IsFocused) ? "TabActive" : "Tab");
        const y = tab_bar.BarRect.Max.y - 1.;
        const separator_min_x = tab_bar.BarRect.Min.x - win.WindowPadding.x;
        const separator_max_x = tab_bar.BarRect.Max.x + win.WindowPadding.x;
        win.DrawList.AddLine(new Vec2(separator_min_x, y),
                             new Vec2(separator_max_x, y), col, 1);
        return true;
    },

    _compareTabItemsByVisibleOffset(a, b)
    {
        return a.Offset - b.Offset;
    },

    tabBarCalcTabID(tabbar, label)
    {
        if (tabbar.Flags & TabBarFlags.DockNode)
        {
            let id = GetHash(label, 0);
            this.KeepAliveID(id);
            return id;
        }
        else
        {
            let win = this.guictx.CurrentWindow;
            return win.GetID(label);
        }
    },

    // only call EndTabBar() if BeginTabBar() returns true!
    EndTabBar()
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (win.SkipItems)
            return;

        let tab_bar = g.CurrentTabBar;
        if (tab_bar == null)
        {
            console.assert(tab_bar != null,  "Mismatched BeginTabBar()/EndTabBar()!");
            return; // FIXME-ERRORHANDLING
        }
        if (tab_bar.WantLayout)
            this.tabBarLayout(tab_bar);

        // Restore the last visible height if no tab is visible, this reduce
        // vertical flicker/movement when a tabs gets removed without calling
        // SetTabItemClosed().
        const tab_bar_appearing = (tab_bar.PrevFrameVisible + 1 < g.FrameCount);
        if (tab_bar.VisibleTabWasSubmitted || tab_bar.VisibleTabId == 0 || tab_bar_appearing)
            tab_bar.ContentsHeight = Math.max(win.DC.CursorPos.y - tab_bar.BarRect.Max.y, 0);
        else
            win.DC.CursorPos.y = tab_bar.BarRect.Max.y + tab_bar.ContentsHeight;

        if ((tab_bar.Flags & TabBarFlags.DockNode) == 0)
            this.PopID();

        g.CurrentTabBarStack.pop();
        g.CurrentTabBar = g.CurrentTabBarStack.length == 0 ? null :
            g.CurrentTabBarStack[g.CurrentTabBarStack.length-1]; // was GetTabBarFromTabBarRef
    },

    // create a Tab. Returns true if the Tab is selected.
    BeginTabItem(label, p_open=null, flags=0)
    {
        let g = this.guictx;
        if (g.CurrentWindow.SkipItems)
            return false;

        let tabbar = g.CurrentTabBar;
        if (tabbar == null)
        {
            console.assert(tabbar, "Needs to be called between BeginTabBar() and EndTabBar()!");
            return false; // FIXME-ERRORHANDLING
        }
        let ret = this.tabItemEx(tabbar, label, p_open, flags);
        if (ret && !(flags & TabItemFlags.NoPushId))
        {
            let tab = tabbar.Tabs[tabbar.LastTabItemIdx];
            // We already hashed 'label' so push into the ID stack directly
            // nstead of doing another hash through PushID(label)
            g.CurrentWindow.IDStack.push(tab.ID);
        }
        return ret;
    },

    // only call EndTabItem() if BeginTabItem() returns true!
    EndTabItem()
    {
        let g = this.guictx;
        if (g.CurrentWindow.SkipItems)
            return;

        let tab_bar = g.CurrentTabBar;
        if (tab_bar == null)
        {
            console.assert(tab_bar != null,  "Needs to be called between BeginTabBar() and EndTabBar()!");
            return;
        }
        console.assert(tab_bar.LastTabItemIdx >= 0);
        let tab = tab_bar.Tabs[tab_bar.LastTabItemIdx];
        if (!(tab.Flags & TabItemFlags.NoPushId))
            g.CurrentWindow.IDStack.pop();
    },

    tabItemEx(tab_bar, label, p_open, flags)
    {
        // Layout whole tab bar if not already done
        if (tab_bar.WantLayout)
            this.tabBarLayout(tab_bar);

        let g = this.guictx;
        let win = g.CurrentWindow;
        if (win.SkipItems)
            return false;

        const style = g.Style;
        const id = this.tabBarCalcTabID(tab_bar, label);

        // If the user called us with *p_open == false, we early out and
        // don't render. We make a dummy call to ItemAdd() so that attempts
        // to use a contextual popup menu with an implicit ID won't use an
        // older ID.
        if (p_open && !p_open.get())
        {
            this.PushItemFlag(ItemFlags.NoNav | ItemFlags.NoNavDefaultFocus, true);
            this.itemAdd(new Rect(), id);
            this.PopItemFlag();
            return false;
        }

        // Calculate tab contents size
        let size = this.tabItemCalcSize(label, p_open != null);

        // Acquire tab data
        let tab = this.tabBarFindTabByID(tab_bar, id);
        let tab_is_new = false;
        if (tab == null)
        {
            tab = new TabItem();
            tab.ID = id;
            tab.Width = size.x;
            tab_is_new = true;
            tab_bar.Tabs.push(tab);
        }
        tab_bar.LastTabItemIdx = tab_bar.Tabs.indexOf(tab);
        tab.WidthContents = size.x;

        if (p_open == null)
            flags |= TabItemFlags.NoCloseButton;

        const tab_bar_appearing = (tab_bar.PrevFrameVisible + 1 < g.FrameCount);
        const tab_bar_focused = (tab_bar.Flags & TabBarFlags.IsFocused) != 0;
        const tab_appearing = (tab.LastFrameVisible + 1 < g.FrameCount);
        tab.LastFrameVisible = g.FrameCount;
        tab.Flags = flags;

        // Append name with zero-terminator
        tab.NameOffset = tab_bar.TabsNames.length;
        tab_bar.TabsNames.push(label);

        // If we are not reorderable, always reset offset based on submission order.
        // (We already handled layout and sizing using the previous known order,
        // but sizing is not affected by order!)
        if (!tab_appearing && !(tab_bar.Flags & TabBarFlags.Reorderable))
        {
            tab.Offset = tab_bar.OffsetNextTab;
            tab_bar.OffsetNextTab += tab.Width + g.Style.ItemInnerSpacing.x;
        }

        // Update selected tab
        if (tab_appearing && (tab_bar.Flags & TabBarFlags.AutoSelectNewTabs) &&
            tab_bar.NextSelectedTabId == 0)
        {
            if (!tab_bar_appearing || tab_bar.SelectedTabId == 0)
                tab_bar.NextSelectedTabId = id;  // New tabs gets activated
        }
        // SetSelected can only be passed on explicit tab bar
        if ((flags & TabItemFlags.SetSelected) && (tab_bar.SelectedTabId != id))
        {
            tab_bar.NextSelectedTabId = id;
        }

        // Lock visibility
        let tab_contents_visible = (tab_bar.VisibleTabId == id);
        if (tab_contents_visible)
            tab_bar.VisibleTabWasSubmitted = true;

        // On the very first frame of a tab bar we let first tab contents be
        // visible to minimize appearing glitches
        if (!tab_contents_visible && tab_bar.SelectedTabId == 0 && tab_bar_appearing)
        {
            if (tab_bar.Tabs.length == 1 && !(tab_bar.Flags & TabBarFlags.AutoSelectNewTabs))
                tab_contents_visible = true;
        }

        if (tab_appearing && !(tab_bar_appearing && !tab_is_new))
        {
            this.PushItemFlag(ItemFlags.NoNav | ItemFlags.NoNavDefaultFocus, true);
            this.itemAdd(new Rect(), id);
            this.PopItemFlag();
            return tab_contents_visible;
        }

        if (tab_bar.SelectedTabId == id)
            tab.LastFrameSelected = g.FrameCount;

        // Backup current layout position
        const backup_main_cursor_pos = win.DC.CursorPos;

        // Layout
        size.x = tab.Width;
        win.DC.CursorPos = Vec2.AddXY(tab_bar.BarRect.Min,
                        Math.floor(tab.Offset - tab_bar.ScrollingAnim), 0.0);
        let pos = win.DC.CursorPos;
        let bb = new Rect(pos, Vec2.Add(pos, size));

        // We don't have CPU clipping primitives to clip the CloseButton (until
        // it becomes a texture), so need to add an extra draw call (temporary
        // in the case of vertical animation)
        let want_clip_rect = (bb.Min.x < tab_bar.BarRect.Min.x) ||
                              (bb.Max.x >= tab_bar.BarRect.Max.x);
        if (want_clip_rect)
        {
            this.PushClipRect(
                    new Vec2(Math.max(bb.Min.x, tab_bar.BarRect.Min.x), bb.Min.y - 1),
                    new Vec2(tab_bar.BarRect.Max.x, bb.Max.y),
                    true);
        }

        this.itemSize(bb, style.FramePadding.y);
        if (!this.itemAdd(bb, id))
        {
            if (want_clip_rect)
                this.PopClipRect();
            win.DC.CursorPos = backup_main_cursor_pos;
            return tab_contents_visible;
        }

        // Click to Select a tab
        let button_flags = (ButtonFlags.PressedOnClick | ButtonFlags.AllowItemOverlap);
        if (g.DragDropActive)
            button_flags |= ButtonFlags.PressedOnDragDropHold;
        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(bb, id, hovered, held, button_flags);
        if (pressed)
            tab_bar.NextSelectedTabId = id;
        hovered |= (g.HoveredId == id);

        // Allow the close button to overlap unless we are dragging (in which
        // case we don't want any overlapping tabs to be hovered)
        if (!held.get())
            this.SetItemAllowOverlap();

        // Drag and drop: re-order tabs
        if (held && !tab_appearing && this.IsMouseDragging(0) && 
            (tab_bar.Flags & TabBarFlags.Reorderable))
        {
            if (!g.DragDropActive)
            {
                // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
                if (g.IO.MouseDelta.x < 0 && g.IO.MousePos.x < bb.Min.x)
                {
                    if (tab_bar.Flags & TabBarFlags.Reorderable)
                        this.tabBarQueueChangeTabOrder(tab_bar, tab, -1);
                }
                else
                if (g.IO.MouseDelta.x > 0 && g.IO.MousePos.x > bb.Max.x)
                {
                    if (tab_bar.Flags & TabBarFlags.Reorderable)
                        this.tabBarQueueChangeTabOrder(tab_bar, tab, +1);
                }
            }
        }

        if(false)
        {
            // XXX: pending evaluation/implementation of ForegroundDrawList
            if (hovered && g.HoveredIdNotActiveTimer > 0.50&&
                bb.GetWidth() < tab.WidthContents)
            {
                // Enlarge tab display when hovering
                bb.Max.x = bb.Min.x + Math.floor(Vec1.Lerp(bb.GetWidth(), tab.WidthContents,
                                                Vec1.Saturate((g.HoveredIdNotActiveTimer - 0.4)*6)));
                let display_draw_list = this.GetForegroundDrawList(win);
                this.tabItemBackground(display_draw_list, bb, flags,
                                    style.GetColor("TitleBgActive"));
            }
        }

        // Render tab shape
        let drawList = win.DrawList;
        const tab_col = style.GetColor((held.get() || hovered) ? "TabHovered" :
                tab_contents_visible ? (tab_bar_focused ? "TabActive" : "TabUnfocusedActive") :
                        (tab_bar_focused ? "Tab" : "TabUnfocused"));
        this.tabItemBackground(drawList, bb, flags, tab_col);
        this.renderNavHighlight(bb, id);

        // Select with right mouse button. This is so the common idiom for
        // context menu automatically highlight the current widget.
        const hovered_unblocked = this.IsItemHovered(HoveredFlags.AllowWhenBlockedByPopup);
        if (hovered_unblocked && 
            (this.IsMouseClicked(1) || this.IsMouseReleased(1))
           )
        {
            tab_bar.NextSelectedTabId = id;
        }

        if (tab_bar.Flags & TabBarFlags.NoCloseWithMiddleMouseButton)
            flags |= TabItemFlags.NoCloseWithMiddleMouseButton;

        // Render tab label, process close button
        const close_button_id = p_open ? win.GetID("" + id + 1) : 0;
        let just_closed = this.tabItemLabelAndCloseButton(drawList, bb, flags,
                                tab_bar.FramePadding, label, id, close_button_id);
        if (just_closed && p_open != null)
        {
            p_open.set(false);
            this.tabBarCloseTab(tab_bar, tab);
        }

        // Restore main window position so user can draw there
        if (want_clip_rect)
            this.PopClipRect();
        win.DC.CursorPos = backup_main_cursor_pos;

        // Tooltip (FIXME: Won't work over the close button because
        // ItemOverlap systems messes up with HoveredIdTimer). We test
        // IsItemHovered() to discard e.g. when another item is active
        // or drag and drop over the tab bar (which g.HoveredId ignores)
        if (g.HoveredId == id && !held && g.HoveredIdNotActiveTimer > 0.5
                && this.IsItemHovered())
        {
            if (!(tab_bar.Flags & TabBarFlags.NoTooltip))
                this.SetTooltip(label);
        }
        return tab_contents_visible;
    },

    // notify TabBar or Docking system of a closed tab/window ahead
    // (useful to reduce visual flicker on reorderable tab bars).
    // For tab-bar: call after BeginTabBar() and before Tab submissions.
    // Otherwise call with a window name.
    SetTabItemClosed(_tab_or_docked_window_label)
    {
    },

    // This is called only once a frame before by the first call to ItemTab()
    // The reason we're not calling it in BeginTabBar() is to leave a chance
    // to the user to call the SetTabItemClosed() functions.
    tabBarLayout(tab_bar)
    {
        let g = this.guictx;
        tab_bar.WantLayout = false;

        // Garbage collect
        let tab_dst_n = 0;
        for (let tab_src_n = 0; tab_src_n < tab_bar.Tabs.length; tab_src_n++)
        {
            let tab = tab_bar.Tabs[tab_src_n];
            if (tab.LastFrameVisible < tab_bar.PrevFrameVisible)
            {
                if (tab.ID == tab_bar.SelectedTabId)
                    tab_bar.SelectedTabId = 0;
                continue;
            }
            if (tab_dst_n != tab_src_n)
                tab_bar.Tabs[tab_dst_n] = tab_bar.Tabs[tab_src_n];
            tab_dst_n++;
        }
        if (tab_bar.Tabs.length != tab_dst_n)
            tab_bar.Tabs.length = tab_dst_n; // resize

        // Setup next selected tab
        let scrollTrackSelTabId = 0;
        if (tab_bar.NextSelectedTabId)
        {
            tab_bar.SelectedTabId = tab_bar.NextSelectedTabId;
            tab_bar.NextSelectedTabId = 0;
            scrollTrackSelTabId = tab_bar.SelectedTabId;
        }

        // Process order change request (we could probably process it when
        // requested but it's just saner to do it in a single spot).
        if (tab_bar.ReorderRequestTabId != 0)
        {
            let tab1 = this.tabBarFindTabByID(tab_bar, tab_bar.ReorderRequestTabId);
            if(tab1)
            {
                //IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable);
                // <- this may happen when using debug tools
                let tab2_order = tab_bar.GetTabOrder(tab1) + tab_bar.ReorderRequestDir;
                if (tab2_order >= 0 && tab2_order < tab_bar.Tabs.length)
                {
                    let tab2 = tab_bar.Tabs[tab2_order];
                    tab_bar.Tabs[tab2_order] = tab1;
                    tab_bar.Tabs[tab_bar.ReqorderRequestTabId] = tab2;
                    if (tab2.ID == tab_bar.SelectedTabId)
                        scrollTrackSelTabId = tab2.ID;
                }
                if (tab_bar.Flags & TabBarFlags.SaveSettings)
                    this.MarkIniSettingsDirty();
            }
            tab_bar.ReorderRequestTabId = 0;
        }

        // Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
        const tab_list_popup_button = (tab_bar.Flags & TabBarFlags.TabListPopupButton) != 0;
        if (tab_list_popup_button)
        {
            // NB: Will alter BarRect.Max.x!
            let tab_to_select = this.tabBarTabListPopupButton(tab_bar);
            if (tab_to_select)
                scrollTrackSelTabId = tab_bar.SelectedTabId = tab_to_select.ID;
        }

        let widthBuffer = g.TabSortByWidthBuffer;
        widthBuffer.length = tab_bar.Tabs.length; // resize

        // Compute ideal widths
        let widthTotal = 0.;
        let recentTab = null;
        let foundSelTabID = false;
        for (let tab_n = 0; tab_n < tab_bar.Tabs.length; tab_n++)
        {
            let tab = tab_bar.Tabs[tab_n];
            console.assert(tab.LastFrameVisible >= tab_bar.PrevFrameVisible);

            if (recentTab == null ||
                recentTab.LastFrameSelected < tab.LastFrameSelected)
            {
                recentTab = tab;
            }
            if (tab.ID == tab_bar.SelectedTabId)
                foundSelTabID = true;

            // Refresh tab width immediately, otherwise changes of style e.g.
            // style.FramePadding.x would noticeably lag in the tab bar.
            // Additionally, when using TabBarAddTab() to manipulate tab bar
            // order we occasionally insert new tabs that don't have a width yet,
            // and we cannot wait for the next BeginTabItem() call. We cannot
            // compute this width within TabBarAddTab() because font size depends
            // on the active window.
            const tab_name = tab_bar.GetTabName(tab);
            tab.WidthContents = this.tabItemCalcSize(tab_name,
                    (tab.Flags & TabItemFlags.NoCloseButton) ? false : true).x;

            widthTotal += (tab_n > 0 ? g.Style.ItemInnerSpacing.x : 0) + tab.WidthContents;

            // Store data so we can build an array sorted by width if we need to shrink tabs down
            let si = widthBuffer[tab_n];
            if(si == null)
            {
                si = new TabSortItem();
                widthBuffer[tab_n] = si;
            }
            si.Index = tab_n;
            si.Width = tab.WidthContents;
        }
        // Compute width
        const width_avail = tab_bar.BarRect.GetWidth();
        let width_excess = (width_avail < widthTotal) ? (widthTotal - width_avail) : 0;
        if (width_excess > 0 && (tab_bar.Flags & TabBarFlags.FittingPolicyResizeDown))
        {
            // If we don't have enough room, resize down the largest tabs first
            if (tab_bar.Tabs.length > 1)
            {
                widthBuffer.sort(this.tabBarSortItemComparer);
            }
            let tab_count_same_width = 1;
            while (width_excess > 0 &&
                    tab_count_same_width < tab_bar.Tabs.length)
            {
                while (tab_count_same_width < tab_bar.Tabs.length &&
                        widthBuffer[0].Width == widthBuffer[tab_count_same_width].Width)
                {
                    tab_count_same_width++;
                }
                let width_to_remove_per_tab_max = (tab_count_same_width < tab_bar.Tabs.length) ?
                        (widthBuffer[0].Width - widthBuffer[tab_count_same_width].Width) :
                        (widthBuffer[0].Width - 1);
                let width_to_remove_per_tab = Math.min(width_excess / tab_count_same_width, width_to_remove_per_tab_max);
                for (let tab_n = 0; tab_n < tab_count_same_width; tab_n++)
                    widthBuffer[tab_n].Width -= width_to_remove_per_tab;
                width_excess -= width_to_remove_per_tab * tab_count_same_width;
            }
            for (let tab_n=0; tab_n < tab_bar.Tabs.length; tab_n++)
            {
                tab_bar.Tabs[widthBuffer[tab_n].Index].Width =
                            Math.floor(widthBuffer[tab_n].Width);
            }
        }
        else
        {
            const tab_max_width = this.tabBarCalcMaxTabWidth();
            for (let tab_n = 0; tab_n < tab_bar.Tabs.length; tab_n++)
            {
                let tab = tab_bar.Tabs[tab_n];
                tab.Width = Math.min(tab.WidthContents, tab_max_width);
            }
        }
        // Layout all active tabs
        let offset_x = 0.;
        for (let tab_n=0; tab_n<tab_bar.Tabs.length; tab_n++)
        {
            let tab = tab_bar.Tabs[tab_n];
            tab.Offset = offset_x;
            if (scrollTrackSelTabId == 0 && g.NavJustMovedToId == tab.ID)
                scrollTrackSelTabId = tab.ID;
            offset_x += tab.Width + g.Style.ItemInnerSpacing.x;
        }
        tab_bar.OffsetMax = Math.max(offset_x - g.Style.ItemInnerSpacing.x, 0);
        tab_bar.OffsetNextTab = 0;

        // Horizontal scrolling buttons
        const scrolling_buttons = (tab_bar.OffsetMax > tab_bar.BarRect.GetWidth() &&
                                    tab_bar.Tabs.length > 1) &&
                                !(tab_bar.Flags & TabBarFlags.NoTabListScrollingButtons) &&
                                (tab_bar.Flags & TabBarFlags.FittingPolicyScroll);
        if (scrolling_buttons)
        {
            // NB: Will alter BarRect.Max.x!
            let tab_to_select = this.tabBarScrollingButtons(tab_bar);
            if (tab_to_select)
            {
                scrollTrackSelTabId =
                tab_bar.SelectedTabId = tab_to_select.ID;
            }
        }

        // If we have lost the selected tab, select the next most recently
        // active one
        if (foundSelTabID == false)
            tab_bar.SelectedTabId = 0;
        if (tab_bar.SelectedTabId == 0 && tab_bar.NextSelectedTabId == 0 && recentTab != null)
            scrollTrackSelTabId = tab_bar.SelectedTabId = recentTab.ID;

        // Lock in visible tab
        tab_bar.VisibleTabId = tab_bar.SelectedTabId;
        tab_bar.VisibleTabWasSubmitted = false;

        // Update scrolling
        if (scrollTrackSelTabId)
        {
            let scrollTrackSel = this.tabBarFindTabByID(tab_bar, scrollTrackSelTabId);
            if (scrollTrackSel)
                this.tabBarScrollToTab(tab_bar, scrollTrackSel);
        }
        tab_bar.ScrollingAnim = this.tabBarScrollClamp(tab_bar, tab_bar.ScrollingAnim);
        tab_bar.ScrollingTarget = this.tabBarScrollClamp(tab_bar, tab_bar.ScrollingTarget);
        if (tab_bar.ScrollingAnim != tab_bar.ScrollingTarget)
        {
            // Scrolling speed adjust itself so we can always reach our
            // target in 1/3 seconds. Teleport if we are aiming far off
            // the visible line
            tab_bar.ScrollingSpeed = Math.max(tab_bar.ScrollingSpeed, 70*g.FontSize);
            tab_bar.ScrollingSpeed = Math.max(tab_bar.ScrollingSpeed,
                    Math.abs(tab_bar.ScrollingTarget-tab_bar.ScrollingAnim)/0.3);
            const teleport = (tab_bar.PrevFrameVisible + 1 < g.FrameCount) ||
                    (tab_bar.ScrollingTargetDistToVisibility > 10*g.FontSize);
            tab_bar.ScrollingAnim = teleport ? tab_bar.ScrollingTarget :
                linearSweep(tab_bar.ScrollingAnim, tab_bar.ScrollingTarget,
                            g.IO.DeltaTime * tab_bar.ScrollingSpeed);
        }
        else
        {
            tab_bar.ScrollingSpeed = 0.;
        }
        // Clear name buffers
        if ((tab_bar.Flags & TabBarFlags.DockNode) == 0)
            tab_bar.TabsNames.length = 0; // resize
    },

    tabBarCalcMaxTabWidth()
    {
        return this.guictx.FontSize * 20;
    },

    tabBarFindTabByID(tabbar, tabid)
    {
        if(tabid != 0)
        {
            for(let n=0;n<tabbar.Tabs.length;n++)
            {
                if(tabbar.Tabs[n].ID == tabid)
                    return tabbar.Tabs[n];
            }
        }
        return null;
    },

    tabBarCloseTab(tabbar, tab)
    {
        if ((tabbar.VisibleTabId == tab.ID) &&
            !(tab.Flags & TabItemFlags.UnsavedDocument))
        {
            // This will remove a frame of lag for selecting another tab on closure.
            // However we don't run it in the case where the 'Unsaved' flag is
            // set, so user gets a chance to fully undo the closure
            tab.LastFrameVisible = -1;
            tabbar.SelectedTabId = tabbar.NextSelectedTabId = 0;
        }
        else
        if ((tabbar.VisibleTabId != tab.ID) &&
            (tab.Flags & TabItemFlags.UnsavedDocument))
        {
            // Actually select before expecting closure
            tabbar.NextSelectedTabId = tab.ID;
        }
    },

    tabBarQueueChangeTabOrder(tabbar, tab, dir)
    {
        console.assert(dir == -1 || dir == +1);
        console.assert(tabbar.ReorderRequestTabId == 0);
        tabbar.ReorderRequestTabId = tab.ID;
        tabbar.ReorderRequestDir = dir;
    },

    tabBarScrollClamp(tabbar, scrolling)
    {
        scrolling = Math.min(scrolling, tabbar.OffsetMax-tabbar.BarRect.GetWidth());
        return Math.max(scrolling, 0);
    },

    tabBarScrollToTab(tabbar, tab)
    {
        let g = this.guictx;
        // When to scroll to make Tab N+1 visible always make a bit of N
        // visible to suggest more scrolling area (since we don't have a scrollbar)
        let margin = g.FontSize * 1;
        let order = tabbar.GetTabOrder(tab);
        let tab_x1 = tab.Offset + (order > 0 ? -margin : 0);
        let tab_x2 = tab.Offset + tab.Width + (order + 1 < tabbar.Tabs.length ? margin : 1);
        tabbar.ScrollingTargetDistToVisibility = 0;
        if (tabbar.ScrollingTarget > tab_x1)
        {
            tabbar.ScrollingTargetDistToVisibility = Math.max(tabbar.ScrollingAnim - tab_x2, 0);
            tabbar.ScrollingTarget = tab_x1;
        }
        else
        if (tabbar.ScrollingTarget < tab_x2 - tabbar.BarRect.GetWidth())
        {
            let w = tabbar.BarRect.GetWidth();
            tabbar.ScrollingTargetDistToVisibility = Math.max((tab_x1 - w) - tabbar.ScrollingAnim, 0.);
            tabbar.ScrollingTarget = tab_x2 - w;
        }
    },

    tabItemCalcSize(label, hasCloseButton)
    {
        let g = this.guictx;
        if(label == undefined)
        {
            console.assert(0);
            label = "Error";
        }
        let labelSize = this.CalcTextSize(label, true/*hide text after ##*/);
        let size = new Vec2(labelSize.x + g.Style.FramePadding.x,
                            labelSize.y + g.Style.FramePadding.y * 2);
        size.x += g.Style.FramePadding.x + 1;
        if (hasCloseButton)
        {
            size.x += (g.Style.ItemInnerSpacing.x + g.FontSize); 
            // We use FontSize (Y) intentionally to fit the close button circle.
        }

        size.x = Math.min(size.x, this.tabBarCalcMaxTabWidth());
        return size;
    },

    tabItemBackground(drawlist, bb, itemflags, col)
    {
        // While rendering tabs, we trim 1 pixel off the top of our bounding
        // box so they can fit within a regular frame height while looking
        // "detached" from it.
        let g = this.guictx;
        const width = bb.GetWidth();
        console.assert(width > 0.);
        const rounding = Math.max(0, Math.min(g.Style.TabRounding, width * 0.5 - 1));
        const y1 = bb.Min.y + 1;
        const y2 = bb.Max.y - 1;
        drawlist.PathLineTo(new Vec2(bb.Min.x, y2));
        drawlist.PathArcToFast(new Vec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);
        drawlist.PathArcToFast(new Vec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);
        drawlist.PathLineTo(new Vec2(bb.Max.x, y2));
        drawlist.PathFillConvex(col);
        if (g.Style.TabBorderSize > 0.)
        {
            drawlist.PathLineTo(new Vec2(bb.Min.x + 0.5, y2));
            drawlist.PathArcToFast(new Vec2(bb.Min.x + rounding + 0.5,
                                            y1 + rounding + 0.5),
                                  rounding, 6, 9);
            drawlist.PathArcToFast(new Vec2(bb.Max.x - rounding - 0.5,
                                            y1 + rounding + 0.5),
                                  rounding, 9, 12);
            drawlist.PathLineTo(new Vec2(bb.Max.x - 0.5, y2));
            drawlist.PathStroke(g.Style.GetColor("Border"), false, g.Style.TabBorderSize);
        }
    },

    // Render text label (with custom clipping) + Unsaved Document marker + Close Button logic
    // We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.
    tabItemLabelAndCloseButton(drawlist, bb, flags, framepadding, label,
                                tabid, closebuttonid)
    {
        let g = this.guictx;
        let labelSize = this.CalcTextSize(label, true);
        // Render text label (with clipping + alpha gradient) + unsaved marker
        const TAB_UNSAVED_MARKER = "*";
        let text_pixel_clip_bb = Rect.FromXY(bb.Min.x + framepadding.x,
                                             bb.Min.y + framepadding.y,
                                             bb.Max.x - framepadding.x,
                                             bb.Max.y);
        if (flags & TabItemFlags.UnsavedDocument)
        {
            text_pixel_clip_bb.Max.x -= this.CalcTextSize(TAB_UNSAVED_MARKER, null, false).x;
            let unsaved_marker_pos = new Vec2(
                    Math.min(bb.Min.x+framepadding.x+labelSize.x+2,
                             text_pixel_clip_bb.Max.x),
                    bb.Min.y+framepadding.y+Math.floor(-g.FontLineHeight * 0.25));
            this.renderTextClippedEx(drawlist, unsaved_marker_pos,
                                    Vec2.Subtract(bb.Max,framepadding),
                                    TAB_UNSAVED_MARKER, null, null);
        }
        let text_ellipsis_clip_bb = text_pixel_clip_bb.Clone();

        // Close Button
        // We are relying on a subtle and confusing distinction between
        // 'hovered' and 'g.HoveredId' which happens because we are using
        // ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
        //  'hovered' will be true when hovering the Tab but NOT when
        //      hovering the close button
        //  'g.HoveredId==id' will be true when hovering the Tab including
        //      when hovering the close button
        //  'g.ActiveId==close_button_id' will be true when we are holding
        //      on the close button, in which case both hovered booleans are false
        let close_button_pressed = false;
        let close_button_visible = false;
        if (closebuttonid != 0)
        {
            if (g.HoveredId == tabid || g.HoveredId == closebuttonid ||
                g.ActiveId == closebuttonid)
            {
                close_button_visible = true;
            }
        }
        if (close_button_visible)
        {
            let last_item_backup = new ItemHoveredDataBackup(this.guictx);
            const close_button_sz = g.FontSize * 0.5;
            if (this.CloseButton(closebuttonid,
                    new Vec2(bb.Max.x - framepadding.x - close_button_sz,
                             bb.Min.y + framepadding.y + close_button_sz),
                             close_button_sz))
            {
                close_button_pressed = true;
            }
            last_item_backup.Restore();

            // Close with middle mouse button
            if (!(flags & TabItemFlags.NoCloseWithMiddleMouseButton) &&
                this.IsMouseClicked(2))
            {
                close_button_pressed = true;
            }
            text_pixel_clip_bb.Max.x -= close_button_sz * 2.;
        }
        // Label with ellipsis
        // FIXME: This should be extracted into a helper but the use of
        // text_pixel_clip_bb and !close_button_visible makes it tricky to
        // abstract at the moment
        //const label_display_end = FindRenderedTextEnd(label);
        if (labelSize.x > text_ellipsis_clip_bb.GetWidth())
        {
            const ellipsis_dot_count = 3;
            const ellipsis_width = (1. + 1.) * ellipsis_dot_count - 1.;
            const maxwidth = text_ellipsis_clip_bb.GetWidth()-ellipsis_width+1;
            let labelClippedX = g.Font.CalcTextSizeA(maxwidth, -1, label).x;

            // nb: could add ellipses
            // console.assert(0, "need to clip label: " + labelClippedX);
            this.renderTextClippedEx(drawlist, text_pixel_clip_bb.Min,
                        text_pixel_clip_bb.Max, label, null);
        }
        else
        {
            this.renderTextClippedEx(drawlist, text_pixel_clip_bb.Min,
                        text_pixel_clip_bb.Max, label, null);
        }
        return close_button_pressed;
    },

    tabBarTabListPopupButton(tab_bar)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;

        // We use g.Style.FramePadding.y to match the square ArrowButton size
        const tab_list_popup_button_width = g.FontLineHeight + g.Style.FramePadding.y;
        const backup_cursor_pos = win.DC.CursorPos;
        win.DC.CursorPos = new Vec2(tab_bar.BarRect.Min.x - g.Style.FramePadding.y,
                                    tab_bar.BarRect.Min.y);
        tab_bar.BarRect.Min.x += tab_list_popup_button_width;

        let arrow_col = g.Style.Colors["Text"];
        arrow_col.w *= 0;
        this.PushStyleColor("Text", arrow_col);
        this.PushStyleColor("Button", Color.rgba(0,0,0,0));
        let open = this.BeginCombo("##v", null, ComboFlags.NoPreview);
        this.PopStyleColor(2);

        let tab_to_select = null;
        if (open)
        {
            for (let tab_n = 0; tab_n < tab_bar.Tabs.length; tab_n++)
            {
                let tab = tab_bar.Tabs[tab_n];
                let tab_name = tab_bar.GetTabName(tab);
                if (this.Selectable(tab_name, tab_bar.SelectedTabId == tab.ID))
                    tab_to_select = tab;
            }
            this.EndCombo();
        }

        win.DC.CursorPos = backup_cursor_pos;
        return tab_to_select;
    },

    tabBarScrollingButtons(tab_bar)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;

        const arrow_button_size = new Vec2(g.FontSize - 2,
                                    g.FontSize + g.Style.FramePadding.y * 2);
        const scrolling_buttons_width = arrow_button_size.x * 2;

        const backup_cursor_pos = win.DC.CursorPos.Clone();
        //win.DrawList.AddRect(new Vec2(tab_bar.BarRect.Max.x - scrolling_buttons_width, tab_bar.BarRect.Min.y), new Vec2(tab_bar.BarRect.Max.x, tab_bar.BarRect.Max.y), IM_COL32(255,0,0,255));

        const avail_bar_rect = tab_bar.BarRect;
        let want_clip_rect = !avail_bar_rect.Contains(
                                new Rect(win.DC.CursorPos,
                                    Vec2.AddXY(win.DC.CursorPos,
                                            scrolling_buttons_width, 0)
                                       ));
        if (want_clip_rect)
        {
            this.PushClipRect(tab_bar.BarRect.Min,
                               Vec2.AddXY(tab_bar.BarRect.Max,
                                    g.Style.ItemInnerSpacing.x, 0),
                              true);
        }

        let tab_to_select = null;

        let select_dir = 0;
        const arrow_col = g.Style.Colors.Text;
        arrow_col.w *= 0.5;

        this.PushStyleColor("Text", arrow_col);
        this.PushStyleColor("Button", Colors.clear);
        const backup_repeat_delay = g.IO.KeyRepeatDelay;
        const backup_repeat_rate = g.IO.KeyRepeatRate;
        g.IO.KeyRepeatDelay = 0.25;
        g.IO.KeyRepeatRate = 0.200;
        win.DC.CursorPos = new Vec2(tab_bar.BarRect.Max.x - scrolling_buttons_width,
                                    tab_bar.BarRect.Min.y);
        if (this.ArrowButtonEx("##<", Dir.Left, arrow_button_size,
                        ButtonFlags.PressedOnClick | ButtonFlags.Repeat))
            select_dir = -1;
        win.DC.CursorPos = new Vec2(tab_bar.BarRect.Max.x - scrolling_buttons_width + arrow_button_size.x,
                                    tab_bar.BarRect.Min.y);
        if (this.ArrowButtonEx("##>", Dir.Right, arrow_button_size,
                        ButtonFlags.PressedOnClick | ButtonFlags.Repeat))
            select_dir = +1;
        this.PopStyleColor(2);
        g.IO.KeyRepeatRate = backup_repeat_rate;
        g.IO.KeyRepeatDelay = backup_repeat_delay;

        if (want_clip_rect)
            this.PopClipRect();

        if (select_dir != 0)
        {
            let tab_item = this.TabBarFindTabByID(tab_bar, tab_bar.SelectedTabId);
            if (tab_item)
            {
                let selected_order = tab_bar.GetTabOrder(tab_item);
                let target_order = selected_order + select_dir;
                // If we are at the end of the list, still scroll to make our
                // tab visible
                let it = (target_order >= 0 && target_order < tab_bar.Tabs.length) ?
                            target_order : selected_order;
                tab_to_select = tab_bar.Tabs[it];
            }
        }
        win.DC.CursorPos = backup_cursor_pos;
        tab_bar.BarRect.Max.x -= scrolling_buttons_width + 1;
        return tab_to_select;
    },

};
// =====================================================================================================================
// widgets/tab.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/listbox.js BEGIN
// =====================================================================================================================


class ListClipper
{
    constructor(imgui, items_count=-1, items_height=-1)
    {
        console.assert(imgui);
        this.imgui = imgui;
        this.Begin(items_count, items_height);
    }

    Begin(count, items_height=-1)
    {
        this.StartPosY = this.imgui.GetCursorPosY();
        this.ItemsHeight = items_height;
        this.ItemsCount = count;
        this.StepNo = 0;
        this.DisplayEnd = this.DisplayStart = -1;
        if (this.ItemsHeight > 0)
        {
            // calculate how many to clip/display
            let out = this.imgui.CalcListClipping(this.ItemsCount, this.ItemsHeight);
            this.DisplayStart = out[0];
            this.DisplayEnd = out[1];
            if (this.DisplayStart > 0)
            {
                // advance cursor
                this.imgui.SetCursorPosYAndSetupDummyPrevLine(
                    this.StartPosY + this.DisplayStart * this.ItemsHeight,
                    this.ItemsHeight);
            }
            this.StepNo = 2;
        }
    }

    End()
    {
        if (this.ItemsCount < 0)
            return;
        // In theory here we should assert
        //      GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight
        // but it feels saner to just seek at End and not assert/crash the user.
        if (this.ItemsCount < Number.MAX_SAFE_INTEGER)
        {
            this.imgui.SetCursorPosYAndSetupDummyPrevLine(
                this.StartPosY + this.ItemsCount * this.ItemsHeight,
                this.ItemsHeight); // advance cursor
        }
        this.ItemsCount = -1;
        this.StepNo = 3;
    }

    Step()
    {
        if (this.ItemsCount == 0 || this.imgui.getCurrentWindowRead().SkipItems)
        {
            this.ItemsCount = -1;
            return false;
        }
        // Step 0: the clipper let you process the first element, regardless of
        // it being visible or not, so we can measure the element height.
        if (this.StepNo == 0)
        {
            this.DisplayStart = 0;
            this.DisplayEnd = 1;
            this.StartPosY = this.imgui.GetCursorPosY();
            this.StepNo = 1;
            return true;
        }
        // Step 1: the clipper infer height from first element, calculate the
        // actual range of elements to display, and position the cursor before
        // the first element.
        if (this.StepNo == 1)
        {
            if (this.ItemsCount == 1)
            {
                this.ItemsCount = -1;
                return false;
            }
            let items_height = this.imgui.GetCursorPosY() - this.StartPosY;
            // If this triggers, it means Item 0 hasn't moved the cursor vertically
            console.assert(items_height > 0);
            this.Begin(this.ItemsCount-1, items_height);
            this.DisplayStart++;
            this.DisplayEnd++;
            this.StepNo = 3;
            return true;
        }
        // Step 2: dummy step only required if an explicit items_height was
        // passed to constructor or Begin() and user still call Step(). Does
        // nothing and switch to Step 3.
        if (this.StepNo == 2)
        {
            console.assert(this.DisplayStart >= 0 && this.DisplayEnd >= 0);
            this.StepNo = 3;
            return true;
        }
        // Step 3: the clipper validate that we have reached the expected Y
        // position (corresponding to element DisplayEnd), advance the cursor
        // to the end of the list and then returns 'false' to end the loop.
        if (this.StepNo == 3)
            this.End();
        return false;
    }
}

var ImguiListboxMixin =
{
    // Helper to calculate coarse clipping of large list of evenly sized items.
    // Prefer using the ImGuiListClipper higher-level helper if you can.
    // NB: 'items_count' is only used to clamp the result, if you don't know
    // your count you can use INT_MAX
    // NB: we return a list of length 2: DisplayStart, DisplayEnd
    CalcListClipping(items_count, items_height)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (g.LogEnabled)
        {
            // If logging is active, do not perform any clipping
            return [ 0, items_count ];
        }
        if (win.SkipItems)
        {
            return [ 0, 0 ];
        }

        // We create the union of the ClipRect and the NavScoringRect which
        // at worst should be 1 page away from ClipRect
        let unclipped_rect = win.ClipRect.Clone();
        if (g.NavMoveRequest)
            unclipped_rect.Add(g.NavScoringRectScreen);

        const pos = win.DC.CursorPos;
        let start = Math.floor((unclipped_rect.Min.y - pos.y) / items_height);
        let end = Math.floor((unclipped_rect.Max.y - pos.y) / items_height);

        // When performing a navigation request, ensure we have one item extra
        // in the direction we are moving to
        if (g.NavMoveRequest && g.NavMoveClipDir == Dir.Up)
            start--;
        if (g.NavMoveRequest && g.NavMoveClipDir == Dir.Down)
            end++;

        start = Vec1.Clamp(start, 0, items_count);
        end = Vec1.Clamp(end + 1, start, items_count);
        if(isNaN(start) || isNaN(end))
        {
            console.assert(0);
        }
        return [start, end];
    },

    //-------------------------------------------------------------------------
    // [SECTION] Widgets: ListBox
    //-------------------------------------------------------------------------
    // - ListBox()
    // - ListBoxHeader()
    // - ListBoxFooter()
    //-------------------------------------------------------------------------
    // FIXME: This is an old API. We should redesign some of it, rename
    // ListBoxHeader->BeginListBox, ListBoxFooter->EndListBox
    // and promote using them over existing ListBox() functions, similarly to
    // change with combo boxes.
    //-------------------------------------------------------------------------

    // FIXME: In principle this function should be called BeginListBox().
    // We should rename it after re-evaluating if we want to keep the same
    // signature. Helper to calculate the size of a listbox and display a
    // label on the right.
    // Tip: To have a list filling the entire window width, PushItemWidth(-1)
    // and pass an non-visible label e.g. "##empty"
    ListBoxHeader(label, items_count, height_in_items)
    {
        if(items_count.x != undefined)
        {
            // it's actually a size..
            return this.ListBoxHeaderEx(label, items_count);
        }
        // Size default to hold ~7.25 items.
        // We add +25% worth of item height to allow the user to see at a glance
        // if there are more items up/down, without looking at the scrollbar.
        // We don't add this extra bit if items_count <= height_in_items. It is
        // slightly dodgy, because it means a dynamic list of items will make
        // the widget resize occasionally when it crosses that size.
        // I am expecting that someone will come and complain about this behavior
        // in a remote future, then we can advise on a better solution.
        if (height_in_items < 0)
            height_in_items = Math.min(items_count, 7);
        const style = this.GetStyle();
        let height_in_items_f = (height_in_items < items_count) ?
                (height_in_items + 0.25) : (height_in_items + 0.);

        // We include ItemSpacing.y so that a list sized for the exact number
        // of items doesn't make a scrollbar appears. We could also enforce that
        // by passing a flag to BeginChild().
        let size = new Vec2();
        size.x = 0.;
        size.y = this.GetTextLineHeightWithSpacing() * height_in_items_f +
                        style.FramePadding.y * 2.;
        return this.ListBoxHeaderEx(label, size);
    },

    ListBoxHeaderEx(label, size_arg)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        const style = this.GetStyle();
        const id = this.GetID(label);
        const label_size = this.CalcTextSize(label, true);

        // Size default to hold ~7 items. Fractional number of items helps
        // seeing that we can scroll down/up without looking at scrollbar.
        let size = this.calcItemSize(size_arg, this.getNextItemWidth(),
                    this.GetTextLineHeightWithSpacing() * 7.4 + style.ItemSpacing.y);
        let frame_size = new Vec2(size.x, Math.max(size.y, label_size.y));
        let frame_bb = new Rect(win.DC.CursorPos,
                            Vec2.Add(win.DC.CursorPos, frame_size));
        let bb = new Rect(frame_bb.Min,
                            Vec2.AddXY(frame_bb.Max,
                                label_size.x > 0 ?
                                    style.ItemInnerSpacing.x + label_size.x : 0,
                                0.));
        win.DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.

        if (!this.IsRectVisible(bb.Min, bb.Max))
        {
            this.itemSize(bb.GetSize(), style.FramePadding.y);
            this.itemAdd(bb, 0, frame_bb);
            return false;
        }

        this.BeginGroup();
        if (label_size.x > 0)
        {
            this.renderText(new Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                                     frame_bb.Min.y + style.FramePadding.y),
                            label);
        }

        this.BeginChildFrame(id, frame_bb.GetSize());
        return true;
    },

    // FIXME: In principle this function should be called EndListBox().
    // We should rename it after re-evaluating if we want to keep the same
    // signature.
    ListBoxFooter()
    {
        let parent_window = this.getCurrentWindow().ParentWindow;
        const bb = parent_window.DC.LastItemRect;
        const style = this.GetStyle();

        this.EndChildFrame();

        // Redeclare item size so that it includes the label (we have stored
        // the full size in LastItemRect)
        // We call SameLine() to restore DC.CurrentLine* data
        this.SameLine();
        parent_window.DC.CursorPos = bb.Min.Clone();
        this.itemSize(bb, style.FramePadding.y);
        this.EndGroup();
    },

    ListBox(label, current_item, items, height_items=-1, onChange)
    {
        let getter = function(i)
        {
            return items[i];
        };
        return this.ListBoxCB(label, current_item, getter, items.length,
                                height_items, onChange);
    },

    // windowed/deferred listbox
    ListBoxCB(label, current_item, items_getter, items_count,
                height_in_items, onChange)
    {
        let g = this.guictx;
        let value_changed = false;
        if(this.ListBoxHeader(label, items_count, height_in_items))
        {
            // Assume all items have even height (= 1 line of text). If you
            // need items of different or variable sizes you can create a
            // custom version of ListBox() in your code without using the clipper.
            // We know exactly our line height here so we pass it as a minor
            // optimization, but generally you don't need to.
            let clipper = new ListClipper(this, items_count,
                                    this.GetTextLineHeightWithSpacing());
            while (clipper.Step())
            {
                for (let i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
                {
                    const item_selected = (i == current_item);
                    let item_text =  items_getter(i);
                    if(item_text == undefined)
                        item_text = "*Unknown item*";

                    this.PushID(i);
                    if (this.Selectable(item_text, item_selected))
                    {
                        current_item = i;
                        value_changed = true;
                    }
                    if (item_selected)
                        this.SetItemDefaultFocus();
                    this.PopID();
                }
            }
            this.ListBoxFooter();
        }
        if(value_changed)
        {
            if(onChange) onChange(current_item);
            this.markItemEdited(g.CurrentWindow.DC.LastItemId);
        }
        return value_changed;
    },

};
// =====================================================================================================================
// widgets/listbox.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/selectable.js BEGIN
// =====================================================================================================================


/* -- Selectable -------------------------------------------*/
// Tip: pass a non-visible label (e.g. "##dummy") then you
// can use the space to draw other text or image. But you need
// to make sure the ID is unique, e.g. enclose calls in PushID/PopID
// or use ##unique_id.
var SelectableFlags =
{
    None: 0,
    // Clicking this don't close parent popup window
    DontClosePopups: 1 << 0,
    // Selectable frame can span all columns (text will still fit in current column)
    SpanAllColumns: 1 << 1,
    // Generate press events on double clicks too
    AllowDoubleClick: 1 << 2,
    // Cannot be selected, display greyed out text
    Disabled: 1 << 3,

    // these are SelectableFlagsPrivate
    NoHoldingActiveID: 1 << 10,
    PressedOnClick: 1 << 11,
    PressedOnRelease: 1 << 12,
    DrawFillAvailWidth: 1 << 13,
    AllowItemOverlap: 1 << 14
};

var ImguiSelectableMixin =
{
    Selectable(label, selected=false, flags=0, size_arg=Vec2.Zero(false))
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;
        let g = this.guictx;
        const style = g.Style;

        // FIXME-OPT: Avoid if vertically clipped.
        if ((flags & SelectableFlags.SpanAllColumns) && win.DC.CurrentColumns)
            this.PopClipRect();

        let id = win.GetID(label);
        let label_size = this.CalcTextSize(label, true);
        let size = new Vec2(size_arg.x != 0 ? size_arg.x : label_size.x,
                            size_arg.y != 0 ? size_arg.y : label_size.y);
        let pos = win.DC.CursorPos.Clone();
        pos.y += win.DC.CurrentLineTextBaseOffset;
        let bb_inner = new Rect(pos, Vec2.Add(pos,size));
        this.itemSize(bb_inner);

        // Fill horizontal space.
        let window_padding = win.WindowPadding.Clone();
        let max_x = (flags & SelectableFlags.SpanAllColumns) ?
            this.GetWindowContentRegionMax().x :
            this.GetContentRegionMax().x;
        let w_draw = Math.max(label_size.x,
                            win.Pos.x+max_x - window_padding.x-pos.x);
        let size_draw = new Vec2(
                (size_arg.x != 0 && !(flags & SelectableFlags.DrawFillAvailWidth)) ?
                    size_arg.x : w_draw,
                size_arg.y != 0 ? size_arg.y : size.y);
        let bb = new Rect(pos, Vec2.Add(pos, size_draw));
        if (size_arg.x == 0 || (flags & SelectableFlags.DrawFillAvailWidth))
            bb.Max.x += window_padding.x;

        // Selectables are tightly packed together, we extend the box to cover spacing between selectable.
        let spacing_L = Math.floor(style.ItemSpacing.x * 0.5);
        let spacing_U = Math.floor(style.ItemSpacing.y * 0.5);
        let spacing_R = style.ItemSpacing.x - spacing_L;
        let spacing_D = style.ItemSpacing.y - spacing_U;
        bb.Min.x -= spacing_L;
        bb.Min.y -= spacing_U;
        bb.Max.x += spacing_R;
        bb.Max.y += spacing_D;

        let item_add;
        if (flags & SelectableFlags.Disabled)
        {
            let backup_item_flags = win.DC.ItemFlags;
            win.DC.ItemFlags |= ItemFlags.Disabled | ItemFlags.NoNavDefaultFocus;
            item_add = this.itemAdd(bb, id);
            win.DC.ItemFlags = backup_item_flags;
        }
        else
        {
            item_add = this.itemAdd(bb, id);
        }
        if (!item_add)
        {
            if ((flags & SelectableFlags.SpanAllColumns) && win.DC.CurrentColumns)
                this.pushColumnClipRect();
            return false;
        }

        // We use NoHoldingActiveID on menus so user can click and _hold_ on a
        // menu then drag to browse child entries
        let button_flags = 0;
        if (flags & SelectableFlags.NoHoldingActiveID)
            button_flags |= ButtonFlags.NoHoldingActiveID;
        if (flags & SelectableFlags.PressedOnClick)
            button_flags |= ButtonFlags.PressedOnClick;
        if (flags & SelectableFlags.PressedOnRelease)
            button_flags |= ButtonFlags.PressedOnRelease;
        if (flags & SelectableFlags.Disabled)
            button_flags |= ButtonFlags.Disabled;
        if (flags & SelectableFlags.AllowDoubleClick)
            button_flags |= ButtonFlags.PressedOnClickRelease | ButtonFlags.PressedOnDoubleClick;
        if(flags & SelectableFlags.AllowItemOverlap)
            button_flags |= ButtonFlags.AllowItemOverlap;
        if (flags & SelectableFlags.Disabled)
            selected = false;

        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(bb, id, hovered, held, button_flags);

        // Hovering selectable with mouse updates NavId accordingly so
        // navigation can be resumed with gamepad/keyboard (this doesn't
        // happen on most widgets)
        if (pressed || hovered.get())
        {
            if (!g.NavDisableMouseHover && g.NavWindow == win &&
                g.NavLayer == win.DC.NavLayerCurrent)
            {
                g.NavDisableHighlight = true;
                this.setNavID(id, win.DC.NavLayerCurrent);
            }
        }
        if (pressed)
            this.markItemEdited(id);

        if(flags & SelectableFlags.AllowItemOverlap)
            this.SetItemAllowOverlap();

        // Render
        if (hovered.get() || selected)
        {
            let col = style.GetColor((held.get() && hovered.get()) ? "HeaderActive" :
                                hovered.get() ? "HeaderHovered" :
                                "Header");
            this.renderFrame(bb.Min, bb.Max, col, false, 0);
            this.renderNavHighlight(bb, id,
                        NavHighlightFlags.TypeThin|NavHighlightFlags.NoRounding);
        }

        if ((flags & SelectableFlags.SpanAllColumns) && win.DC.CurrentColumns)
        {
            this.pushColumnClipRect();
            bb.Max.x -= (this.GetContentRegionMax().x - max_x);
        }

        if (flags & SelectableFlags.Disabled)
            this.PushStyleColor("Text", g.Style.GetColor("TextDisabled"));
        this.renderTextClipped(bb_inner.Min, bb_inner.Max, label, null,
                                style.SelectableTextAlign, bb);
        if (flags & SelectableFlags.Disabled)
            this.PopStyleColor();

        // Automatically close popups
        if (pressed && (win.Flags & WindowFlags.Popup) &&
            !(flags & SelectableFlags.DontClosePopups) &&
            !(win.DC.ItemFlags & ItemFlags.SelectableDontClosePopup))
        {
            this.CloseCurrentPopup();
        }
        return pressed;
    }
}; // end mixin
// =====================================================================================================================
// widgets/selectable.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/tooltip.js BEGIN
// =====================================================================================================================


var ImguiTooltipMixin =
{
    // simplest tooltip
    Tooltip(str, maxchars=20)
    {
        let imgui = this;
        imgui.SameLine();
        imgui.TextDisabled("?");
        if (imgui.IsItemHovered())
        {
            imgui.BeginTooltip();
            imgui.PushTextWrapPos(imgui.GetFontSize() * maxchars);
            imgui.TextUnformatted(str);
            imgui.PopTextWrapPos();
            imgui.EndTooltip();
        }
    },

    // begin/append a tooltip window. to create full-featured tooltip (with
    //  any kind of items).
    BeginTooltip()
    {
        let g = this.guictx;
        if (g.DragDropWithinSourceOrTarget)
        {
            // The default tooltip position is a little offset to give space to
            // see the context menu (it's also clamped within the current viewport/monitor)
            // In the context of a dragging tooltip we try to reduce that
            // offset and we enforce following the cursor. Whatever we do we
            // want to call SetNextWindowPos() to enforce a tooltip position
            // and disable clipping the tooltip without our display area,
            // like regular tooltip do.
            //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
            let tooltip_pos = Vec2.AddXY(g.IO.MousePos,
                                        16*g.Style.MouseCursorScale,
                                        8*g.Style.MouseCursorScale);
            this.SetNextWindowPos(tooltip_pos);
            this.SetNextWindowBgAlpha(g.Style.Colors["PopupBg"].a * 0.6);
            //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f);
            // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
            this.beginTooltipEx(0, true);
        }
        else
        {
            this.beginTooltipEx(0, false);
        }
    },

    EndTooltip()
    {
        console.assert(this.getCurrentWindowRead().Flags & WindowFlags.Tooltip,
                        "Mismatched BeginTooltip()/EndTooltip() calls");
        this.End();
    },

    SetTooltip(txt, ...args)
    {
        let g = this.guictx;
        if (g.DragDropWithinSourceOrTarget)
            this.BeginTooltip();
        else
            this.beginTooltipEx(0, true);
        this.TextV(txt, args);
        this.EndTooltip();
    },

    beginTooltipEx(extra_flags, override_previous_tooltip=true)
    {
        let g = this.guictx;
        let window_name = "##Tooltip_" + g.TooltipOverrideCount;
        if (override_previous_tooltip)
        {
            let win = this.findWindowByName(window_name);
            if (win && win.Active)
            {
                // Hide previous tooltip from being displayed. We can't easily
                // "reset" the content of a window so we create a new one.
                win.Hidden = true;
                win.HiddenFramesCanSkipItems = 1;
                window_name = "##Tooltip_" + ++g.TooltipOverrideCount;
            }
        }
        let flags = WindowFlags.Tooltip|WindowFlags.NoInputs|
                    WindowFlags.NoTitleBar|WindowFlags.NoMove|
                    WindowFlags.NoResize|WindowFlags.NoSavedSettings|
                    WindowFlags.AlwaysAutoResize;
        this.Begin(window_name, null/*popen*/, flags|extra_flags);
    }
};
// =====================================================================================================================
// widgets/tooltip.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/slider.js BEGIN
// =====================================================================================================================


//-------------------------------------------------------------------------
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
//-------------------------------------------------------------------------
// - SliderBehaviorT<>() [Internal]
// - SliderBehavior() [Internal]
// - SliderScalar()
// - SliderScalarN()
// - SliderFloat()
// - SliderFloat2()
// - SliderFloat3()
// - SliderFloat4()
// - SliderAngle()
// - SliderInt()
// - SliderInt2()
// - SliderInt3()
// - SliderInt4()
// - VSliderScalar()
// - VSliderFloat()
// - VSliderInt()

var SliderFlags =
{
    None: 0,
    Vertical: 1
};

const SliderFFmt = "%0.2f";
const SliderIFmt = "%d";

var ImguiSliderMixin =
{
    /**
    // - CTRL+Click on any slider to turn them into an input box. Manually
    //   input values aren't clamped and can go off-bounds.
    // - Adjust format string to decorate the value with a prefix, a suffix,
    //  or adapt the editing and display precision e.g.
    //      "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs;
    //      "Biscuit: %.0f" -> Biscuit: 1; etc.
    */
    SliderFloat(label, v, v_min, v_max, format=null, power=1, onChange=null)
    {
        if(format == null) format = SliderFFmt;
        return this.SliderScalar(label, v, v_min, v_max, format, power, onChange);
    },

    // adjust format to decorate the value with a prefix or a suffix for
    // in-slider labels or unit display. Use power!=1.0 for power curve sliders
    SliderFloat2(label, v, v_min, v_max, format=null, power=1, onChange=null)
    {
        if(format == null) format = SliderFFmt;
        return this.SliderScalarN(label, 2, v, v_min, v_max, format, power, onChange);
    },

    SliderFloat3(label, v, v_min, v_max, format=null, power=1, onChange=null)
    {
        if(format == null) format = SliderFFmt;
        return this.SliderScalarN(label, 3, v, v_min, v_max, format, power, onChange);
    },

    SliderFloat4(label, v, v_min, v_max, format=null, power=1, onChange=null)
    {
        if(format == null) format = SliderFFmt;
        return this.SliderScalarN(label, 4, v, v_min, v_max, format, power, onChange);
    },

    SliderAngle(label, v_rad, v_degrees_min, v_degrees_max, format=null, onChange)
    {
        if(format == null) format = SliderIFmt;
        let v_deg = v_rad * 360 / (2 * Math.PI);
        let value_changed =
            this.SliderFloat(label, v_deg, v_degrees_min, v_degrees_max, format, 1,
                function(deg) {
                    v_rad = deg * 2 * Math.PI / 360;
                    if(onChange) onChange(v_rad);
                });
        return value_changed;
    },

    SliderInt(label, v, v_min, v_max, format=null, onChange=null)
    {
        if(format == null) format = SliderIFmt;
        return this.SliderScalar(label, v, v_min, v_max, format, 1, onChange);
    },

    SliderInt2(label, v, v_min, v_max, format=null, onChange=null)
    {
        if(format == null) format = SliderIFmt;
        return this.SliderScalarN(label, 2, v, v_min, v_max, format, 1, onChange);
    },

    SliderInt3(label, v, v_min, v_max, format=null, onChange=null)
    {
        if(format == null) format = SliderIFmt;
        return this.SliderScalarN(label, 3, v, v_min, v_max, format, 1, onChange);
    },

    SliderInt4(label, v, v_min, v_max, format=null, onChange=null)
    {
        if(format == null) format = SliderIFmt;
        return this.SliderScalarN(label, 4, v, v_min, v_max, format, 1, onChange);
    },

    SliderScalar(label, v, v_min, v_max, format, power=1, onChange=null)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        const style = g.Style;
        const id = win.GetID(label);
        const w = this.CalcItemWidth();
        const label_size = this.CalcTextSize(label, true);
        const frame_bb = new Rect(win.DC.CursorPos,
                            Vec2.AddXY(win.DC.CursorPos,
                                    w, label_size.y + style.FramePadding.y*2));
        const total_bb = new Rect(frame_bb.Min,
                            Vec2.AddXY(frame_bb.Max,
                                label_size.x > 0 ? style.ItemInnerSpacing.x+label_size.x: 0,
                                0.0));

        this.itemSize(total_bb, style.FramePadding.y);
        if (!this.itemAdd(total_bb, id, frame_bb))
            return false;

        // Tabbing or CTRL-clicking on Slider turns it into an input box
        let start_text_input = false;
        const focus_requested = this.focusableItemRegister(win, id);
        const hovered = this.itemHoverable(frame_bb, id);
        if (focus_requested || (hovered && g.IO.MouseClicked[0]) ||
            g.NavActivateId == id ||
            (g.NavInputId == id && g.ScalarAsInputTextId != id))
        {
            this.setActiveID(id, win);
            this.setFocusID(id, win);
            this.FocusWindow(win);
            g.ActiveIdAllowNavDirFlags = (1 << Dir.Up) | (1 << Dir.Down);
            if (focus_requested || g.IO.KeyCtrl || g.NavInputId == id)
            {
                start_text_input = true;
                g.ScalarAsInputTextId = 0;
            }
        }
        if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
        {
            win.DC.CursorPos = frame_bb.Min;
            this.focusableItemUnregister(win);
            return this.inputScalarAsWidgetReplacement(frame_bb, id, label,
                                                        v, format, onChange);
        }

        // Draw frame
        const  frame_col = style.GetColor(g.ActiveId == id ? "FrameBgActive" :
                                        g.HoveredId == id ? "FrameBgHovered" :
                                        "FrameBg");
        this.renderNavHighlight(frame_bb, id);
        this.renderFrame(frame_bb.Min, frame_bb.Max, frame_col, true,
                            g.Style.FrameRounding);

        // Slider behavior
        let grab_bb = new Rect();
        let valstr = FormatValues(format, [v]);
        let value_changed = this.sliderBehavior(frame_bb, id, v,
                                            v_min, v_max, format, power,
                                            SliderFlags.None, grab_bb,
                                            function(newVal) {
                                                valstr = FormatValues(format, [newVal]);
                                                if(onChange)
                                                    onChange(newVal);
                                            });
        if (value_changed)
            this.markItemEdited(id);

        // Render grab
        win.DrawList.AddRectFilled(grab_bb.Min, grab_bb.Max,
                    style.GetColor(g.ActiveId == id ?
                                "SliderGrabActive" : "SliderGrab"),
                    style.GrabRounding);

        // Display value using user-provided display format so user can add
        // prefix/suffix/decorations to the value.
        this.renderTextClipped(frame_bb.Min, frame_bb.Max, valstr, null, new Vec2(0.5,0.5));
        if (label_size.x > 0)
        {
            this.renderText(new Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                                     frame_bb.Min.y + style.FramePadding.y),
                                     label);
        }
        return value_changed;
    },

    SliderScalarN(label, components, v, v_min, v_max, format, power=1, onChange=null)
    {
        let saveV = null;
        if(!Array.isArray(v))
        {
            if(v.x != undefined)
            {
                saveV = v;
                v = [saveV.x];
            }
            if(saveV.y != undefined)
                v.push(saveV.y);
            if(saveV.z != undefined)
                v.push(saveV.z);
            if(saveV.a != undefined)
                v.push(saveV.a);
        }
        console.assert(v.length >= components);

        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        let value_changed = false;
        this.BeginGroup();
        this.PushID(label);
        this.pushMultiItemsWidths(components);
        for (let i = 0; i < components; i++)
        {
            this.PushID(i);
            value_changed |= this.SliderScalar("", v[i], v_min, v_max, format, power,
                                            (newVal) => v[i] = newVal);
            this.SameLine(0, g.Style.ItemInnerSpacing.x);
            this.PopID();
            this.PopItemWidth();
        }
        this.PopID();
        this.textEx(label);
        this.EndGroup();
        if(value_changed)
        {
            if(saveV != null)
            {
                saveV.x = v[0];
                if(saveV.y != undefined)
                    saveV.y = v[1];
                if(saveV.z != undefined)
                    saveV.z = v[2];
                if(saveV.a != undefined)
                    saveV.a = v[3];
            }
            if(onChange)
                onChange(v);
        }
        return value_changed;
    },

    // Vertical slider
    VSliderFloat(label, size, v, v_min, v_max, format=null, power=1, onChange=null)
    {
        if(format==null) format = SliderFFmt;
        this.VSliderScalar(label, size, v, v_min, v_max, format, power, onChange);
    },

    VSliderInt(label, size, v, v_min, v_max, format=null, onChange=null)
    {
        if(format == null) format = SliderIFmt;
        this.VSliderScalar(label, size, v, v_min,v_max, format, 1, onChange);
    },

    VSliderScalar(label, size, v, v_min, v_max, format, power, onChange)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        const style = g.Style;
        const id = win.GetID(label);
        const label_size = this.CalcTextSize(label, true);
        const frame_bb = new Rect(win.DC.CursorPos,
                                Vec2.Add(win.DC.CursorPos, size));
        const bb = new Rect(frame_bb.Min,
                        Vec2.AddXY(frame_bb.Max,
                            (label_size.x > 0 ? style.ItemInnerSpacing.x+label_size.x : 0),
                            0));

        this.itemSize(bb, style.FramePadding.y);
        if (!this.itemAdd(frame_bb, id))
            return false;

        const hovered = this.itemHoverable(frame_bb, id);
        if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id ||
            g.NavInputId == id)
        {
            this.setActiveID(id, win);
            this.setFocusID(id, win);
            this.FocusWindow(win);
            g.ActiveIdAllowNavDirFlags = (1 << Dir.Left) | (1 << Dir.Right);
        }

        // Draw frame
        const frame_col = style.GetColor(g.ActiveId == id ? "FrameBgActive" :
                            g.HoveredId == id ? "FrameBgHovered" : "FrameBg");
        this.renderNavHighlight(frame_bb, id);
        this.renderFrame(frame_bb.Min, frame_bb.Max, frame_col, true,
                            g.Style.FrameRounding);

        // Slider behavior
        let grab_bb = new Rect();
        let valstr = FormatValues(format, [v]);
        const value_changed = this.sliderBehavior(frame_bb, id, v, v_min, v_max,
                                    format, power, SliderFlags.Vertical,
                                    grab_bb, function(newval) {
                                        valstr = FormatValues(format, [newval]);
                                        if(onChange) onChange(newval);
                                    });
        if (value_changed)
            this.markItemEdited(id);

        // Render grab
        if (grab_bb.Max.y > grab_bb.Min.y)
        {
            win.DrawList.AddRectFilled(grab_bb.Min, grab_bb.Max,
                    style.GetColor(g.ActiveId == id ? "SliderGrabActive" : "SliderGrab"),
                    style.GrabRounding);
            }

        // Display value using user-provided display format so user can add
        // prefix/suffix/decorations to the value. For the vertical slider we
        // allow centered text to overlap the frame padding
        this.renderTextClipped(new Vec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y),
                                frame_bb.Max, valstr, null, new Vec2(0.5,0.));

        if (label_size.x > 0)
        {
            this.renderText(new Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                                     frame_bb.Min.y + style.FramePadding.y),
                            label);
        }
        return value_changed;
    },

    /*---------------------------------------------------------------*/
    // returns true/false
    sliderBehavior(bb, id, v, v_min, v_max, format, power, flags,
                  out_grab_bb, onChange=null)
    {
        let g = this.guictx;
        const style = g.Style;
        let data_type = typeof(v);
        console.assert(data_type == "number");
        let precision = ParseFormatPrecision(format);

        const axis = (flags & SliderFlags.Vertical) ? "y" : "x"; // Axis.Y : Axis.X;
        const is_decimal = precision != 0;
        const is_power = (power != 1) && is_decimal;

        const grab_padding = 2;
        const slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2;
        let grab_sz = style.GrabMinSize;
        let v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);
        if (!is_decimal && v_range >= 0) // v_range < 0 may happen on integer overflows
        {
            // For integer sliders: if possible have the grab size represent 1 unit
            grab_sz = Math.max((slider_sz / (v_range + 1)), style.GrabMinSize);
        }
        grab_sz = Math.min(grab_sz, slider_sz);
        const slider_usable_sz = slider_sz - grab_sz;
        const slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz*0.5;
        const slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz*0.5;

        // For power curve sliders that cross over sign boundary we want the
        // curve to be symmetric around 0
        let linear_zero_pos;   // 0->1.
        if (is_power && v_min * v_max < 0)
        {
            // Different sign
            const minToZero = Math.pow(v_min >= 0 ? v_min : -v_min, 1.0/power);
            const maxToZero = Math.pow(v_max >= 0 ? v_max : -v_max, 1.0/power);
            linear_zero_pos = (minToZero / (minToZero + maxToZero));
        }
        else
        {
            // Same sign
            linear_zero_pos = v_min < 0 ? 1 : 0;
        }
        // Process interacting with the slider
        let value_changed = false;
        if (g.ActiveId == id)
        {
            let set_new_value = false;
            let clicked_t = 0.0;
            if (g.ActiveIdSource == InputSource.Mouse)
            {
                if (!g.IO.MouseDown[0])
                {
                    this.clearActiveID();
                }
                else
                {
                    const mouse_abs_pos = g.IO.MousePos[axis];
                    clicked_t = (slider_usable_sz > 0) ?
                            Vec1.Clamp((mouse_abs_pos-slider_usable_pos_min) /
                            slider_usable_sz, 0, 1)
                            : 0.0;
                    if (axis == "y")
                        clicked_t = 1 - clicked_t;
                    set_new_value = true;
                }
            }
            else
            if (g.ActiveIdSource == InputSource.Nav)
            {
                const delta2 = this.getNavInputAmount2d(NavDirSourceFlags.Keyboard |
                                                        NavDirSourceFlags.PadDPad,
                                                        InputReadMode.RepeatFast,
                                                        0, 0);
                let delta = (axis == Axis.X) ? delta2.x : -delta2.y;
                if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
                {
                    this.clearActiveID();
                }
                else
                if (delta != 0)
                {
                    clicked_t = this.sliderCalcRatioFromValue(v, v_min, v_max, power, linear_zero_pos);
                    const decimal_precision = ParseFormatPrecision(format);
                    if ((decimal_precision > 0) || is_power)
                    {
                        delta /= 100;    // Gamepad/keyboard tweak speeds in % of slider bounds
                        if(this.isNavInputDown(NavInput.TweakSlow))
                            delta /= 10;
                    }
                    else
                    {
                        if ((v_range >= -100 && v_range <= 100) ||
                            this.isNavInputDown(NavInput.TweakSlow))
                        {
                            // Gamepad/keyboard tweak speeds in integer steps
                            delta = ((delta < 0.0) ? -1.0 : +1.0) / v_range;
                        }
                        else
                            delta /= 100.;
                    }
                    if (this.isNavInputDown(NavInput.TweakFast))
                        delta *= 10.;
                    set_new_value = true;
                    if ((clicked_t >= 1. && delta > 0.) ||
                        (clicked_t <= 0. && delta < 0.))
                    {
                        // This is to avoid applying the saturation when already
                        // past the limits
                        set_new_value = false;
                    }
                    else
                        clicked_t = Vec1.Saturate(clicked_t + delta);
                }
            }
            if (set_new_value)
            {
                let v_new;
                if (is_power)
                {
                    // Account for power curve scale on both sides of the zero
                    if (clicked_t < linear_zero_pos)
                    {
                        // Negative: rescale to the negative range before powering
                        let a = 1.0 - (clicked_t / linear_zero_pos);
                        a = Math.pow(a, power);
                        v_new = Vec1.Lerp(Math.min(v_max, 0), v_min, a);
                    }
                    else
                    {
                        // Positive: rescale to the positive range before powering
                        let a;
                        if (Math.abs(linear_zero_pos - 1) > 1.e-6)
                            a = (clicked_t-linear_zero_pos) / (1.0-linear_zero_pos);
                        else
                            a = clicked_t;
                        a = Math.pow(a, power);
                        v_new = Vec1.Lerp(Math.max(v_min, 0), v_max, a);
                    }
                }
                else
                {
                    // Linear slider
                    if (is_decimal)
                    {
                        v_new = Vec1.Lerp(v_min, v_max, clicked_t);
                    }
                    else
                    {
                        // For integer values we want the clicking position to
                        // match the grab box so we round above  This code is
                        // carefully tuned to work with large values (e.g. high
                        // ranges of U64) while preserving this property..
                        // XXX: is this okay for "floats"?
                        let v_new_off_f = (v_max - v_min) * clicked_t;
                        let v_new_off_floor = Math.floor(v_new_off_f);
                        let v_new_off_round = Math.round(v_new_off_f);
                        if (!is_decimal && v_new_off_floor < v_new_off_round)
                            v_new = v_min + v_new_off_round;
                        else
                            v_new = v_min + v_new_off_floor;
                    }
                }

                // Round to user desired precision based on format string
                v_new = RoundScalarToPrecision(v_new, precision);

                // Apply result
                if (v != v_new)
                {
                    v = v_new;
                    value_changed = true;
                }
            }
        }
        // Output grab position so it can be displayed by the caller
        let grab_t = this.sliderCalcRatioFromValue(v, v_min, v_max, power, linear_zero_pos);
        if (axis == "y")
            grab_t = 1. - grab_t;
        const grab_pos = Vec1.Lerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
        if(out_grab_bb != null)
        {
            let min, max;
            if (axis == "x")
            {
                min = new Vec2(grab_pos - grab_sz*0.5, bb.Min.y + grab_padding);
                max = new Vec2(grab_pos + grab_sz*0.5, bb.Max.y - grab_padding);
            }
            else
            {
                min = new Vec2(bb.Min.x + grab_padding, grab_pos - grab_sz*0.5);
                max = new Vec2(bb.Max.x - grab_padding, grab_pos + grab_sz*0.5);
            }
            out_grab_bb.Min = min;
            out_grab_bb.Max = max;
        }
        if(value_changed && onChange)
            onChange(v);
        return value_changed;
    },

    sliderCalcRatioFromValue(v, v_min, v_max, power, linear_zero_pos)
    {
        if (v_min == v_max)
            return 0;
        const is_power = (power != 1);
        const v_clamped = (v_min < v_max) ? Vec1.Clamp(v, v_min, v_max) :
                                            Vec1.Clamp(v, v_max, v_min);
        if (is_power)
        {
            if (v_clamped < 0)
            {
                const f = 1 - ((v_clamped - v_min) / (Math.min(0, v_max) - v_min));
                return (1 - Math.pow(f, 1/power)) * linear_zero_pos;
            }
            else
            {
                const f = (v_clamped - Math.max(0, v_min)) / (v_max - Math.max(0, v_min));
                return linear_zero_pos + Math.pow(f, 1/power) * (1 - linear_zero_pos);
            }
        }

        // Linear slider
        return (v_clamped - v_min) / (v_max - v_min);
    },

};
// =====================================================================================================================
// widgets/slider.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/text.js BEGIN
// =====================================================================================================================

//-------------------------------------------------------------------------
// [SECTION] Widgets: Text, etc.
//-------------------------------------------------------------------------
// - TextUnformatted()
// - Text()
// - TextV()
// - TextColored()
// - TextColoredV()
// - TextDisabled()
// - TextDisabledV()
// - TextWrapped()
// - TextWrappedV()
// - LabelText()
// - LabelTextV()
// - BulletText()
// - BulletTextV()
//-------------------------------------------------------------------------

var TextFlags =
{
    None: 0,
    CharsDecimal: 1 << 0,   // Allow 0123456789.+-*/
    CharsHexadecimal: 1 << 1,   // Allow 0123456789ABCDEFabcdef
    CharsUppercase: 1 << 2,   // Turn a..z into A..Z
    CharsNoBlank: 1 << 3,   // Filter out spaces, tabs
    AutoSelectAll: 1 << 4,   // Select entire text when first taking mouse focus
    EnterReturnsTrue: 1 << 5,   // Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function.
    CallbackCompletion: 1 << 6,   // Callback on pressing TAB (for completion handling)
    CallbackHistory: 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)
    CallbackAlways: 1 << 8,   // Callback on each iteration. User code may query cursor position, modify text buffer.
    CallbackCharFilter: 1 << 9,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
    AllowTabInput: 1 << 10,  // Pressing TAB input a '\t' character into the text field
    CtrlEnterForNewLine: 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
    NoHorizontalScroll: 1 << 12,  // Disable following the cursor horizontally
    AlwaysInsertMode: 1 << 13,  // Insert mode
    ReadOnly: 1 << 14,  // Read-only mode
    Password: 1 << 15,  // Password mode, display all characters as '*'
    NoUndoRedo: 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
    CharsScientific: 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
    CallbackResize: 1 << 18,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
    AsHyperText: 1 << 19,  
    UseLabelWidth: 1 << 20, // defer to Style for width text
    // [Internal]
    Multiline: 1 << 21   // For internal use by InputTextMultiline()
};

// A text filter widget includes the filter value and is able to draw itself.
// The filter may be changed as a side-effect of calling Draw.
class TextFilter
{
    constructor(imgui, defaultFilter="")
    {
        this.imgui = imgui;
        this.filter = new MutableString(defaultFilter);
        this.regexp = null;
        this.regexpErr = null;
    }

    Set(f)
    {
        this.filter.Set(f);
        this.updateRegexp();
    }

    Get()
    {
        return this.filter.Get();
    }

    Draw(label = "Filter", width=0, flags=0)
    {
        if (width != 0)
            this.imgui.PushItemWidth(width);
        let value_changed = this.imgui.InputText(label, this.filter, flags);
        if (width != 0)
            this.imgui.PopItemWidth();
        if(value_changed)
        {
            this.updateRegexp();
        }
        if(this.regexpErr)
        {
            const style = this.imgui.guictx.Style;
            this.imgui.SameLine();
            this.imgui.PushFont(style.GetFont("Small"));
            this.imgui.TextColored(style.GetColor("TextError"), this.regexpErr);
            this.imgui.PopFont();
        }
        return value_changed;
    }

    updateRegexp()
    {
        try
        {
            let r = new RegExp(this.filter.toString());
            this.regexp = r;
            this.regexpErr = null;
        }
        catch(err)
        {
            // report errors?
            this.regexpErr = err.message;
        }
    }

    IsActive()
    {
        return this.filter.Length() > 0;
    }

    PassFilter(input)
    {
        if(this.filter.Length() > 0 && this.regexp)
        {
            if(input)
            {
                if(!Array.isArray(input))
                    return this.regexp.test(input);
                else
                {
                    for(let str of input)
                    {
                        if(this.regexp.test(str))
                            return true;
                    }
                }
            }
            else
            if(this.filter.Get() == "<undefined>" ||
               this.filter.Get() == "<unknown>")
                return true;
            return false;
        }
        else
            return true;
    }

    Clear()
    {
        this.filter.Set("");
    }
}

var ImguiTextMixin =
{
    GetTextLineHeight()
    {
        return this.guictx.FontLineHeight;
    },

    GetTextLineHeightWithSpacing()
    {
        return this.guictx.FontLineHeight + this.guictx.Style.ItemSpacing.y;
    },

    HyperMenu(txt, flags=0)
    {
        let fields = txt.split("##");
        txt = fields[0] + " " + this.guictx.Style._UIcons.SmallDownArrow;
        if(fields.length == 2)
            txt += "##" + fields[1];
        return this.HyperText(txt, flags);
    },

    HyperText(txt, txtflags=0, buttonflags=0)
    {
        return this.textEx(txt, txtflags|
                        TextFlags.NoWidthForLargeClippedText|
                        TextFlags.AsHyperText,
                        buttonflags
                        );
    },

    TextUnformatted(txt, flags=0)
    {
        this.textEx(txt, flags|TextFlags.NoWidthForLargeClippedText);
    },

    Text(fmt, ...args)
    {
        return this.TextV(fmt, args);
    },

    TextV(fmt, args)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;
        let str = this.formatText(fmt, args);
        return this.textEx(str, TextFlags.NoWidthForLargeClippedText);
    },

    TextColored(col, fmt, ...args)
    {
        return this.TextColoredV(col, fmt, args);
    },

    TextColoredV(col, fmt, args)
    {
        this.PushStyleColor("Text", col);
        let ret = this.TextV(fmt, args);
        this.PopStyleColor();
        return ret;
    },

    TextDisabled(fmt, ...args)
    {
        return this.TextDisabledV(fmt, args);
    },

    TextDisabledV(fmt, args)
    {
        this.PushStyleColor("Text", this.guictx.Style.Colors.TextDisabled);
        let ret = this.TextV(fmt, args);
        this.PopStyleColor();
        return ret;
    },

    TextEmphasized(fmt, ...args)
    {
        return this.TextEmphasizedV(fmt, args);
    },

    TextEmphasizedV(fmt, args)
    {
        this.PushStyleColor("Text", this.guictx.Style.Colors.TextEmphasized);
        let ret = this.TextV(fmt, args);
        this.PopStyleColor();
        return ret;
    },

    TextWrapped(fmt, ...args)
    {
        return this.TextWrappedV(fmt, args);
    },

    TextWrappedV(fmt, args)
    {
        let need_backup = (this.guictx.CurrentWindow.DC.TextWrapPos < 0);
        if (need_backup)
        {
            // Keep existing wrap position if one is already set
            this.PushTextWrapPos(0.);
        }
        let ret = this.TextV(fmt, args);
        if (need_backup)
            this.PopTextWrapPos();
        return ret;
    },

    // Add a text label that has vertical alignment equivalent to
    // input text.  Used to bypass labels on right behavior.
    // NB: this is easy to confuse with LabelText (below)

    LabelDisabled(label, txtflags=TextFlags.UseLabelWidth)
    {
        this.PushStyleColor("Text", this.guictx.Style.Colors.TextDisabled);
        this.Label(label, txtflags);
        this.PopStyleColor();
    },

    Label(label, txtflags=TextFlags.UseLabelWidth)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let g = this.guictx;
        let style = g.Style;
        let mtext = label;
        if(txtflags & TextFlags.UseLabelWidth)
            mtext = style.LabelWidth;

        // we cache results of CalcTextSize since it's expensive and
        // the number of labels is presumed limited.
        let key = mtext + g.Font.AsStr();
        if(!this.labelSizeCache) 
            this.labelSizeCache = {};
        let labelSize = this.labelSizeCache[key];
        if(!labelSize)
        {
            labelSize = this.CalcTextSize(mtext, false /*split before ## */);
            this.labelSizeCache[key] = labelSize; // a Vec2
        }
        const labelBB = new Rect(win.DC.CursorPos,
                                  Vec2.AddXY(win.DC.CursorPos,
                                    labelSize.x + style.FramePadding.x, 
                                    labelSize.y + style.FramePadding.y*2));
        /*
        // styleItemInnerSpacing
        const totalBB = new Rect(win.DC.CursorPos,
                                 Vec2.Add(
                                    Vec2.AddXY(win.DC.CursorPos,
                                        w + (labelSize.x > 0 ?
                                                style.ItemInnerSpacing.x : 0),
                                        style.FramePadding.y*2),
                                    labelSize));
        */
        this.itemSize(labelBB, style.FramePadding.y);
        if (!this.itemAdd(labelBB, 0))
            return;
        let tpos = new Vec2(labelBB.Min.x,
                            labelBB.Min.y + style.FramePadding.y);
        this.renderText(tpos, label); // clip?
    },

    LabelText(label, fmt, ...args)
    {
        this.LabelTextV(label, fmt, args);
    },

    // Add a label+text combo aligned to other label+value widgets
    LabelTextV(label, fmt, args)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let g = this.guictx;
        let style = g.Style;
        const w = this.CalcItemWidth();
        const label_size = this.CalcTextSize(label, true);
        const value_bb = new Rect(win.DC.CursorPos,
                                  Vec2.AddXY(win.DC.CursorPos,
                                        w, label_size.y + style.FramePadding.y*2));
        const total_bb = new Rect(win.DC.CursorPos,
                                 Vec2.Add(
                                    Vec2.AddXY(win.DC.CursorPos,
                                        w + (label_size.x > 0 ?
                                                style.ItemInnerSpacing.x : 0),
                                        style.FramePadding.y*2),
                                    label_size));
        this.itemSize(total_bb, style.FramePadding.y);
        if (!this.itemAdd(total_bb, 0))
            return;

        if(fmt)
        {
            // Render
            let valueTxt = this.formatText(fmt, args);
            this.renderTextClipped(value_bb.Min, value_bb.Max,
                                valueTxt, null, new Vec2(0.,0.5));
        }
        if (label_size.x > 0)
        {
            this.renderText(
                new Vec2(value_bb.Max.x + style.ItemInnerSpacing.x,
                         value_bb.Min.y + style.FramePadding.y), label);
        }
    },

    BulletText(fmt, ...args)
    {
        this.BulletTextV(fmt, args);
    },

    // Text with a little bullet aligned to the typical tree node.
    BulletTextV(fmt, args)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let g = this.guictx;
        const style = g.Style;

        let text = this.formatText(fmt, args);
        const label_size = this.CalcTextSize(text, false);
        // Latch before ItemSize changes it
        const text_base_offset_y = Math.max(0, win.DC.CurrentLineTextBaseOffset);
        const line_height = Math.max(Math.min(win.DC.CurrentLineHeight,
                                        g.FontLineHeight + g.Style.FramePadding.y*2),
                                    g.FontSize);
        // Empty text doesn't add padding
        const bb = new Rect(win.DC.CursorPos,
                            Vec2.AddXY(win.DC.CursorPos,
                                    g.FontSize + (label_size.x > 0 ?
                                        (label_size.x + style.FramePadding.x*2) : 0),
                                    Math.max(line_height, label_size.y)));
        this.itemSize(bb);
        if (!this.itemAdd(bb, 0))
            return;

        // Render
        this.renderBullet(Vec2.AddXY(bb.Min,
                                style.FramePadding.x + g.FontSize*0.5,
                                g.FontSize*0.5));
        this.renderText(Vec2.AddXY(bb.Min,
                                g.FontSize + style.FramePadding.x*2,
                                text_base_offset_y),
                        text, false);
    },

    textEx(txt, flags, buttonflags=0)
    {
       let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let id;
        if(flags & TextFlags.AsHyperText)
        {
            id = win.GetID(txt);
            txt = txt.split("##")[0];
        }
        let ret = false;
        const text_pos = new Vec2(win.DC.CursorPos.x,
                            win.DC.CursorPos.y + win.DC.CurrentLineTextBaseOffset);
        const wrap_pos_x = win.DC.TextWrapPos;
        const wrap_enabled = flags&TextFlags.NoWidthForLargeClippedText ? false :
                                (wrap_pos_x >= 0.);
        if (txt.length > 2000 && !wrap_enabled)
        {
            // Long text!
            // Perform manual coarse clipping to optimize for long multi-line text
            // - From this point we will only compute the width of lines that are
            //   visible. Optimization only available when word-wrapping is disabled.
            // - We also don't vertically center the text within the line full
            //   height, which is unlikely to matter because we are likely the
            //   biggest and only item on the line.
            // - We use memchr(), pay attention that well optimized versions of
            //   those str/mem functions are much faster than a casually written
            //   loop.
            console.assert(0, "long text not implemented");
        }
        else
        {
            let style = this.GetStyle();
            const wrap_width = wrap_enabled ?
                    this.calcWrapWidthForPos(win.DC.CursorPos, wrap_pos_x) :
                    0.0;
            let stxt = txt;
            if(flags & TextFlags.UseLabelWidth)
                stxt = style.LabelWidth;

            const text_size = this.CalcTextSize(stxt, false, wrap_width);
            let bb = new Rect(text_pos, Vec2.Add(text_pos, text_size));
            this.itemSize(text_size);
            if (!this.itemAdd(bb, 0))
                return ret;
            
            if(flags&TextFlags.AsHyperText)
            {
                let hovered = new ValRef(), held = new ValRef();
                if (win.DC.ItemFlags & ItemFlags.ButtonRepeat)
                    buttonflags |= ButtonFlags.Repeat;
                ret = this.ButtonBehavior(bb, id, hovered, held, buttonflags);
                if (ret)
                    this.markItemEdited(id);
                let disabled = buttonflags & ButtonFlags.Disabled;
                let stylenm = disabled ? "TextDisabled" :
                                (held.get() ? "LinkActive" : 
                                    (hovered.get() ? "LinkHovered" : "Link"));
                this.PushStyleColor("Text", style.GetColor(stylenm));
            }

            // Render (only expect ## in the AsHyperText case)
            this.renderTextWrapped(bb.Min, txt, wrap_width);
            if(flags&TextFlags.AsHyperText)
                this.PopStyleColor();
        }
        return ret;
    },

    formatNumber(n, radix=10, pad=0, pad_char="0")
    {
        return pad > 0 ?
            (pad_char.repeat(pad) + n.toString(radix)).substr(-pad) :
            n.toString(radix);
    },

    formatNumberDec(n, pad=0, pad_char="0")
    {
       return this.formatNumber(n, 10, pad, pad_char);
    },

    formatNumberHex(n, pad, pad_char="0")
    {
        return this.formatNumber(n, 16, pad, pad_char);
    },

    formatText(fmt, args)
    {
        return FormatValues(fmt, args);
    }

};  // end mixin

// =====================================================================================================================
// widgets/text.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/coloredit.js BEGIN
// =====================================================================================================================


var ColorEditFlags =
{
    None: 0,
    NoAlpha: 1 << 1,   // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).
    NoPicker: 1 << 2,  // ColorEdit: disable picker when clicking on colored square.
    NoOptions: 1 << 3, // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
    NoSmallPreview: 1 << 4, // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
    NoInputs: 1 << 5,   // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
    NoTooltip: 1 << 6,   // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
    NoLabel: 1 << 7,   // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
    NoSidePreview: 1 << 8,   // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.
    NoDragDrop: 1 << 9,   // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.

    // User Options (right-click on widget to change some of them).
    AlphaBar: 1 << 16,  // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
    AlphaPreview: 1 << 17,  // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
    AlphaPreviewHalf: 1 << 18,  // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
    HDR: 1 << 19,  // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
    DisplayRGB: 1 << 20,  // [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.
    DisplayHSV: 1 << 21,  // [Display]    // "
    DisplayHex: 1 << 22,  // [Display]    // "
    Uint8: 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
    Float: 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
    PickerHueBar: 1 << 25,  // [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.
    PickerHueWheel: 1 << 26,  // [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.
    InputRGB: 1 << 27,  // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.
    InputHSV: 1 << 28,  // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.
};

// Defaults Options. You can set application defaults using SetColorEditOptions().
// The intent is that you probably don't want to  override them in most of your
// calls. Let the user choose via the option menu and/or call SetColorEditOptions()
// once during startup.
f = ColorEditFlags;
f.OptionsDefault = f.Uint8|f.DisplayRGB|f.InputRGB|f.PickerHueBar;
// [Internal] Masks
f.DisplayMask    = f.DisplayRGB|f.DisplayHSV|f.DisplayHex;
f.DataTypeMask   = f.Uint8|f.Float;
f.PickerMask     = f.PickerHueWheel|f.PickerHueBar;
f.InputMask      = f.InputRGB|f.InputHSV;

//-------------------------------------------------------------------------
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
//-------------------------------------------------------------------------
// - ColorEdit3()
// - ColorEdit4()
// - ColorButton()
// - SetColorEditOptions()
// - colorTooltip() [Internal]
// - colorEditOptionsPopup() [Internal]
// - colorPickerOptionsPopup() [Internal]
//-------------------------------------------------------------------------
var ImguiColorEditMixin =
{
    // little colored preview square that can be left-clicked to open a picker,
    //  and right-clicked to open an option menu.)
    ColorEdit3(label, col, flags=ColorEditFlags.DisplayRGB)
    {
        return this.ColorEdit4(label, col, flags | ColorEditFlags.NoAlpha);
    },

    // Edit colors components (each component in 0.0f..1.0f range).
    // See enum ColorEditFlags_ for available options. e.g. Only access
    // 3 floats if ColorEditFlags.NoAlpha flag is set. With typical
    // options: Left-click on colored square to open color picker. Right-click
    // to open option menu. CTRL-Click over input fields to edit them and TAB
    // to go to next item.
    ColorEdit4(label, col, flags)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        const style = g.Style;
        const square_sz = this.GetFrameHeight();
        const w_extra = (flags & ColorEditFlags.NoSmallPreview) ? 0 :
                        (square_sz + style.ItemInnerSpacing.x);
        const w_items_all = this.CalcItemWidth() - w_extra;
        this.BeginGroup();
        this.PushID(label); // {

        label = label.split("##")[0];

        // If we're not showing any slider there's no point in doing any HSV conversions
        const flags_untouched = flags;
        if (flags & ColorEditFlags.NoInputs)
        {
            flags = (flags & (~ColorEditFlags.DisplayMask)) |
                    ColorEditFlags.DisplayRGB | ColorEditFlags.NoOptions;
        }

        // Context menu: display and modify options (before defaults are applied)
        if (!(flags & ColorEditFlags.NoOptions))
            this.colorEditOptionsPopup(col, flags);

        // Read stored options
        if (!(flags & ColorEditFlags.DisplayMask))
            flags |= (g.ColorEditOptions & ColorEditFlags.DisplayMask);
        if (!(flags & ColorEditFlags.DataTypeMask))
            flags |= (g.ColorEditOptions & ColorEditFlags.DataTypeMask);
        if (!(flags & ColorEditFlags.PickerMask))
            flags |= (g.ColorEditOptions & ColorEditFlags.PickerMask);
        if (!(flags & ColorEditFlags.InputMask))
            flags |= (g.ColorEditOptions & ColorEditFlags.InputMask);
        flags |= (g.ColorEditOptions & ~(ColorEditFlags.DisplayMask |
                                         ColorEditFlags.DataTypeMask |
                                         ColorEditFlags.PickerMask |
                                         ColorEditFlags.InputMask));

        const alpha = (flags & ColorEditFlags.NoAlpha) == 0;
        const hdr = (flags & ColorEditFlags.HDR) != 0;
        const components = alpha ? 4 : 3;

        // Convert to the formats we need
        let cedit;
        if (flags & (ColorEditFlags.DisplayRGB|ColorEditFlags.DisplayHex))
            cedit = col.AsRGB(1, true/*clone*/);
        else
        if (flags & ColorEditFlags.DisplayHSV)
            cedit = col.AsHSV();
        else
            console.assert(0, "Unimplemented color space for disply");

        if(!alpha)
            cedit = cedit.AsOpaque();

        let ca = cedit.AsArray();
        let ica = cedit.AsIArray();
        let value_changed = false;
        let value_changed_as_float = false;

        if ((flags & (ColorEditFlags.DisplayRGB | ColorEditFlags.DisplayHSV)) != 0
            && (flags & ColorEditFlags.NoInputs) == 0)
        {
            // RGB/HSV 0..255 Sliders
            const w_item_one  = Math.max(1, Math.floor((w_items_all - (style.ItemInnerSpacing.x)*(components-1))/components));
            const w_item_last = Math.max(1, Math.floor(w_items_all - (w_item_one + style.ItemInnerSpacing.x)*(components-1)));
            const tsize = this.CalcTextSize((flags & ColorEditFlags.Float) ? "M:0.000" : "M:000");
            const hide_prefix = (w_item_one <= tsize.x) ? true : false;
            const ids = [ "##X", "##Y", "##Z", "##W" ];
            const fmt_table_int =
            [
                [   "%3d",   "%3d",   "%3d",   "%3d" ], // Short display
                [ "R:%3d", "G:%3d", "B:%3d", "A:%3d" ], // Long display for RGBA
                [ "H:%3d", "S:%3d", "V:%3d", "A:%3d" ]  // Long display for HSVA
            ];
            const fmt_table_float =
            [
                [   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" ], // Short display
                [ "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" ], // Long display for RGBA
                [ "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" ]  // Long display for HSVA
            ];
            const fmt_idx = hide_prefix ? 0 : (flags & ColorEditFlags.DisplayHSV) ? 2 : 1;
            this.PushItemWidth(w_item_one);
            for (let n = 0; n < components; n++)
            {
                if (n > 0)
                    this.SameLine(0, style.ItemInnerSpacing.x);
                if (n + 1 == components)
                    this.PushItemWidth(w_item_last);
                if (flags & ColorEditFlags.Float)
                {
                    value_changed |= this.DragFloat(ids[n], ca[n], 1/255,
                                            0, hdr ? 0 : 1, fmt_table_float[fmt_idx][n],
                                            function(newval) {
                                                ca[n] = newval;
                                            });
                    value_changed_as_float |= value_changed;
                }
                else
                {
                    value_changed |= this.DragInt(ids[n], ica[n], 1, 0,
                                        hdr ? 0 : 255, fmt_table_int[fmt_idx][n],
                                        function(newval) {
                                            ica[n] = newval;
                                        });
                }
                if (!(flags & ColorEditFlags.NoOptions))
                    this.OpenPopupOnItemClick("context");
            }
            this.PopItemWidth();
            this.PopItemWidth();
        }
        else
        if ((flags & ColorEditFlags.DisplayHex) != 0 &&
            (flags & ColorEditFlags.NoInputs) == 0)
        {
            // RGB Hexadecimal Input
            let buf = cedit.AsHashStr(!alpha);
            this.PushItemWidth(w_items_all);
            this.InputText("##Text", buf,
                            InputTextFlags.CharsHexadecimal |
                            InputTextFlags.CharsUppercase,
                            (newval) => {
                value_changed = true;
                ica[0] = ica[1] = ica[2] = ica[3] = 0;
                let k=0;
                for(let j=1;j<newval.length;j+=2) // skip leading #, pairs
                {
                    ica[k++] = parseInt(newval.slice(j, j+2), 16);
                }
            });
            if (!(flags & ColorEditFlags.NoOptions))
                this.OpenPopupOnItemClick("context");
            this.PopItemWidth();
        }

        let picker_active_window = null;
        if (!(flags & ColorEditFlags.NoSmallPreview))
        {
            if (!(flags & ColorEditFlags.NoInputs))
                this.SameLine(0, style.ItemInnerSpacing.x);

            const col_v4 = Color.FromArray(ca, alpha);
            if (this.ColorButton("##ColorButton", col_v4, flags))
            {
                if (!(flags & ColorEditFlags.NoPicker))
                {
                    // Store current color and open a picker
                    g.ColorPickerRef = col_v4;
                    this.OpenPopup("picker");
                    this.SetNextWindowPos(Vec2.AddXY(
                                    win.DC.LastItemRect.GetBL(),
                                    -1, style.ItemSpacing.y));
                }
            }
            if (!(flags & ColorEditFlags.NoOptions))
                this.OpenPopupOnItemClick("context");

            if (this.BeginPopup("picker"))
            {
                picker_active_window = g.CurrentWindow;
                if(label.length > 0)
                {
                    this.textEx(label);
                    this.Spacing();
                }
                let picker_flags_to_forward = ColorEditFlags.DataTypeMask |
                                              ColorEditFlags.PickerMask |
                                              ColorEditFlags.InputMask |
                                              ColorEditFlags.DIsplayRGB |
                                              ColorEditFlags.DIsplayHSV |
                                              ColorEditFlags.HDR |
                                              ColorEditFlags.NoAlpha |
                                              ColorEditFlags.AlphaBar;
                let picker_flags = (flags_untouched & picker_flags_to_forward) |
                                              ColorEditFlags.NoLabel |
                                              ColorEditFlags.AlphaPreviewHalf;
                this.PushItemWidth(square_sz * 12); // Use 256 + bar sizes?
                value_changed |= this.ColorPicker4("##picker", col, picker_flags,
                                                    g.ColorPickerRef);
                this.PopItemWidth();
                this.EndPopup();
            }
        }

        if (label.length > 0 && !(flags & ColorEditFlags.NoLabel))
        {
            this.SameLine(0, style.ItemInnerSpacing.x);
            this.textEx(label);
        }

        // Convert back
        if (value_changed && picker_active_window == null)
        {
            if (!value_changed_as_float)
            {
                for (let n = 0; n < 4; n++)
                    ca[n] = ica[n] / 255;
            }
            if ((flags & ColorEditFlags.DisplayHSV) &&
                (flags & ColorEditFlags.InputRGB))
            {
                let cc = Color.hsva(ca[0], ca[1], ca[2], ca[3]);
                let cr = cc.AsRGB();
                ca = cr.AsArray();
            }
            if ((flags & ColorEditFlags.DisplayRGB) &&
                (flags & ColorEditFlags.InputHSV))
            {
                let cc = Color.rgba(ca[0], ca[1], ca[2], ca[3]);
                let cr = cc.AsHSV();
                ca = cr.AsArray();
            }

            col.x = ca[0]; // <-----------------------
            col.y = ca[1];
            col.z = ca[2];
            if (alpha)
                col.a = ca[3];
            col.Dirty();
        }

        this.PopID(); // }
        this.EndGroup();

        // Drag and Drop Target
        // NB: The flag test is merely an optional micro-optimization,
        // BeginDragDropTarget() does the same test.
        if ((win.DC.LastItemStatusFlags & ItemStatusFlags.HoveredRect) &&
            !(flags & ColorEditFlags.NoDragDrop) &&
            this.BeginDragDropTarget())
        {
            let accepted_drag_drop = false;
            let payload = this.AcceptDragDropPayload(DragPayloads.COLOR_3F);
            if (payload)
            {
                col.Copy(payload.Data);
                value_changed = accepted_drag_drop = true;
            }
            payload = this.AcceptDragDropPayload(DragPayloads.COLOR_4F);
            if (payload )
            {
                col.Copy(payload.Data);
                value_changed = accepted_drag_drop = true;
            }

            // Drag-drop payloads are always RGB
            if (accepted_drag_drop && (flags & ColorEditFlags.InputHSV))
            {
                let c2 = col.AsHSV();
                col.Copy(c2);
            }
            this.EndDragDropTarget();
        }

        // When picker is being actively used, use its active id so IsItemActive()
        // will function on ColorEdit4().
        if (picker_active_window && g.ActiveId != 0 &&
            g.ActiveIdWindow == picker_active_window)
        {
            win.DC.LastItemId = g.ActiveId;
        }

        if (value_changed)
            this.markItemEdited(win.DC.LastItemId);

        return value_changed;
    },

    // display a colored square/button, hover for details, return true when pressed.
    // FIXME: May want to display/ignore the alpha component in the color display?
    // Yet show it in the tooltip. 'desc_id' is not called 'label' because we
    // don't display it next to the button, but only in the tooltip.
    // Note that 'col' may be encoded in HSV if ColorEditFlags.InputHSV is set.
    ColorButton(desc_id, col, flags=0, size=Vec2.Zero())
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        const style = g.Style;
        const id = win.GetID(desc_id);
        let default_size = this.GetFrameHeight();
        if (size.x == 0)
            size.x = default_size;
        if (size.y == 0)
            size.y = default_size;
        const bb = new Rect(win.DC.CursorPos,
                            Vec2.Add(win.DC.CursorPos, size));
        this.itemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0);
        if (!this.itemAdd(bb, id))
            return false;

        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(bb, id, hovered, held);

        if (flags & ColorEditFlags.NoAlpha)
            flags &= ~(ColorEditFlags.AlphaPreview | ColorEditFlags.AlphaPreviewHalf);

        let col_rgb = col.AsRGB(1, true/*clone*/);
        let col_rgb_noalpha = col_rgb.AsOpaque();
        let grid_step = Math.min(size.x, size.y) / 2.99;
        let rounding = Math.min(g.Style.FrameRounding, grid_step * 0.5);
        let bb_inner = bb.Clone();
        let off = -0.75; // The border (using Col_FrameBg) tends to look off when
                         // color is near-opaque and rounding is enabled. This
                         // offset seemed like a good middle ground to reduce
                         // those artifacts.
        bb_inner.Expand(off);
        if ((flags & ColorEditFlags.AlphaPreviewHalf) && col_rgb.a < 1.0)
        {
            let mid_x = Math.floor((bb_inner.Min.x + bb_inner.Max.x) * 0.5 + 0.5);
            this.renderColorRectWithAlphaCheckerboard(
                new Vec2(bb_inner.Min.x + grid_step, bb_inner.Min.y),
                bb_inner.Max, col_rgb, grid_step,
                new Vec2(-grid_step + off, off), rounding,
                CornerFlags.TopRight | CornerFlags.BotRight);
            win.DrawList.AddRectFilled(bb_inner.Min, new Vec2(mid_x, bb_inner.Max.y),
                                        col_rgb_noalpha, rounding,
                                        CornerFlags.TopLeft|CornerFlags.BotLeft);
        }
        else
        {
            // Because GetColorU32() multiplies by the global style Alpha and we
            // don't want to display a checkerboard if the source code had no alpha
            let col_source = (flags & ColorEditFlags.AlphaPreview) ? col_rgb : col_rgb_noalpha;
            if (col_source.a < 1.)
                this.renderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max,
                        col_source, grid_step, new Vec2(off, off), rounding);
            else
                win.DrawList.AddRectFilled(bb_inner.Min, bb_inner.Max, col_source,
                       rounding, CornerFlags.All);
        }
        this.renderNavHighlight(bb, id);
        if (g.Style.FrameBorderSize > 0)
            this.renderFrameBorder(bb.Min, bb.Max, rounding);
        else
        {
            // Color button are often in need of some sort of border
            win.DrawList.AddRect(bb.Min, bb.Max, style.GetColor("FrameBg"), rounding);
        }

        // Drag and Drop Source
        // NB: The ActiveId test is merely an optional micro-optimization,
        // BeginDragDropSource() does the same test.
        if (g.ActiveId == id && !(flags & ColorEditFlags.NoDragDrop) &&
            this.BeginDragDropSource())
        {
            if (flags & ColorEditFlags.NoAlpha)
                this.SetDragDropPayload(DragPayloads.COLOR_3F, col_rgb_noalpha,
                                        CondFlags.Once);
            else
                this.SetDragDropPayload(DragPayloads.COLOR_4F, col_rgb,
                                        CondFlags.Once);
            this.ColorButton(desc_id, col, flags);
            this.SameLine();
            this.textEx("Color");
            this.EndDragDropSource();
        }

        // Tooltip
        if (!(flags & ColorEditFlags.NoTooltip) && hovered.get())
        {
            this.colorTooltip(desc_id, col,
                    flags & (ColorEditFlags.InputMask |
                             ColorEditFlags.NoAlpha |
                             ColorEditFlags.AlphaPreview |
                             ColorEditFlags.AlphaPreviewHalf));
        }

        if (pressed)
            this.markItemEdited(id);

        return pressed;
    },

    // Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
    colorTooltip(text, col, flags)
    {
        let g = this.guictx;
        this.beginTooltipEx(0, true);
        let label = text.split("##")[0];
        if (label.length)
        {
            this.textEx(label);
            this.Separator();
        }

        let sz = new Vec2(g.FontSize * 3 + g.Style.FramePadding.y * 2,
                        g.FontLineHeight * 3 + g.Style.FramePadding.y * 2);
        this.ColorButton("##preview", col, (flags & (ColorEditFlags.InputMask |
                                                    ColorEditFlags.NoAlpha |
                                                    ColorEditFlags.AlphaPreview |
                                                    ColorEditFlags.AlphaPreviewHalf)) |
                                                    ColorEditFlags.NoTooltip,
                        sz);
        this.SameLine();
        this.Text(col.AsMultiStr(flags & ColorEditFlags.NoAlpha));
        this.EndTooltip();
    },

};
// =====================================================================================================================
// widgets/coloredit.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/texteditState.js BEGIN
// =====================================================================================================================

// Support for editable text.
//  - only instantiate one TextEdit object for each window. Reused according
//    to window focus.
//  - since javscript strings are immutable, we require that they be passed
//    around by reference. A trivial MutablieString class is provided for
//    that purpose.
//  - meta-keys are managed by client.
//  - derived from imstb_textedit.h which itself is derived from
//      https://github.com/nothings/stb.
//  - Licensed under MIT and "unlicense"

var TextEditMetaKeys =
{
    Left: 0x10000,         // cursor left
    Right: 0x10001,        // cursor right
    Up: 0x10002,           // cursor up
    Down: 0x10003,         // cursor down
    LineStart: 0x10004,    // cursor to start of line
    LineEnd: 0x10005,      // cursor to end of line
    TextStart: 0x10006,    // cursor to start of text
    TextEnd: 0x10007,      // cursor to end of text
    Delete: 0x10008,       // delete selection or character under cursor
    Backspace: 0x10009,    // delete selection or character left of cursor
    Undo: 0x1000A,         // perform undo
    Redo: 0x1000B,         // perform redo
    WordLeft: 0x1000C,     // cursor left one word
    WordRight: 0x1000D,    // cursor right one word
    ToggleInsert: 0x1000E,
    Insert: 0x1000F,
    Shift: 0x20000,
};

// UndoRecord tracks two textedit operations:
//  1. delete length (no CharStorage)
//  2. insert length (yes CharStorage)
const UndoOp =
{
    Insert:1,
    Replace:2,
    Delete:4,
    DoneFlag:8
};

class UndoRecord
{
    constructor(op, where, insertLen, deleteLen, str)
    {
        this.op = op; // the op represents what we must *undo*
        this.where = where;
        this.insertLen = insertLen;
        this.deleteLen = deleteLen;
        switch(this.op)
        {
        case UndoOp.Insert:
            this.charStorage = null;
            break;
        case UndoOp.Delete:
        case UndoOp.Replace:
            this.charStorage = str.GetChars(where, deleteLen);
            break;
        }
        this.op |= UndoOp.DoneFlag;
    }

    Undo(str)
    {
        switch(this.op)
        {
        case UndoOp.Insert | UndoOp.DoneFlag:
            // delete inserted chars from str, store them
            // for potential redo
            this.charStorage = str.GetChars(this.where, this.insertLen);
            str.DeleteChars(this.where, this.insertLen);
            break;
        case UndoOp.Delete | UndoOp.DoneFlag:
            // reinsert the deleted chars
            str.InsertChars(this.where, this.charStorage);
            break;
        case UndoOp.Replace | UndoOp.DoneFlag:
            // undo replace: delete/copy insertLen, then insert
            //
            {
                let newchars = str.GetChars(this.where, this.insertLen);
                str.DeleteChars(this.where, this.insertLen);
                str.InsertChars(this.where, this.charStorage);
                this.charStorage = newchars;
            }
            break;
        default:
            console.assert(0, "most unexpected undo");
            break;
        }
        this.op &= ~UndoOp.DoneFlag;
    }

    Redo(str)
    {
        switch(this.op)
        {
        case UndoOp.Insert:
            console.assert(this.charStorage);
            str.InsertChars(this.where, this.charStorage);
            break;
        case UndoOp.Delete:
            console.assert(this.charStorage == str.GetChars(this.where, this.deleteLen));
            str.DeleteChars(this.where, this.insertLen);
            break;
        case UndoOp.Replace:
            {
                let oldchars = str.GetChars(this.where, this.deleteLen);
                str.DeleteChars(this.where, this.deleteLen);
                str.InsertChars(this.where, this.charStorage);
                this.charStorage = oldchars;
            }
            break;
        default:
            console.assert(0, "most unexpected redo");
            break;
        }
        this.op |= UndoOp.DoneFlag;
    }
}

// UndoMgr tracks the state of done, undoable, redoable:
//  * text edit operations push new UndoRecords on the Deque.
//    Insert operations rely on the underlying string to contain
//    the inserted characters.  In contrast a delete operation
//    must include the characters removed.
//  * An undo record has a dual life.  On creation it merely records
//    the underlying operation.  While the record resides on the deque
//    it is either in its undo or its redo state. Ie: after an undo
//    it transmutes itself to the do representation.
//  * Conceptually the current state of the string is the "integral"
//    of all operations on the deque up to the "current". Until the
//    first undo operation, the undoPoint is the tail of the deque.
//    As the user issues repeated undo requests, we decrement the
//    undo point while preserving the deque contents for potential
//    redo.  If we encounter any Track events, we clear the redo
//    state. If we exceed UndoStateCount, we release the oldest
//    undo records (from the "front" of the deque).
class UndoMgr
{
    constructor()
    {
        this.Clear();
    }

    Clear()
    {
        this.cmdDeque = []; // of UndoRecord
        this.cmdIndex = -1; // index into cmdDeque representing "now"
    }

    GetUndoAvailCount()
    {
        Math.max(0, this.cmdIndex+1);
    }

    GetRedoAvailCount()
    {
        Math.max(0, this.cmdDeque.length - this.cmdIndex -1);
    }

    PerformUndo(str)
    {
        if(this.cmdIndex >= 0)
        {
            console.assert(this.cmdIndex < this.cmdDeque.length);
            this.cmdDeque[this.cmdIndex].Undo(str);
            this.cmdIndex--;
        }
    }

    PerformRedo(str)
    {
        let redoIndex = this.cmdIndex+1;
        if(redoIndex < this.cmdDeque.length)
        {
            this.cmdDeque[redoIndex].Redo(str);
            this.cmdIndex = redoIndex;
        }
    }

    // called *after* chars have been insertted
    TrackInsert(where, length)
    {
        this.createUndo(UndoOp.Insert, where, length, 0, null);
    }

    // called *before* deleting chars.
    TrackDelete(str, where, length)
    {
        this.createUndo(UndoOp.Delete, where, 0, length, str);
    }

    // called *before* to delete+insert
    TrackReplace(str, where, oldLen, newLen)
    {
        this.createUndo(UndoOp.Replace, where, oldLen, newLen, str);
    }

    createUndo(op, pos, insertLen, deleteLen, str)
    {
        if(this.cmdIndex < this.cmdDeque.length-1)
            this.cmdDeque.length = this.cmdIndex+1; // flush our redo

        let r = new UndoRecord(op, pos, insertLen, deleteLen, str);
        this.cmdDeque.push(r);
        this.cmdIndex = this.cmdDeque.length-1;
        return r;
    }
}

// Result of layout query, used to determine where the text in each row is.
class Row
{
    construct()
    {
        this.x0 = 0; // start/end location in row
        this.x1 = 0;
        this.baselineYDelta = 0; // position of baseline relative to prior row's
        this.ymin = 0;  // height of row above and below baseline
        this.ymax = 0;
        this.numChars = 0;
    }
}

class FindState
{
    constructor()
    {
        this.x = 0;
        this.y = 0;
        this.height = 0;    // height of line
        this.firstChar = 0; // first char of this row
        this.length = 0;
        this.prevFirst = 0; // first char of previous row
    }
}

// State associated with string editing. We maintain cursor and selection
// state and perform layout, modification and undo/redo.  Client "owns"
// the string which is assumed to implement the MutableString interface.
// We don't store the string internally which makes it easier to share
// an instance across multiple strings.
class TextEditState
{
    constructor(guictx)
    {
        // public member vars

        this.Cursor = -1; // position of the text cursor within the string
        this.SelectStart = 0;
        this.SelectEnd = 0;
        this.InsertMode = 0;

        // private ---
        this.guictx = guictx; // for CurrentFont
        this.initialized = false;
        this.preferredX = undefined; // cursor up/down
        this.singleLine = false;

        this.row = new Row();
        this.finder = new FindState();
        this.undoMgr = new UndoMgr();
    }

    Init(singleLine=true, clearUndo=true)
    {
        if(clearUndo)
            this.undoMgr.Clear();

        this.singleLine = singleLine;

        this.SelectEnd = 0;
        this.SelectStart = 0;
        this.Cursor = 0;
        this.preferredX = null;
        this.cursorAtEndOfLine = 0;
        this.initialized = true;
        this.insertMode = 0;
    }

    // move the cursor to the clicked location, and reset the selection
    Click(str, x, y)
    {
        // In single-line mode, just always make y = 0. This lets the drag
        // keep working if the mouse goes off the top or bottom of the text
        if(this.singleLine)
        {
            this.layoutRow(this.row, str, 0);
            y = this.row.ymin;
        }

        this.Cursor = this.locateCoord(str, x, y);
        this.SelectStart = this.Cursor;
        this.SelectEnd = this.Cursor;
        this.preferredX = null; // !hasPreferredX
    }

    // make the selection/cursor state valid if client altered the string
    ClampCursor(str)
    {
        let n = str.Length();
        if (this.HasSelection())
        {
            if (this.SelectStart > n) this.SelectStart = n;
            if (this.SelectEnd > n) this.SelectEnd = n;
            // if clamping forced them to be equal, move the cursor to match
            if (this.SelectStart == this.SelectEnd)
                this.Cursor = this.SelectStart;
        }
        if (this.Cursor > n)
            this.Cursor = n;
    }

    HasSelection()
    {
        return this.SelectStart != this.SelectEnd;
    }

    GetSelectedText(str)
    {
        if(!this.HasSelection()) return null;
        this.sortSelection();
        return str.GetChars(this.SelectStart, this.SelectEnd-this.SelectStart);
    }

    ClearSelection()
    {
        this.SelectStart = this.SelectEnd = 0;
    }

    SelectAll(str)
    {
        this.SelectStart = 0;
        this.SelectEnd = this.Cursor = str.Length();
        this.preferredX = null;
    }

    GetUndoAvailCount()
    {
        this.undoMgr.GetUndoAvailCount();
    }

    GetRedoAvailCount()
    {
        this.undoMgr.GetRedoAvailCount();
    }

    // move the cursor and selection endpoint to the clicked location
    Drag(str, x, y)
    {
        let p = 0;

        // In single-line mode, just always make y = 0. This lets the drag keep
        // working if the mouse goes off the top or bottom of the text
        if(this.singleLine)
        {
           this.layoutRow(this.row, str, 0);
           y = this.row.ymin;
        }

        if (this.SelectStart == this.SelectEnd)
           this.SelectStart = this.Cursor;

        p = this.locateCoord(str, x, y);
        this.Cursor = this.SelectEnd = p;
    }

    // API cut: delete selection
    Cut(str)
    {
        if(this.HasSelection())
        {
            this.deleteSelection(str);
            this.preferredX = null;
            return 1;
        }
        return 0;
    }

    // API paste: replace existing selection with passed-in text
    Paste(str, newchars)
    {
        // if there's a selection, the paste should delete it
        this.ClampCursor(str);
        this.deleteSelection(str);
        // try to insert the characters
        if (this.insertChars(str, this.Cursor, newchars))
        {
            let len = newchars.length;
            this.undoMgr.TrackInsert(this.Cursor, len);
            this.Cursor += len;
            this.preferredX = null;
            return 1;
        }
        return 0;
    }

    // process a keyboard input
    Key(str,key)
    {
        let c;
        switch (key)
        {
        default:
            c = this.keyToText(key);
            if (c != null)
            {
                let ch = c;
                // can't add newline in single-line mode
                if (c == "\n" && this.singleLine)
                    break;

                if (this.insertMode && !this.HasSelection() &&
                    this.Cursor < str.Length())
                {
                    this.undoMgr.TrackReplace(str, this.Cursor, 1, 1);
                    this.deleteChars(str, this.Cursor, 1);
                    if (this.insertChars(str, this.Cursor, ch))
                    {
                        ++this.Cursor;
                        this.hasPreferredX = null;
                    }
                }
                else
                {
                    this.deleteSelection(str); // implicitly clamps, tracks delete
                    if (this.insertChars(str, this.Cursor, ch))
                    {
                        // console.log(`insert ${ch} before ${this.Cursor}`);
                        this.undoMgr.TrackInsert(this.Cursor, 1);
                        this.Cursor++;
                        this.preferredX = null;
                    }
                }
            }
            break;

        case TextEditMetaKeys.Insert:
            this.insertMode = !this.insertMode;
            break;

        case TextEditMetaKeys.Undo:
            this.undoMgr.PerformUndo(str);
            this.preferredX = null;
            this.ClampCursor(str);
            break;

        case TextEditMetaKeys.Redo:
            this.undoMgr.PerformRedo(str);
            this.preferredX = null;
            this.ClampCursor(str);
            break;

        case TextEditMetaKeys.Left:
            // if currently there's a selection, move cursor to start of selection
            if (this.HasSelection())
                this.moveToFirst();
            else
            if (this.Cursor > 0)
                this.Cursor--;
            this.preferredX = null;
            break;

        case TextEditMetaKeys.Right:
            // if currently there's a selection, move cursor to end of selection
            if (this.HasSelection())
                this.moveToLast(str);
            else
                this.Cursor++;
            this.ClampCursor(str);
            this.preferredX = null;
            break;

        case TextEditMetaKeys.Left | TextEditMetaKeys.Shift:
            this.ClampCursor(str);
            this.prepSelectionAtCursor();
            // move selection left
            if (this.SelectEnd > 0)
                this.SelectEnd--;
            this.Cursor = this.SelectEnd;
            this.preferredX = null;
            break;

        case TextEditMetaKeys.WordLeft:
            if (this.HasSelection())
                this.moveToFirst();
            else
            {
                this.Cursor = this.moveWordLeft(str, this.Cursor);
                this.ClampCursor(str);
            }
            break;

        case TextEditMetaKeys.WordLeft | TextEditMetaKeys.Shift:
            if (this.HasSelection())
                this.prepSelectionAtCursor();

            this.Cursor = this.moveWordLeft(str, this.Cursor);
            this.SelectEnd = this.Cursor;
            this.ClampCursor(str);
            break;

        case TextEditMetaKeys.WordRight:
            if (this.HasSelection())
                this.moveToLast(str);
            else
            {
                this.Cursor = this.moveWordRight(str, this.Cursor);
                this.ClampCursor(str);
            }
            break;

        case TextEditMetaKeys.WordRight | TextEditMetaKeys.Shift:
            if (this.HasSelection())
                this.prepSelectionAtCursor();

            this.Cursor = this.moveWordRight(str, this.Cursor);
            this.SelectEnd = this.Cursor;
            this.ClampCursor(str);
            break;

        case TextEditMetaKeys.Right | TextEditMetaKeys.Shift:
            this.prepSelectionAtCursor();
            // move selection right
            this.SelectEnd++;
            this.ClampCursor(str);
            this.Cursor = this.SelectEnd;
            this.preferredX = null;
            break;

        case TextEditMetaKeys.Down:
        case TextEditMetaKeys.Down | TextEditMetaKeys.Shift:
            {
                if (this.singleLine)
                {
                    // on windows, up&down in single-line behave like left&right
                    key = TextEditMetaKeys.Right | (key & TextEditMetaKeys.Shift);
                    return this.Key(str, key); // retry
                }

                let find = this.finder;
                let row = this.row;
                let i, sel = (key & TextEditMetaKeys.Shift) != 0;

                if (sel)
                    this.prepSelectionAtCursor();
                else
                if (this.HasSelection)
                    this.moveToLast(str);

                // compute current position of cursor point
                this.ClampCursor(str);
                this.findCharPos(str, this.Cursor, this.singleLine, find);

                // now find character position down a row
                if (find.length)
                {
                    let goal_x = this.preferredX != null ? this.preferredX : find.x;
                    let x;
                    let start = find.firstChar + find.length;
                    this.Cursor = start;
                    this.layoutRow(row, str, this.Cursor);
                    x = row.x0;
                    for (i=0; i<row.numChars; ++i)
                    {
                        let dx = this.getWidth(str, start, i);
                        x += dx;
                        if (x > goal_x)
                            break;
                        this.Cursor++;
                    }
                    this.ClampCursor(str);
                    this.preferredX = goal_x;
                    if (sel)
                        this.SelectEnd = this.Cursor;
                }
                else
                {
                    // console.log("down (no length): " + this.Cursor);
                }
            }
            break;

        case TextEditMetaKeys.Up:
        case TextEditMetaKeys.Up | TextEditMetaKeys.Shift:
            {
                if (this.singleLine)
                {
                    // on windows, up&down become left&right
                    key = TextEditMetaKeys.Left | (key & TextEditMetaKeys.Shift);
                    return this.Key(str, key); // retry
                }

                let find = this.finder;
                let row = this.row;
                let i, sel = (key & TextEditMetaKeys.Shift) != 0;

                if (sel)
                    this.prepSelectionAtCursor();
                else
                if (this.HasSelection())
                    this.moveToFirst();

                // compute current position of cursor point
                this.ClampCursor(str);
                this.findCharPos(str, this.Cursor, this.singleLine, find);

                // can only go up if there's a previous row
                if (find.prevFirst != find.firstChar)
                {
                    // now find character position up a row
                    let old = this.Cursor;
                    let goal_x = this.preferredX != null ? this.preferredX : find.x;
                    let x;
                    this.Cursor = find.prevFirst;
                    this.layoutRow(row, str, this.Cursor);
                    if(goal_x > row.x1)
                        this.Cursor += row.numChars-1;
                    else
                    if(row.x1 > 0) // bypass newline-only case
                    {
                        x = row.x0;
                        for (i=0; i < row.numChars; ++i)
                        {
                            let dx = this.getWidth(str, find.prevFirst, i);
                            x += dx;
                            if (x > goal_x)
                                break;
                            this.Cursor++;
                        }
                    }
                    // console.log(`old:${old} goal:${goal_x} => new:${this.Cursor}`);
                    this.ClampCursor(str);
                    this.preferredX = goal_x;
                    if (sel)
                        this.SelectEnd = this.Cursor;
                }
                else
                {
                    // console.log("top:" + this.Cursor);
                }
            }
            break;

        case TextEditMetaKeys.Delete:
        case TextEditMetaKeys.Delete | TextEditMetaKeys.Shift:
            if (this.HasSelection())
                this.deleteSelection(str);
            else
            {
                let n = str.Length();
                if (this.Cursor < n)
                    this.delete(str, this.Cursor, 1);
            }
            this.preferredX = null;
            break;

        case TextEditMetaKeys.Backspace:
        case TextEditMetaKeys.Backspace | TextEditMetaKeys.Shift:
            if (this.HasSelection())
                this.deleteSelection(str);
            else
            {
                this.ClampCursor(str);
                if (this.Cursor > 0)
                {
                    this.delete(str, this.Cursor-1, 1);
                    this.Cursor--;
                }
            }
            this.preferredX = null;
            break;

        case TextEditMetaKeys.TextStart:
            this.Cursor = this.SelectStart = this.SelectEnd = 0;
            this.preferredX = null;
            break;

        case TextEditMetaKeys.TextStart | TextEditMetaKeys.Shift:
            this.prepSelectionAtCursor();
            this.Cursor = this.SelectEnd = 0;
            this.preferredX = null;
            break;

        case TextEditMetaKeys.TextEnd:
            this.Cursor = str.Length();
            this.SelectStart = this.SelectEnd = 0;
            this.preferredX = null;
            break;

        case TextEditMetaKeys.TextEnd | TextEditMetaKeys.Shift:
            this.prepSelectionAtCursor();
            this.Cursor = this.SelectEnd = str.Length();
            this.preferredX = null;
            break;

        case TextEditMetaKeys.LineStart:
            this.ClampCursor(str);
            this.moveToFirst();
            if (this.singleLine)
                this.Cursor = 0;
            else
            while (this.Cursor > 0 && !str.IsNewLine(this.Cursor-1))
                this.Cursor--;
            this.preferredX = null;
            break;

        case TextEditMetaKeys.LineStart | TextEditMetaKeys.Shift:
            this.ClampCursor(str);
            this.prepSelectionAtCursor();
            if (this.singleLine)
                this.Cursor = 0;
            else
            while (this.Cursor > 0 && !str.IsNewLine(this.Cursor-1))
            {
                this.Cursor--;
            }
            this.SelectEnd = this.Cursor;
            this.preferredX = null;
            break;

        case TextEditMetaKeys.LineEnd:
            {
                let n = str.Length();
                this.ClampCursor(str);
                this.moveToFirst();
                if (this.singleLine)
                    this.Cursor = n;
                else
                while (this.Cursor < n && !str.IsNewLine(this.Cursor))
                {
                    this.Cursor++;
                }
                this.preferredX = null;
            }
            break;

        case TextEditMetaKeys.LineEnd | TextEditMetaKeys.Shift:
            {
                let n = str.Length();
                this.ClampCursor(str);
                this.prepSelectionAtCursor();
                if (this.singleLine)
                    this.Cursor = n;
                else
                while (this.Cursor < n && !str.IsNewLine(this.Cursor))
                    this.Cursor++;
                this.SelectEnd = this.Cursor;
                this.preferredX = null;
            }
            break;
        }
    } // end Key()

    // returns information about the shape of one displayed row of characters
    // assuming they start on the i'th character: the width and the height
    // and the number of characters consumed. This allows this library to
    // traverse the entire layout incrementally. You need to compute
    // word-wrapping here.
    layoutRow(row, str, lineStart, stopOnNewline=true)
    {
        let ts = this.CalcTextRunSize(str, lineStart, -1, stopOnNewline);
        row.x0 = 0.;
        row.x1 = ts.x;
        row.baselineYDelta = ts.y;
        row.ymin = 0.;
        row.ymax = ts.y;
        row.numChars = ts.consumed - lineStart;
        // numChars may be 0!
    }

    // returns
    //   { x: width, y: height, consumed: lastIndex}
    CalcTextRunSize(str, lineStart, lineEnd=-1, stopOnNewline=true)
    {
        let g = this.guictx;
        const lineHeight = g.Font.Size * g.Style.TextLineHeightPct;
        let ret = {x: 0, y:0};
        let lineWidth = 0.;
        let i = lineStart;
        if(lineEnd == -1)
            lineEnd = str.Length();
        g.Font.MeasureBegin();
        while (i < lineEnd)
        {
            let c = str.GetCharCode(i++);
            if (c == 10) // 0x0a, "\n"
            {
                ret.x = Math.max(ret.x, lineWidth);
                ret.y += lineHeight;
                lineWidth = 0;
                if (stopOnNewline)
                    break;
                continue;
            }
            if (c == 13) // 0x0d, "\r"
                continue;

            lineWidth += g.Font.MeasureWidth(String.fromCharCode(c));
        }
        ret.consumed = i;
        g.Font.MeasureEnd();
        if (ret.x < lineWidth)
            ret.x = lineWidth;

        if (lineWidth > 0 || ret.y == 0)
            ret.y += lineHeight;

        return ret;
    }

    // returns the pixel delta from the xpos of the i'th character to the xpos
    // of the i+1'th char for a line of characters starting at character n
    // (i.e. accounts for kerning with previous char)
    getWidth(str, lineStart, charIdx)
    {
        let g = this.guictx;
        let c = str.GetChar(lineStart + charIdx);
        if ("\n\r".indexOf(c) != -1) return 0;
        return g.Font.MeasureWidth(c);
    }

    keyToText(key)
    {
        return key >= 0x10000 ? null : String.fromCharCode(key);
    }

    isWordBoundaryFromRight(str, idx)
    {
        return idx > 0 ?
            str.IsSeparator(idx-1) && !str.IsSeparator(idx) : 1;
    }

    moveWordLeft(str, idx)
    {
        idx--;
        while (idx >= 0 && !this.isWordBoundaryFromRight(str, idx))
            idx--;
        return idx < 0 ? 0 : idx;
    }

    moveWordRight(str, idx)
    {
        idx++;
        let len = str.Length();
        while (idx < len && !this.isWordBoundaryFromRight(str, idx))
            idx++;
        return idx > len ? len : idx;
    }

    prepSelectionAtCursor()
    {
        if(!this.HasSelection())
            this.SelectStart = this.SelectEnd = this.Cursor;
        else
            this.Cursor = this.SelectEnd;
    }

    deleteChars(str, pos, n)
    {
        str.DeleteChars(pos, n);
    }

    insertChars(str, pos, newchars)
    {
        // console.log(`insert ${newchars} at $`)
        str.InsertChars(pos, newchars);
        return true; // XXX: a little more care required here.
    }

    // mouse position
    // traverse layout to locate the nearest character to a display position
    locateCoord(str, x, y)
    {
        let r = new Row();
        let n = str.Length();
        let base_y = 0;
        let i=0, k;
        let g = this.guictx;

        r.x0 = r.x1 = 0;
        r.ymin = r.ymax = 0;
        r.numChars = 0;

        try
        {
            g.Font.MeasureBegin(); // MeasureEnd in finally block
            // search rows to find one that straddles 'y'
            while (i < n)
            {
                this.layoutRow(r, str, i);
                if (r.numChars <= 0)
                    return n;
                if (i==0 && y < base_y + r.ymin)
                    return 0;
                if (y < base_y + r.ymax)
                    break;
                i += r.numChars;
                base_y += r.baselineYDelta;
            }

            // below all text, return 'after' last character
            if (i >= n)
                return n;

            // check if it's before the beginning of the line
            if (x < r.x0)
                return i;

            // check if it's before the end of the line
            if (x < r.x1)
            {
                // search characters in row for one that straddles 'x'
                let prev_x = r.x0;
                for (k=0; k < r.numChars; ++k)
                {
                    let w = this.getWidth(str, i, k);
                    let next_x = prev_x + w;
                    if (x < next_x)
                    {
                        if (x < prev_x+w/2)
                            return k+i;
                        else
                            return k+i+1;
                    }
                    prev_x =  next_x;
                }
                // shouldn't happen, but if it does, fall through to end-of-line case
            }

            // if the last character is a newline, return that. otherwise return
            // 'after' the last character
            if (str[i+r.numChars-1] == "\n") // XXX: more newlines?
                return i+r.numChars-1;
            else
                return i+r.numChars;
        }
        finally
        {
            // to handle myriad internal returns
            g.Font.MeasureEnd();
        }
    } // end locateCoord

    // find the x/y location of a character, and remember info about the
    // previous row in case we get a move-up event (for page up, we'll have
    // to rescan)
    findCharPos(str, n, singleLine, find)
    {
        let prev_linestart = 0;
        let z = str.Length();
        let i=0;
        let r = this.row;
        if (n == z) // location of one-past last character
        {
            // if it's at the end, then find the last line -- simpler than
            // trying to explicitly handle this case in the regular code
            if (singleLine)
            {
                this.layoutRow(r, str, 0);
                find.y = 0;
                find.firstChar = 0;
                find.length = z;
                find.height = r.ymax - r.ymin;
                find.x = r.x1;
            }
            else
            {
                find.y = 0;
                find.x = 0;
                find.height = 1;
                while (i < z)
                {
                    this.layoutRow(r, str, i);
                    prev_linestart = i;
                    i += r.numChars;
                }
                find.firstChar = i;
                find.length = 0;
                find.prevFirst = prev_linestart;
            }
            return;
        }
        // cursor is not at end of buffer,
        // search rows to find the one that straddles character n
        find.y = 0;
        while(i < str.Length())
        {
            this.layoutRow(r, str, i);
            if (n < i + r.numChars)
              break;
            prev_linestart = i;
            i += r.numChars;
            find.y += r.baselineYDelta;
        }

        find.firstChar = i;
        find.length = r.numChars;
        find.height = r.ymax - r.ymin;
        find.prevFirst = prev_linestart;

        // now scan to find xpos
        find.x = 0;
        for (i=0; find.firstChar+i < n; ++i)
           find.x += this.getWidth(str, find.firstChar, i);
    }

    // delete characters while updating undo
    delete(str, where, len)
    {
        this.undoMgr.TrackDelete(str, where, len);
        str.DeleteChars(where, len); //
        this.preferredX = null;
    }

    // delete the selection
    deleteSelection(str)
    {
        this.ClampCursor(str);
        if (this.HasSelection())
        {
            if (this.SelectStart < this.SelectEnd)
            {
                this.delete(str, this.SelectStart, this.SelectEnd - this.SelectStart);
                this.SelectEnd = this.Cursor = this.SelectStart;
            }
            else
            {
                this.delete(str, this.SelectEnd, this.SelectStart - this.SelectEnd);
                this.SelectStart = this.Cursor = this.SelectEnd;
            }
            this.preferredX = null;
        }
    }

    // canonicalize the selection so start <= end
    sortSelection()
    {
        if (this.SelectEnd < this.SelectStart)
        {
            let temp = this.SelectEnd;
            this.SelectEnd = this.SelectStart;
            this.SelectStart = temp;
        }
    }

    // move cursor to first character of selection
    moveToFirst()
    {
        if (this.HasSelection())
        {
            this.sortSelection();
            this.Cursor = this.SelectStart;
            this.SelectEnd = this.SelectStart;
            this.preferredX = null;
        }
    }

    // move cursor to last character of selection
    moveToLast(str)
    {
        if (this.HasSelection())
        {
            this.sortSelection();
            this.ClampCursor(str);
            this.Cursor = this.SelectEnd;
            this.SelectStart = this.SelectEnd;
            this.preferredX = null;
        }
    }

}
// =====================================================================================================================
// widgets/texteditState.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/tree.js BEGIN
// =====================================================================================================================


//-------------------------------------------------------------------------
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
//-------------------------------------------------------------------------
// - TreeNode()
// - TreeNodeV()
// - TreeNodeEx()
// - TreeNodeExV()
// - treeNodeBehavior() [Internal]
// - TreePush()
// - TreePop()
// - TreeAdvanceToLabelPos()
// - GetTreeNodeToLabelSpacing()
// - SetNextTreeNodeOpen()
// - CollapsingHeader()
//-------------------------------------------------------------------------

var TreeNodeFlags =
{
    None: 0,
    Selected: 1 << 0,   // Draw as selected
    Framed: 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
    AllowItemOverlap: 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
    NoTreePushOnOpen: 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
    NoAutoOpenOnLog: 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
    DefaultOpen: 1 << 5,   // Default node to be open
    OpenOnDoubleClick: 1 << 6,   // Need double-click to open node
    OpenOnArrow: 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
    Leaf: 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).
    Bullet: 1 << 9,   // Display a bullet instead of arrow
    FramePadding: 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
    //SpanAllAvailWidth: 1 << 11,  // FIXME: TODO: Extend hit box horizontally even if not framed
    //NoScrollOnOpen: 1 << 12,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
    NavLeftJumpsBackHere: 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
};

TreeNodeFlags.CollapsingHeader = TreeNodeFlags.Framed |
                                TreeNodeFlags.NoTreePushOnOpen |
                                TreeNodeFlags.NoAutoOpenOnLog;

var ImguiTreeMixin =
{
    // - TreeNode functions return true when the node is open, in which case
    //  you need to also call TreePop() when you are finished displaying the
    //  tree node contents. In the c binding, there are several variants.
    //  Those accepting varargs produce a label so we just assume that
    //  callers will always produce a unique label and we'll generate
    //  an ID from there.
    //      TreeNode(void*, fmt, ...) // id derived from pointer
    //      TreeNode(char*, fmt, ...) // id derived from string
    //      TreeNode(label, flags // id derived from string
    TreeNode(label, flags=0)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems) return false;
        let g = this.guictx;
        return this.treeNodeBehavior(win.GetID(label), flags,
                                    label.split("##")[0]);
    },

    TreeNodeEx(label, flags=0)
    {
        return this.TreeNode(label, flags);
    },

    // ~ Indent()+PushId(). Already called by TreeNode() when returning true,
    // but you can call TreePush/TreePop yourself if desired.
    TreePush(str_id=null)
    {
        let win = this.getCurrentWindow();
        this.Indent();
        win.DC.TreeDepth++;
        this.PushID(str_id ? str_id : "#TreePush");
    },

    // ~ Unindent()+PopId()
    TreePop()
    {
        let g = this.guictx;
        let win = this.getCurrentWindow();
        this.Unindent();
        win.DC.TreeDepth--;
        if (g.NavMoveDir == Dir.Left && g.NavWindow == win &&
            this.navMoveRequestButNoResultYet())
        {
            if (g.NavIdIsAlive &&
                (win.DC.TreeDepthMayJumpToParentOnPop & (1 << win.DC.TreeDepth)))
            {
                this.setNavID(win.IDStack.back(), g.NavLayer);
                this.navMoveRequestCancel();
            }
        }
        win.DC.TreeDepthMayJumpToParentOnPop &= (1 << win.DC.TreeDepth) - 1;

        // There should always be 1 element in the IDStack (pushed during
        // window creation). If this triggers you called TreePop/PopID too much.
        console.assert(win.IDStack.length > 1);
        this.PopID();
    },

    // advance cursor x position by GetTreeNodeToLabelSpacing()
    TreeAdvanceToLabelPos()
    {
        let g = this.guictx;
        g.CurrentWindow.DC.CursorPos.x += this.GetTreeNodeToLabelSpacing();
    },

    // horizontal distance preceding label when using TreeNode*() or Bullet() ==
    // (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
    GetTreeNodeToLabelSpacing()
    {
        let g = this.guictx;
        return g.FontSize + (g.Style.FramePadding.x * 2.);
    },

    // set next TreeNode/CollapsingHeader open state.
    SetNextTreeNodeOpen(is_open, cond)
    {
        let g = this.guictx;
        if (g.CurrentWindow.SkipItems)
            return;
        g.NextTreeNodeOpenVal = is_open;
        g.NextTreeNodeOpenCond = cond ? cond : CondFlags.Always;
    },

    // if returning 'true' the header is open. doesn't indent nor push on
    // ID stack. user doesn't have to call TreePop().
    // when 'open' isn't NULL, display an additional small close button on
    // upper right of the header
    CollapsingHeader(label, flags=0)
    {
        let win = this.getCurrentWindow();
        if(win.SkipItems) return false;
        return this.treeNodeBehavior(win.GetID(label),
                                flags|TreeNodeFlags.CollapsingHeader, label);
    },

    CollapsingHeaderO(label, p_open=null, flags=0)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems) return false;

        if (p_open && !p_open.get())
            return false;

        let id = win.GetID(label);
        let is_open = this.treeNodeBehavior(id,
                            flags|TreeNodeFlags.CollapsingHeader|
                            (p_open ? TreeNodeFlags.AllowItemOverlap:0), label);
        if (p_open)
        {
            // Create a small overlapping close button
            // FIXME: We can  evolve this into user accessible helpers to add
            // extra buttons on title bars, headers, etc.
            let g = this.guictx;
            let last_item_backup = new ItemHoveredDataBackup(g);
            let button_radius = g.FontSize * 0.5;
            let button_center = new Vec2(
                    Math.min(win.DC.LastItemRect.Max.x, win.ClipRect.Max.x) - g.Style.FramePadding.x - button_radius,
                    win.DC.LastItemRect.GetCenter().y);
            if (this.CloseButton(win.GetID(id+"_1"), button_center, button_radius))
                p_open.set(false);
            else
                p_open.set(true);
            last_item_backup.Restore();
        }
        return is_open;
    },

    treeNodeBehavior(id, flags, label)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        const style = g.Style;
        const display_frame = (flags & TreeNodeFlags.Framed) != 0;
        const padding = (display_frame || (flags & TreeNodeFlags.FramePadding)) ?
                    style.FramePadding : new Vec2(style.FramePadding.x, 0.);
        const label_size = this.CalcTextSize(label, false);

        // We vertically grow up to current line height up the typical widget height.
        const text_base_offset_y = Math.max(padding.y, win.DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
        const frame_height = Math.max(Math.min(win.DC.CurrentLineHeight,
                                            g.FontSize+style.FramePadding.y*2),
                                      label_size.y + padding.y*2);
        let frame_bb = Rect.FromXY(win.DC.CursorPos,
                                    win.Pos.x + this.GetContentRegionMax().x,
                                    win.DC.CursorPos.y + frame_height);
        if (display_frame)
        {
            // Framed header expand a little outside the default padding
            frame_bb.Min.x -= Math.floor(win.WindowPadding.x*0.5) - 1;
            frame_bb.Max.x += Math.floor(win.WindowPadding.x*0.5) - 1;
        }

        // Collapser arrow width + Spacing
        const text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));
        // Include collapser
        const text_width = g.FontSize + (label_size.x > 0 ? label_size.x + padding.x*2 : 0);
        this.itemSize(new Vec2(text_width, frame_height), text_base_offset_y);

        // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
        // (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)
        const interact_bb = display_frame ? frame_bb : Rect.FromXY(frame_bb.Min,
                                frame_bb.Min.x + text_width + style.ItemSpacing.x*2,
                                frame_bb.Max.y);
        let is_open = this.treeNodeBehaviorIsOpen(id, flags);
        let is_leaf = (flags & TreeNodeFlags.Leaf) != 0;

        // Store a flag for the current depth to tell if we will allow closing
        // this node when navigating one of its child. For this purpose we
        // essentially compare if g.NavIdIsAlive went from 0 to 1 between
        // TreeNode() and TreePop(). This currently only supports 32 level
        // deep and we are fine with (1 << Depth) overflowing into a zero.
        if (is_open && !g.NavIdIsAlive &&
            (flags & TreeNodeFlags.NavLeftJumpsBackHere) &&
            !(flags & TreeNodeFlags.NoTreePushOnOpen))
        {
            win.DC.TreeDepthMayJumpToParentOnPop |= (1 << win.DC.TreeDepth);
        }

        let item_add = this.itemAdd(interact_bb, id);
        win.DC.LastItemStatusFlags |= ItemStatusFlags.HasDisplayRect;
        win.DC.LastItemDisplayRect = frame_bb;
        if (!item_add)
        {
            if (is_open && !(flags & TreeNodeFlags.NoTreePushOnOpen))
                this.treePushRawID(id);
            return is_open;
        }

        // Flags that affects opening behavior:
        // - 0 (default) .................... single-click anywhere to open
        // - OpenOnDoubleClick .............. double-click anywhere to open
        // - OpenOnArrow .................... single-click on arrow to open
        // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open
        let button_flags = ButtonFlags.NoKeyModifiers;
        if (flags & TreeNodeFlags.AllowItemOverlap)
            button_flags |= ButtonFlags.AllowItemOverlap;
        if (flags & TreeNodeFlags.OpenOnDoubleClick)
        {
            button_flags |= ButtonFlags.PressedOnDoubleClick |
                ((flags & TreeNodeFlags.OpenOnArrow) ? ButtonFlags.PressedOnClickRelease : 0);
        }
        if (!is_leaf)
            button_flags |= ButtonFlags.PressedOnDragDropHold;

        let selected = (flags & TreeNodeFlags.Selected) != 0;
        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(interact_bb, id, hovered, held, button_flags);
        let toggled = false;
        if (!is_leaf)
        {
            if (pressed)
            {
                toggled = !(flags & (TreeNodeFlags.OpenOnArrow | TreeNodeFlags.OpenOnDoubleClick))
                            || (g.NavActivateId == id);
                if (flags & TreeNodeFlags.OpenOnArrow)
                {
                    toggled |= this.IsMouseHoveringRect(interact_bb.Min,
                                    new Vec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y))
                                && (!g.NavDisableMouseHover);
                }
                if (flags & TreeNodeFlags.OpenOnDoubleClick)
                    toggled |= g.IO.MouseDoubleClicked[0];
                // When using Drag and Drop "hold to open" we keep the node
                // highlighted after opening, but never close it again.
                if (g.DragDropActive && is_open)
                    toggled = false;
            }

            if (g.NavId == id && g.NavMoveRequest &&
                g.NavMoveDir == Dir.Left && is_open)
            {
                toggled = true;
                this.navMoveRequestCancel();
            }
            // If there's something upcoming on the line we may want to
            // give it the priority?
            if (g.NavId == id && g.NavMoveRequest &&
                g.NavMoveDir == Dir.Right && !is_open)
            {
                toggled = true;
                this.navMoveRequestCancel();
            }

            if (toggled)
            {
                is_open = !is_open;
                win.DC.StateStorage.SetInt(id, is_open);
            }
        }
        if (flags & TreeNodeFlags.AllowItemOverlap)
            this.SetItemAllowOverlap();

        // Render
        const col = style.GetColor((held.get() && hovered.get()) ?
            "HeaderActive" : hovered.get() ? "HeaderHovered" : "Header");
        const text_pos = Vec2.AddXY(frame_bb.Min, text_offset_x, text_base_offset_y);
        let nav_highlight_flags = NavHighlightFlags.TypeThin;
        if (display_frame)
        {
            // Framed type
            this.renderFrame(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding);
            this.renderNavHighlight(frame_bb, id, nav_highlight_flags);
            this.renderArrow(Vec2.AddXY(frame_bb.Min, padding.x, text_base_offset_y),
                            is_open ? Dir.Down : Dir.Right, 1.);
            if (g.LogEnabled)
            {
                // NB: '##' is normally used to hide text (as a library-wide feature),
                // so we need to specify the text range to make sure the ## aren't
                // stripped out here.
                const log_prefix = "\n##";
                const log_suffix = "##";
                this.LogRenderedText(text_pos, log_prefix);
                this.renderTextClipped(text_pos, frame_bb.Max, label);
                this.LogRenderedText(text_pos, log_suffix);
            }
            else
            {
                this.renderTextClipped(text_pos, frame_bb.Max, label, label_size);
            }
        }
        else
        {
            // Unframed typed for tree nodes
            if (hovered.get() || selected)
            {
                this.renderFrame(frame_bb.Min, frame_bb.Max, col, false);
                this.renderNavHighlight(frame_bb, id, nav_highlight_flags);
            }

            if (flags & TreeNodeFlags.Bullet)
            {
                this.renderBullet(Vec2.AddXY(frame_bb.Min,
                        text_offset_x * 0.5, g.FontSize*0.5 + text_base_offset_y));
            }
            else
            if (!is_leaf)
            {
                this.renderArrow(Vec2.AddXY(frame_bb.Min, padding.x,
                                        g.FontSize*0.15 + text_base_offset_y),
                                is_open ? Dir.Down : Dir.Right, 0.70);
            }
            this.renderText(text_pos, label, false);
        }

        if (is_open && !(flags & TreeNodeFlags.NoTreePushOnOpen))
            this.treePushRawID(id);
        return is_open;
    }, // end treeNodeBehavior

    treeNodeBehaviorIsOpen(id, flags)
    {
        if (flags & TreeNodeFlags.Leaf)
            return true;

        // We only write to the tree storage if the user clicks (or explicitly
        // use SetNextTreeNode*** functions)
        let g = this.guictx;
        let win = g.CurrentWindow;
        let storage = win.DC.StateStorage;
        let is_open;
        if (g.NextTreeNodeOpenCond != 0)
        {
            if (g.NextTreeNodeOpenCond & CondFlags.Always)
            {
                is_open = g.NextTreeNodeOpenVal;
                storage.SetInt(id, is_open);
            }
            else
            {
                // We treat Cond.Once and Cond.FirstUseEver the same because
                // tree node state are not saved persistently.
                const stored_value = storage.GetInt(id, -1);
                if (stored_value == -1)
                {
                    is_open = g.NextTreeNodeOpenVal;
                    storage.SetInt(id, is_open);
                }
                else
                {
                    is_open = stored_value != 0;
                }
            }
            g.NextTreeNodeOpenCond = 0;
        }
        else
        {
            let def = (flags&TreeNodeFlags.DefaultOpen) ? 1 : 0;
            is_open = 0 != storage.GetInt(id, def);
        }

        // When logging is enabled, we automatically expand tree nodes
        // (but *NOT* collapsing headers.. seems like sensible behavior).
        // NB- If we are above max depth we still allow manually opened
        // nodes to be logged.
        if (g.LogEnabled && !(flags & TreeNodeFlags.NoAutoOpenOnLog) &&
            (win.DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)
            is_open = true;

        return is_open;
    },

    treePushRawID(id)
    {
        let w = this.getCurrentWindow();
        this.Indent();
        w.DC.TreeDepth++;
        w.IDStack.push(id);
    }
};
// =====================================================================================================================
// widgets/tree.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/plot.js BEGIN
// =====================================================================================================================


var PlotType =
{
    Lines: 0,
    Histogram: 1,
    Signal: 2,  // audio samples
};

var PlotFlags =
{
    Default: 0,
    NoTip:   1,

};

var ImguiPlotMixin =
{
    //-------------------------------------------------------------------------
    // [SECTION] Widgets: PlotLines, PlotHistogram
    //-------------------------------------------------------------------------
    // - PlotLines() (two variants)
    // - PlotHistogram() (two variants)
    // - plotEx() [Internal]
    //-------------------------------------------------------------------------
    PlotLines(label, values,
            values_offset=0, overlay_text=null,
            scale_min=Number.MAX_VALUE, scale_max=Number.MAX_VALUE,
            graph_size=Vec2.Zero(), stride=1, flags=0)
    {
        let getter = function(i)
        {
            return values[i*stride];
        };
        this.plotEx(PlotType.Lines, label, getter, values.length, values_offset,
            overlay_text, scale_min, scale_max, graph_size, flags);
    },

    PlotLinesCB(label, getter, values_count,
            values_offset=0, overlay_text=null,
            scale_min=Number.MAX_VALUE, scale_max=Number.MAX_VALUE,
            graph_size=Vec2.Zero(), roi=null, flags=0)
    {
        this.plotEx(PlotType.Lines, label, getter, values_count, values_offset,
            overlay_text, scale_min, scale_max, graph_size, roi, flags);
    },

    PlotSignal(label, values,
            values_offset=0, overlay_text=null,
            scale_min=Number.MAX_VALUE, scale_max=Number.MAX_VALUE,
            graph_size=Vec2.Zero(), roi=null, flags=0)
    {
        let getter = function(i)
        {
            return values[i];
        };
        this.plotEx(PlotType.Signal, label, getter, values.length, values_offset,
            overlay_text, scale_min, scale_max, graph_size, roi, flags);
    },

    PlotSignalCB(label, getter, values,
            values_offset=0, overlay_text=null,
            scale_min=Number.MAX_VALUE, scale_max=Number.MAX_VALUE,
            graph_size=Vec2.Zero(), roi=null, flags=0)
    {
        this.plotEx(PlotType.Signal, label, getter, values.length, values_offset,
            overlay_text, scale_min, scale_max, graph_size, roi, flags);
    },

    PlotHistogram(label, values,
            values_offset=0, overlay_text=null,
            scale_min=Number.MAX_VALUE, scale_max=Number.MAX_VALUE,
            graph_size=Vec2.Zero(), stride=1, roi=null, flags=0)
    {
        let getter = function(i)
        {
            return values[i*stride];
        };
        this.plotEx(PlotType.Histogram, label, getter, values.length, values_offset,
            overlay_text, scale_min, scale_max, graph_size, roi, flags);
    },

    PlotHistogramCB(label, getter, values_count,
            values_offset=0, overlay_text=null,
            scale_min=Number.MAX_VALUE, scale_max=Number.MAX_VALUE,
            graph_size=Vec2.Zero(), roi=null, flags=0)
    {
        this.plotEx(PlotType.Histogram, label, getter, values_count, values_offset,
            overlay_text, scale_min, scale_max, graph_size, roi, flags);
    },

    plotEx(plotType, label, getter, values_count, values_offset, overlay_text,
            scale_min, scale_max, frame_size, roi, flags)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let g = this.guictx;
        const style = g.Style;
        const id = win.GetID(label);

        const label_size = this.CalcTextSize(label, true);
        if (frame_size.x == 0)
            frame_size.x = this.getNextItemWidth();
        if (frame_size.y == 0)
            frame_size.y = label_size.y + (style.FramePadding.y * 2);

        const frame_bb = new Rect(win.DC.CursorPos,
                                Vec2.Add(win.DC.CursorPos, frame_size));
        const inner_bb = new Rect(Vec2.Add(frame_bb.Min, style.FramePadding),
                                Vec2.Subtract(frame_bb.Max, style.FramePadding));
        const total_bb = new Rect(frame_bb.Min,
                                    Vec2.AddXY(frame_bb.Max,
                                      label_size.x > 0 ?
                                        style.ItemInnerSpacing.x+label_size.x : 0,
                                      0));
        this.itemSize(total_bb, style.FramePadding.y);
        if (!this.itemAdd(total_bb, 0, frame_bb))
            return;
        const hovered = this.itemHoverable(frame_bb, id);

        // Determine scale from values if not specified
        if (scale_min == Number.MAX_VALUE || scale_max == Number.MAX_VALUE)
        {
            let v_min = Number.MAX_VALUE;
            let v_max = -Number.MAX_VALUE;
            for (let i = 0; i < values_count; i++)
            {
                const v = getter(i);
                if (isNaN(v)) // Ignore NaN values
                    continue;
                v_min = Math.min(v_min, v);
                v_max = Math.max(v_max, v);
            }
            if (scale_min == Number.MAX_VALUE)
                scale_min = v_min;
            if (scale_max == Number.MAX_VALUE)
                scale_max = v_max;
        }

        this.renderFrame(frame_bb.Min, frame_bb.Max,
                        style.GetColor("PlotBg"), true, style.FrameRounding);

        const values_count_min = (plotType == PlotType.Lines) ? 2 : 1;
        if (values_count >= values_count_min)
        {
            let res_w = Math.min(Math.floor(frame_size.x), values_count) +
                        ((plotType == PlotType.Lines) ? -1 : 0);
            let item_count = values_count + ((plotType == PlotType.Lines) ? -1 : 0);
            let roiPx;
            let colHovered, col, colDimmed;
            if(roi)
                roiPx = [roi[0]*res_w, roi[1]*res_w];

            switch(plotType)
            {
            case PlotType.Lines:
                col = style.GetColor("PlotLines");
                colHovered = style.GetColor("PlotLinesHovered");
                if(roiPx)
                    colDimmed = style.GetColor("PlotLinesDimmed");
                else
                    colDimmed = col;
                break;
            case PlotType.Signal:
                col = style.GetColor("PlotSignal");
                colHovered = style.GetColor("PlotSignalHovered");
                if(roiPx)
                    colDimmed = style.GetColor("PlotSignalDimmed");
                else
                    colDimmed = col;
                break;
            case PlotType.Histogram:
                col = style.GetColor("PlotHistogram");
                colHovered = style.GetColor("PlotHistogramHovered");
                if(roiPx)
                    colDimmed = style.GetColor("PlotHistogramDimmed");
                else
                    colDimmed = col;
                break;
            }

            // Tooltip on hover
            let v_hovered = -1;
            if (!(flags&PlotFlags.NoTip) && hovered &&
                inner_bb.Contains(g.IO.MousePos))
            {
                const t = Vec1.Clamp((g.IO.MousePos.x-inner_bb.Min.x) /
                                     (inner_bb.Max.x - inner_bb.Min.x),
                                     0., 0.9999);
                const v_idx = Math.floor(t * item_count);
                console.assert(v_idx >= 0 && v_idx < values_count);

                const v0 = getter((v_idx + values_offset) % values_count);
                const v1 = getter((v_idx + 1 + values_offset) % values_count);
                switch(plotType)
                {
                case PlotType.Lines:
                    this.SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx+1, v1);
                    break;
                case PlotType.Signal:
                    this.SetTooltip("%d: %8.4g", v_idx, v0);
                    break;
                case PlotType.Histogram:
                    this.SetTooltip("%d: %8.4g", v_idx, v0);
                    break;
                }
                v_hovered = v_idx;
            }

            const t_step = 1 / res_w;
            const inv_scale = (scale_min == scale_max) ? 0 :
                                    (1/(scale_max - scale_min));

            let v0 = getter((0 + values_offset) % values_count);
            let t0 = 0.0;
            // Point in the normalized space of our target rectangle
            let tp0 = new Vec2(t0, 1. - Vec1.Saturate((v0 - scale_min) * inv_scale));
            let histogram_zero_line_t = (scale_min * scale_max < 0) ?
                    (-scale_min * inv_scale) :
                    (scale_min < 0 ? 0 : 1);   // Where does the zero line stand

            let tp1 = new Vec2();
            let lines = [];
            for (let n = 0; n < res_w; n++)
            {
                const t1 = t0 + t_step;
                const v1_idx = Math.floor(t0 * item_count + 0.5);
                console.assert(v1_idx >= 0 && v1_idx < values_count);
                const v1 = getter((v1_idx + values_offset + 1) % values_count);
                tp1.x = t1;
                tp1.y = 1 - Vec1.Saturate((v1 - scale_min) * inv_scale);

                let pos0, pos1;
                let c;
                if(v_hovered == v1_idx)
                    c = colHovered;
                else
                {
                    if(roiPx && (n < roiPx[0] || n > roiPx[1]))
                        c = colDimmed;
                    else
                        c = col;
                }
                switch(plotType)
                {
                case PlotType.Lines:
                    pos0 = Vec2.Lerp(inner_bb.Min, inner_bb.Max, tp0);
                    pos1 = Vec2.Lerp(inner_bb.Min, inner_bb.Max, tp1);
                    lines.push([pos0, pos1, c.AsStr()]);
                    //win.DrawList.AddLine(pos0, pos1, c);
                    break;
                case PlotType.Signal:
                    // we can overwrite tp0, since it's stomped each loop
                    pos0 = Vec2.Lerp(inner_bb.Min, inner_bb.Max, tp0);
                    tp0.y = 1 - Vec1.Saturate((-v1 - scale_min) * inv_scale);
                    pos1 = Vec2.Lerp(inner_bb.Min, inner_bb.Max, tp0);
                    lines.push([pos0, pos1, c.AsStr()]);
                    // win.DrawList.AddLine(pos0, pos1, c);
                    break;
                case PlotType.Histogram:
                    pos0 = Vec2.Lerp(inner_bb.Min, inner_bb.Max, tp0);
                    pos1 = Vec2.Lerp(inner_bb.Min, inner_bb.Max,
                                new Vec2(tp1.x, histogram_zero_line_t));
                    if (pos1.x >= pos0.x + 2.)
                        pos1.x -= 1;
                    win.DrawList.AddRectFilled(pos0, pos1, c);
                    break;
                }
                t0 = t1;
                tp0.Copy(tp1);
            }
            if(lines.length)
                win.DrawList.AddLines(lines);
        }

        // Text overlay
        if (overlay_text)
        {
            this.renderTextClipped(
                new Vec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y),
                frame_bb.Max, overlay_text, null, new Vec2(0.5,0));
        }

        if (label_size.x > 0)
        {
            this.renderText(
                new Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y),
                label);
        }

    }
};
// =====================================================================================================================
// widgets/plot.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/popup.js BEGIN
// =====================================================================================================================


var PopupPositionPolicy = // enum
{
    Default: 0,
    ComboBox: 1
};

class PopupRef
{
    constructor()
    {
        // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
        this.Window = null;

        // Set on OpenPopup
        this.PopupId = -1;   // ImGuiID
        this.ParentWindow = null;
        this.OpenFrameCount = -1;
        this.OpenParentId = -1; // we need this to differentiate multiple menu
                                // sets from each others (e.g. inside menu bar vs
                                // loose menu items)
        this.OpenPopupPos = null; // Vec2, preferred popup position (typically ==
                                  // OpenMousePos when using mouse)
        this.OpenMousePos = null; // copy of mouse position at the time of opening popup
    }
}

var ImguiPopupMixin =
{
    // The properties of popups windows are:
    // - They block normal mouse hovering detection outside them. (*)
    // - Unless modal, they can be closed by clicking anywhere outside them, or
    //   by pressing ESCAPE.
    // - Their visibility state (~bool) is held internally by imgui instead of
    //   being held by the programmer as we are used to with regular Begin() calls.
    // User can manipulate the visibility state by calling OpenPopup().
    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup)
    //  to bypass it and detect hovering even when normally blocked by a popup.
    // Those three properties are connected. The library needs to hold their
    //  visibility state because it can close popups at any time.

    // call to mark popup as open (don't call every frame!). popups are closed
    // when user click outside, or if CloseCurrentPopup() is called within a
    // BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are
    // calling CloseCurrentPopup(). Popup identifiers are relative to the current
    // ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
    OpenPopup(str_id)
    {
        this.openPopupEx(this.guictx.CurrentWindow.GetID(str_id));
    },

    // return true if the popup is open, and you can start outputting to it.
    // only call EndPopup() if BeginPopup() returns true!
    BeginPopup(str_id, flags=0)
    {
        let g = this.guictx;
        if (g.OpenPopupStack.length <= g.BeginPopupStack.length) // Early out for performance
        {
            // We behave like Begin() and need to consume those values
            g.NextWindowData.Clear();
            return false;
        }
        flags |= WindowFlags.AlwaysAutoResize | WindowFlags.NoTitleBar |
                 WindowFlags.NoSavedSettings;
        return this.beginPopupEx(g.CurrentWindow.GetID(str_id), flags);
    },

    // modal dialog (regular window with title bar, block interactions behind
    // the modal window, can't close the modal window by clicking outside)
    BeginPopupModal(name, p_open, flags=0)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        const id = win.GetID(name);
        if (!this.isPopupOpen(id))
        {
            // We behave like Begin() and need to consume those values
            g.NextWindowData.Clear();
            return false;
        }

        // Center modal windows by default
        // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags)
        // with the upcoming window.
        if (g.NextWindowData.PosCond == 0)
            this.SetNextWindowPos(Vec2.Mult(g.IO.DisplaySize, 0.5),
                                CondFlags.Appearing, new Vec2(0.5, 0.5));

        flags |= WindowFlags.Popup | WindowFlags.Modal |
                 WindowFlags.NoCollapse | WindowFlags.NoSavedSettings;
        const is_open = this.Begin(name, p_open, flags);
        // NB: is_open can be 'false' when the popup is completely clipped
        // (e.g. zero size display)
        if (!is_open || (p_open && !p_open.get()))
        {
            this.EndPopup();
            if (is_open)
                this.closePopupToLevel(g.BeginPopupStack.length, true);
            return false;
        }
        return is_open;
    },

    // only call EndPopup() if BeginPopupXXX() returns true!
    EndPopup()
    {
        let g = this.guictx;
        console.assert(g.CurrentWindow.Flags & WindowFlags.Popup,
                        "Mismatched BeginPopup()/EndPopup() calls, length:"+
                        g.BeginPopupStack.length);

        // Make all menus and popups wrap around for now, may need to expose
        // that policy.
        this.navMoveRequestTryWrapping(g.CurrentWindow, NavMoveFlags.LoopY);

        this.End();
    },

    // helper to open and begin popup when clicked on last item. if you can
    // pass a NULL str_id only if the previous item had an id. If you want to
    // use that on a non-interactive item such as Text() you need to pass in
    // an explicit ID here. read comments in .cpp!
    BeginPopupContextItem(str_id, mouse_button=1)
    {
        let win = this.guictx.CurrentWindow;
        // If user hasn't passed an ID, we can use the LastItemID.
        // Using LastItemID as a Popup ID won't conflict!
        let id = str_id ? win.GetID(str_id) : win.DC.LastItemId;
        console.assert(id != 0, "You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)");
        if (this.IsMouseReleased(mouse_button) &&
            this.IsItemHovered(HoveredFlags.AllowWhenBlockedByPopup))
        {
            this.openPopupEx(id);
        }
        return this.beginPopupEx(id, WindowFlags.AlwaysAutoResize|
                                    WindowFlags.NoTitleBar|
                                    WindowFlags.NoSavedSettings);
    },

    // helper to open and begin popup when clicked on current window.
    BeginPopupContextWindow(str_id, mouse_button=1, also_over_items=true)
    {
        if (!str_id) str_id = "window_context";
        let id = this.guictx.CurrentWindow.GetID(str_id);
        if (this.IsMouseReleased(mouse_button) &&
            this.IsWindowHovered(HoveredFlags.AllowWhenBlockedByPopup))
        if (also_over_items || !this.IsAnyItemHovered())
            this.openPopupEx(id);
        return this.beginPopupEx(id, WindowFlags.AlwaysAutoResize|
                                     WindowFlags.NoTitleBar|
                                     WindowFlags.NoSavedSettings);
    },

    // helper to open and begin popup when clicked in void (where there are no
    // imgui windows).
    BeginPopupContextVoid(str_id, mouse_button=1)
    {
        if (!str_id) str_id = "void_context";
        let id = this.guictx.CurrentWindow.GetID(str_id);
        if (this.IsMouseReleased(mouse_button) &&
            !this.IsWindowHovered(HoveredFlags.AnyWindow))
        {
            this.openPopupEx(id);
        }
        return this.beginPopupEx(id, WindowFlags.AlwaysAutoResize|
                                     WindowFlags.NoTitleBar|
                                     WindowFlags.NoSavedSettings);
    },

    // helper to open popup when clicked on last item (note: actually
    // triggers on the mouse _released_ event to be consistent with
    // popup behaviors). return true when just opened.
    OpenPopupOnItemClick(str_id, mouse_button=1)
    {
        let win = this.guictx.CurrentWindow;
        if (this.IsMouseReleased(mouse_button) &&
            this.IsItemHovered(HoveredFlags.AllowWhenBlockedByPopup))
        {
            // If user hasn't passed an ID, we can use the LastItemID. Using
            // LastItemID as a Popup ID won't conflict!
            let id = str_id ? win.GetID(str_id) : win.DC.LastItemId;
            console.assert(id != 0,
                "You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item");
            this.openPopupEx(id);
            return true;
        }
        return false;
    },

    // return true if the popup is open at the current begin-ed level of the
    // popup stack.
    IsPopupOpen(id)
    {
        if(typeof(id) == "string")
            return this.isPopupOpen(this.guictx.CurrentWindow.GetID(id));
        else
            return this.isPopupOpen(id);
    },

    // close the popup we have begin-ed into. clicking on a MenuItem or
    // Selectable automatically close the current popup.
    CloseCurrentPopup()
    {
        let g = this.guictx;
        let popup_idx = g.BeginPopupStack.length - 1;
        if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.length ||
            g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
        {
            return;
        }

        // Closing a menu closes its top-most parent popup (unless a modal)
        while (popup_idx > 0)
        {
            let popup_window = g.OpenPopupStack[popup_idx].Window;
            let parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;
            let close_parent = false;
            if (popup_window && (popup_window.Flags & WindowFlags.ChildMenu))
            {
                if (parent_popup_window == null ||
                    !(parent_popup_window.Flags & WindowFlags.Modal))
                {
                    close_parent = true;
                }
            }
            if (!close_parent)
                break;
            popup_idx--;
        }
        //IMGUI_DEBUG_LOG("CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.length - 1, popup_idx);
        this.closePopupToLevel(popup_idx, true);

        // A common pattern is to close a popup when selecting a menu
        // item/selectable that will open another window.  To improve this
        // usage pattern, we avoid nav highlight for a single frame in the
        // parent window. Similarly, we could avoid mouse hover highlight
        // in this window but it is less visually problematic.
        if (g.NavWindow)
            g.NavWindow.DC.NavHideHighlightOneFrame = true;
    },

    /* ----------------------------------------------------------------*/
    isPopupOpen(id)
    {
        let g = this.guictx;
        return g.OpenPopupStack.length > g.BeginPopupStack.length &&
               g.OpenPopupStack[g.BeginPopupStack.length].PopupId == id;
    },

    getFrontMostPopupModal()
    {
        let g = this.guictx;
        for (let n = g.OpenPopupStack.length-1; n >= 0; n--)
        {
            let popup = g.OpenPopupStack[n].Window;
            if (popup && popup.Flags & WindowFlags.Modal)
                    return popup;
        }
        return null;
    },

    // Mark popup as open (toggle toward open state).
    // Popups are closed when user click outside, or activate a pressable
    // item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup()
    // block. Popup identifiers are relative to the current ID-stack (so
    // OpenPopup and BeginPopup needs to be at the same level). One open
    // popup per level of the popup hierarchy (NB: when assigning we reset
    // the Window member of ImGuiPopupRef to NULL)
    openPopupEx(id)
    {
        let g = this.guictx;
        let parent_window = g.CurrentWindow;
        let current_stack_size = g.BeginPopupStack.length;
        let popup_ref = new PopupRef(); // Tagged as new ref as Window will be set
                                        // back to null if we write this into OpenPopupStack.
        popup_ref.PopupId = id;
        popup_ref.Window = null;
        popup_ref.ParentWindow = parent_window;
        popup_ref.OpenFrameCount = g.FrameCount;
        popup_ref.OpenParentId = parent_window.IDStack.back();
        popup_ref.OpenPopupPos = this.navCalcPreferredRefPos();
        popup_ref.OpenMousePos = this.IsMousePosValid(g.IO.MousePos) ?
                                    g.IO.MousePos : popup_ref.OpenPopupPos;

        //IMGUI_DEBUG_LOG("OpenPopupEx(0x%08X)\n", g.FrameCount, id);
        if (g.OpenPopupStack.length < current_stack_size + 1)
        {
            g.OpenPopupStack.push(popup_ref);
        }
        else
        {
            // Gently handle the user mistakenly calling OpenPopup() every frame.
            // It is a programming mistake! However, if we were to run the regular
            // code path, the ui would become completely unusable because the popup
            // will always be in hidden-while-calculating-size state _while_ claiming
            // focus. Which would be a very confusing situation for the programmer.
            // Instead, we silently allow the popup to proceed, it will keep
            // reappearing and the programming error will be more obvious to understand.
            if (g.OpenPopupStack[current_stack_size].PopupId == id &&
                g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)
            {
                g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
            }
            else
            {
                // Close child popups if any, then flag popup for open/reopen
                g.OpenPopupStack.resize(current_stack_size + 1);
                g.OpenPopupStack[current_stack_size] = popup_ref;
            }

            // When reopening a popup we first refocus its parent, otherwise
            // if its parent is itself a popup it would get closed by
            // ClosePopupsOverWindow(). This is equivalent to what
            // closePopupToLevel() does.
            //if (g.OpenPopupStack[current_stack_size].PopupId == id)
            //    FocusWindow(parent_window);
        }
    },

    closePopupsOverWindow(refwin)
    {
        let g = this.guictx;
        if (g.OpenPopupStack.length == 0)
            return;

        // When popups are stacked, clicking on a lower level popups puts
        // focus back to it and close popups above it. Don't close our own
        // child popup windows.
        let popup_count_to_keep = 0;
        if (refwin)
        {
            // Find the highest popup which is a descendant of the reference
            // window (generally reference window = NavWindow)
            for (; popup_count_to_keep < g.OpenPopupStack.length; popup_count_to_keep++)
            {
                let popup = g.OpenPopupStack[popup_count_to_keep];
                if (!popup.Window)
                    continue;
                console.assert((popup.Window.Flags & WindowFlags.Popup) != 0);
                if (popup.Window.Flags & WindowFlags.ChildWindow)
                    continue;

                // Trim the stack if popups are not direct descendant of the
                // reference window (which is often the NavWindow)
                let popup_or_descendent_has_focus = false;
                for (let m = popup_count_to_keep;
                     m < g.OpenPopupStack.length && !popup_or_descendent_has_focus;
                     m++)
                {
                    if (g.OpenPopupStack[m].Window &&
                        g.OpenPopupStack[m].Window.RootWindow == refwin.RootWindow)
                    {
                        popup_or_descendent_has_focus = true;
                    }
                }
                if (!popup_or_descendent_has_focus)
                    break;
            }
        }
        // This test is not required but it allows to set a convenient
        // breakpoint on the statement below
        if (popup_count_to_keep < g.OpenPopupStack.length)
        {
            //IMGUI_DEBUG_LOG("ClosePopupsOverWindow(%s) -> closePopupToLevel(%d)\n", ref_window->Name, popup_count_to_keep);
            this.closePopupToLevel(popup_count_to_keep, false);
        }
    },

    closePopupToLevel(remaining, applyFocusToWindowUnder)
    {
        console.assert(remaining >= 0);
        let g = this.guictx;
        let focus_window = (remaining > 0) ?
            g.OpenPopupStack[remaining-1].Window : g.OpenPopupStack[0].ParentWindow;
        g.OpenPopupStack.length = remaining; // resize(remaining);

        // FIXME: This code is faulty and we may want to eventually to replace
        // or remove the 'apply_focus_to_window_under=true' path completely.
        // Instead of using g.OpenPopupStack[remaining-1].Window etc. we should
        // find the highest root window that is behind the popups we are closing.
        // The current code will set focus to the parent of the popup window
        // which is incorrect. It rarely manifested until now because
        // UpdateMouseMovingWindowNewFrame() would call FocusWindow() again on
        // the clicked window, leading to a chain of focusing A (clicked window)
        // then B (parent window of the popup) then A again. However if the
        // clicked window has the _NoMove flag set we would be left with B focused.
        // For now, we have disabled this path when called from ClosePopupsOverWindow()
        // because the users of ClosePopupsOverWindow() don't need to alter focus
        // anyway, but we should inspect and fix this properly.
        if (applyFocusToWindowUnder)
        {
            if (g.NavLayer == 0)
                focus_window = this.navRestoreLastChildNavWindow(focus_window);
            this.FocusWindow(focus_window);
        }
    },

    beginPopupEx(id, flags)
    {
        console.assert(typeof(id) != "string");
        let g = this.guictx;
        if (!this.isPopupOpen(id))
        {
            // We behave like Begin() and need to consume those values
            g.NextWindowData.Clear();
            return false;
        }

        let name;
        if (flags & WindowFlags.ChildMenu)
            name = `##Menu_${g.BeginPopupStack.length}`;
        else
            name = `##Popup_${id}`; // Not recycling, so we can close/open during the same frame

        let is_open = this.Begin(name, null, flags | WindowFlags.Popup);
        // NB: Begin can return false when the popup is completely clipped
        // (e.g. zero size display)
        if (!is_open)
            this.EndPopup();
        return is_open;
    },

    findBestWindowPosForPopup(win)
    {
        let g = this.guictx;
        let r_outer = this.getWindowAllowedExtentRect(win);
        if (win.Flags & WindowFlags.ChildMenu)
        {
            // Child menus typically request _any_ position within the parent
            // menu item, and then we move the new menu outside the parent bounds.
            // This is how we end up with child menus appearing (most-commonly)
            // on the right of the parent menu.
            console.assert(g.CurrentWindow == win);
            let parent_window = g.CurrentWindowStack[g.CurrentWindowStack.length - 2];
            // We want some overlap to convey the relative depth of each menu
            //(currently the amount of overlap is hard-coded to style.ItemSpacing.x).
            let horizontal_overlap = g.Style.ItemInnerSpacing.x;
            let r_avoid;
            if (parent_window.DC.MenuBarAppending)
            {
                r_avoid = new Rect(-Number.MAX_VALUE,
                            parent_window.Pos.y + parent_window.TitleBarHeight(),
                            Number.MAX_VALUE,
                            parent_window.Pos.y + parent_window.TitleBarHeight()
                            + parent_window.MenuBarHeight());
            }
            else
            {
                r_avoid = new Rect(parent_window.Pos.x + horizontal_overlap,
                                -Number.MAX_VALUE,
                                parent_window.Pos.x + parent_window.Size.x
                                - horizontal_overlap - parent_window.ScrollbarSizes.x,
                                Number.MAX_VALUE);
            }
            let lastAutoPos = new ValRef(win.AutoPosLastDirection);
            let pos = this.findBestWindowPosForPopupEx(win.Pos, win.Size,
                            lastAutoPos, r_outer, r_avoid);
            win.AutoPosLastDirection = lastAutoPos.get();
            return pos;
        }
        if (win.Flags & WindowFlags.Popup)
        {
            let r_avoid = new Rect(win.Pos.x - 1, win.Pos.y - 1,
                                    win.Pos.x + 1, win.Pos.y + 1);
            let lastAutoPos = new ValRef(win.AutoPosLastDirection);
            let pos = this.findBestWindowPosForPopupEx(win.Pos, win.Size,
                            lastAutoPos, r_outer, r_avoid);
            win.AutoPosLastDirection = lastAutoPos.get();
            return pos;
        }
        if (win.Flags & WindowFlags.Tooltip)
        {
            // Position tooltip (always follows mouse)
            let sc = g.Style.MouseCursorScale;
            let ref_pos = this.navCalcPreferredRefPos();
            let r_avoid;
            if (!g.NavDisableHighlight && g.NavDisableMouseHover &&
                !(g.IO.ConfigFlags & ConfigFlags.NavEnableSetMousePos))
                r_avoid = new Rect(ref_pos.x-16, ref_pos.y-8, ref_pos.x+16, ref_pos.y+8);
            else
            {
                // FIXME: Hard-coded based on mouse cursor shape expectation.
                // Exact dimension not very important.
                r_avoid = new Rect(ref_pos.x-16, ref_pos.y-8, ref_pos.x+24*sc, ref_pos.y+24*sc);
            }
            let lastAutoPos = new ValRef(win.AutoPosLastDirection);
            let pos = this.findBestWindowPosForPopupEx(ref_pos, win.Size,
                                lastAutoPos, r_outer, r_avoid);
            win.AutoPosLastDirection = lastAutoPos.get();
            if (win.AutoPosLastDirection == Dir.None)
            {
                // If there's not enough room, for tooltip we prefer avoiding
                // the cursor at all cost even if it means that part of the
                // tooltip won't be visible.
                pos = Vec2.AddXY(ref_pos, 2, 2);
            }
            return pos;
        }
        console.assert(0, "shouldn't reach here");
        return win.Pos;
    },

    // returns Vec2 and modifies last_dir (of type ValRef)
    //
    // r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle
    // around the mouse cursor which we want to avoid. for popups it's a small
    // point around the cursor.)
    //
    // r_outer = the visible area rectangle, minus safe area padding. If our
    // popup size won't fit because of safe area padding we ignore it.
    findBestWindowPosForPopupEx(ref_pos, size, last_dir, r_outer, r_avoid,
                                policy=PopupPositionPolicy.Default)
    {
        if(last_dir.value == undefined)
            console.assert(last_dir.value, "last_dir must be a ValRef");
        let base_pos_clamped = Vec2.Clamp(ref_pos, r_outer.Min,
                                        Vec2.Subtract(r_outer.Max, size));
        //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
        //GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

        // Combo Box policy (we want a connecting edge)
        if (policy == PopupPositionPolicy.ComboBox)
        {
            const dirOrder = [ Dir.Down, Dir.Right, Dir.Left, Dir.Up];
            for (let n = (last_dir.get() != Dir.None) ? -1 : 0; n < dirOrder.length; n++)
            {
                const dir = (n == -1) ? last_dir.get() : dirOrder[n];
                if (n != -1 && dir == last_dir.get()) // Already tried this direction?
                    continue;
                let pos;
                switch(dir)
                {
                case Dir.Down:
                    // Below, Toward Right (default)
                    pos = new Vec2(r_avoid.Min.x, r_avoid.Max.y);
                    break;
                case Dir.Right:
                    // Above, Toward Right
                    pos = new Vec2(r_avoid.Min.x, r_avoid.Min.y - size.y);
                    break;
                case Dir.Left:
                    // Below, Toward Left
                    pos = new Vec2(r_avoid.Max.x - size.x, r_avoid.Max.y);
                    break;
                case Dir.Up:
                    // Above, Toward Left
                    pos = new Vec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y);
                    break;
                }
                if (!r_outer.Contains(new Rect(pos, Vec2.Add(pos, size))))
                    continue;
                last_dir.set(dir);
                return pos; /// <--------------------------------- return
            }
        }

        // Default popup policy
        const dirOrder = [ Dir.Right, Dir.Down, Dir.Up, Dir.Left ];
        for (let n = (last_dir.get() != Dir.None) ? -1 : 0; n < dirOrder.length; n++)
        {
            const dir = (n == -1) ? last_dir.get() : dirOrder[n];
            if (n != -1 && dir == last_dir.get())
                continue; // Already tried this direction..
            let avail_w = (dir == Dir.Left ?
                r_avoid.Min.x : r_outer.Max.x) -
                    (dir == Dir.Right ? r_avoid.Max.x : r_outer.Min.x);
            let avail_h = (dir == Dir.Up ?
                r_avoid.Min.y : r_outer.Max.y) -
                    (dir == Dir.Down ? r_avoid.Max.y : r_outer.Min.y);
            if (avail_w < size.x || avail_h < size.y)
                continue;

            let pos = new Vec2();
            pos.x = (dir == Dir.Left) ? r_avoid.Min.x - size.x :
                    (dir == Dir.Right) ? r_avoid.Max.x : base_pos_clamped.x;
            pos.y = (dir == Dir.Up)? r_avoid.Min.y - size.y :
                    (dir == Dir.Down) ? r_avoid.Max.y : base_pos_clamped.y;
            // console.log(pos.x, pos.y, r_avoid.Max.y);
            last_dir.set(dir);
            return pos; /// <--------------------------------------- return
        }

        // Fallback, try to keep within display
        last_dir.set(Dir.None);
        let pos = ref_pos.Clone();
        pos.x = Math.max(Math.min(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
        pos.y = Math.max(Math.min(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
        return pos;
    },
}; // end mixin
// =====================================================================================================================
// widgets/popup.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/combo.js BEGIN
// =====================================================================================================================


// Widgets: Combo Box
// - The new BeginCombo()/EndCombo() api allows you to manage your contents
//   and selection state however you want it, by creating e.g. Selectable() items.
// - The old Combo() api are helpers over BeginCombo()/EndCombo() which are
//   kept available for convenience purpose.
var ComboFlags =
{
    None: 0,
    PopupAlignLeft: 1 << 0,
        // Align the popup toward the left by default    -
    HeightSmall: 1 << 1,
        // Max ~4 items visible. Tip: If you want your combo popup to be a
        // specific size you can use SetNextWindowSizeConstraints() prior to
        // calling BeginCombo()
    HeightRegular: 1 << 2,
        // Max ~8 items visible (default)
    HeightLarge: 1 << 3,
        // Max ~20 items visible
    HeightLargest: 1 << 4,
        // As many fitting items as possible
    NoArrowButton: 1 << 5,
        // Display on the preview box without the square arrow button
    NoPreview: 1 << 6,
        // Display only a square arrow button
};

ComboFlags.HeightMask_ = ComboFlags.HeightSmall | ComboFlags.HeightRegular |
                         ComboFlags.HeightLarge | ComboFlags.HeightLargest;

var ImguiComboMixin =
{
    BeginCombo(label, preview_value, flags=0)
    {
        // Always consume the SetNextWindowSizeConstraint() call in our early return paths
        let g = this.guictx;
        let backup_next_window_size_constraint = g.NextWindowData.SizeConstraintCond;
        g.NextWindowData.SizeConstraintCond = 0;

        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        // Can't use both flags together
        console.assert((flags & (ComboFlags.NoArrowButton | ComboFlags.NoPreview)) !=
                                 (ComboFlags.NoArrowButton | ComboFlags.NoPreview));

        let style = g.Style;
        const id = win.GetID(label);
        const arrow_size = (flags & ComboFlags.NoArrowButton) ? 0 : this.GetFrameHeight();
        const label_size = this.CalcTextSize(label, true);
        const expected_w = this.getNextItemWidth();
        const w = (flags & ComboFlags.NoPreview) ? arrow_size : expected_w;
        const frame_bb = new Rect(win.DC.CursorPos,
                                Vec2.AddXY(win.DC.CursorPos,
                                    w, label_size.y + style.FramePadding.y*2));
        const total_bb = new Rect(frame_bb.Min,
                                Vec2.AddXY(frame_bb.Max,
                                    label_size.x > 0 ? style.ItemInnerSpacing.x + label_size.x : 0,
                                    0));
        this.itemSize(total_bb, style.FramePadding.y);
        if (!this.itemAdd(total_bb, id, frame_bb))
            return false;

        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(frame_bb, id, hovered, held);
        let popup_open = this.IsPopupOpen(id);
        const frame_col = style.GetColor(hovered.get() ? "FrameBgHovered" : "FrameBg");
        const value_x2 = Math.max(frame_bb.Min.x, frame_bb.Max.x - arrow_size);
        this.renderNavHighlight(frame_bb, id);
        if (!(flags & ComboFlags.NoPreview))
            win.DrawList.AddRectFilled(frame_bb.Min, new Vec2(value_x2, frame_bb.Max.y),
                        frame_col, style.FrameRounding, CornerFlags.Left);
        if (!(flags & ComboFlags.NoArrowButton))
        {
            win.DrawList.AddRectFilled(new Vec2(value_x2, frame_bb.Min.y), frame_bb.Max,
                style.GetColor((popup_open || hovered.get()) ?
                                "ButtonHovered" : "Button"),
                style.FrameRounding,
                (w <= arrow_size) ? CornerFlags.All : CornerFlags.Right);
            this.renderArrow(new Vec2(value_x2 + style.FramePadding.y,
                                    frame_bb.Min.y + style.FramePadding.y),
                            Dir.Down);
        }
        this.renderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);
        if (preview_value != null && !(flags & ComboFlags.NoPreview))
        {
            this.renderTextClipped(Vec2.Add(frame_bb.Min, style.FramePadding),
                                   new Vec2(value_x2, frame_bb.Max.y),
                                   preview_value, null, Vec2.Zero());
        }
        if (label_size.x > 0)
        {
            this.renderText(new Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                                    frame_bb.Min.y + style.FramePadding.y),
                            label);
        }

        if ((pressed || g.NavActivateId == id) && !popup_open)
        {
            if (win.DC.NavLayerCurrent == 0)
                win.NavLastIds[0] = id;
            this.openPopupEx(id);
            popup_open = true;
        }

        if (!popup_open)
        {
            return false;
        }

        if (backup_next_window_size_constraint)
        {
            g.NextWindowData.SizeConstraintCond = backup_next_window_size_constraint;
            g.NextWindowData.SizeConstraintRect.Min.x = Math.max(g.NextWindowData.SizeConstraintRect.Min.x, w);
        }
        else
        {
            if ((flags & ComboFlags.HeightMask_) == 0)
                flags |= ComboFlags.HeightRegular;
            console.assert(IsPowerOfTwo(flags & ComboFlags.HeightMask_)); // Only one
            let popup_max_height_in_items = -1;
            if (flags & ComboFlags.HeightRegular)
                popup_max_height_in_items = 8;
            else
            if (flags & ComboFlags.HeightSmall)
                popup_max_height_in_items = 4;
            else
            if (flags & ComboFlags.HeightLarge)
                popup_max_height_in_items = 20;
            let h = this.calcMaxPopupHeightFromItemCount(popup_max_height_in_items);
            this.SetNextWindowSizeConstraints(new Vec2(w, 0),
                                              new Vec2(Number.MAX_VALUE, h));
        }
        let name = "##Combo_" + g.BeginPopupStack.length; // Recycle windows based on depth

        // Peak into expected window size so we can position it
        let popup_win = this.findWindowByName(name);
        if (popup_win)
        {
            if (popup_win.WasActive)
            {
                let size_expected = this.calcWindowExpectedSize(popup_win);
                if (flags & ComboFlags.PopupAlignLeft)
                    popup_win.AutoPosLastDirection = Dir.Left;
                let r_outer = this.getWindowAllowedExtentRect(popup_win);
                let lastAutoPos = new ValRef(popup_win.AutoPosLastDirection);
                let pos = this.findBestWindowPosForPopupEx(frame_bb.GetBL(),
                                    size_expected, lastAutoPos,
                                    r_outer, frame_bb,
                                    PopupPositionPolicy.ComboBox);
                popup_win.AutoPosLastDirection = lastAutoPos.get();
                this.SetNextWindowPos(pos);
            }
        }

        // Horizontally align ourselves with the framed text
        let window_flags = WindowFlags.AlwaysAutoResize | WindowFlags.Popup |
                           WindowFlags.NoTitleBar | WindowFlags.NoResize |
                           WindowFlags.NoSavedSettings;
        this.PushStyleVar("WindowPadding", new Vec2(style.FramePadding.x, style.WindowPadding.y));
        let ret = this.Begin(name, null, window_flags);
        this.PopStyleVar();
        if (!ret)
        {
            this.EndPopup();
            console.assert(0);
            // This should never happen as we tested for IsPopupOpen() above
            return false;
        }
        return true;
    },

    // only call EndCombo() if BeginCombo() returns true!
    EndCombo()
    {
        this.EndPopup();
    },

    Combo(label, current_item, items, maxItems=-1, onChange)
    {
        let g = this.guictx;
        if(typeof(maxItems) == "function" && onChange==undefined)
        {
            onChange = maxItems;
            maxItems = -1;
        }
        console.assert(typeof(maxItems)=="number");
        let getter = function(i) {
            return items[i];
        };
        return this.ComboCB(label, current_item, getter, items.length,
                            maxItems, onChange);
    },

    // Old API, prefer using BeginCombo() nowadays if you can.
    ComboCB(label, current_item, getter, numItems, maxItems=-1, onChange)
    {
        let g = this.guictx;
        let item = current_item < 0 ? null : getter(current_item);
        console.assert(typeof(maxItems)=="number");

        // This old Combo() API exposed "popup_max_height_in_items". The new
        // more general BeginCombo() API doesn't have/need it, but we emulate it here.
        if (maxItems != -1 && !g.NextWindowData.SizeConstraintCond)
        {
            let h = this.calcMaxPopupHeightFromItemCount(maxItems);
            this.SetNextWindowSizeConstraints(new Vec2(0,0),
                                              new Vec2(Number.MAX_VALUE, h));
        }
        let value_changed = false;
        if(!this.BeginCombo(label, item!=undefined?item.toString():""))
            return value_changed;
        for (let i = 0; i < numItems; i++)
        {
            let iitem = getter(i);
            this.PushID(i);
            const item_selected = (i == current_item);
            let item_text;
            if (iitem == null || iitem == undefined)
                item_text = "*Unknown item*";
            else
                item_text = iitem.toString();
            if (this.Selectable(item_text, item_selected))
            {
                value_changed = true;
                current_item = i;
            }
            if (item_selected)
                this.SetItemDefaultFocus();
            this.PopID();
        }
        this.EndCombo();
        if(value_changed && onChange)
            onChange(current_item);
        return value_changed;
    },

    calcMaxPopupHeightFromItemCount(items_count)
    {
        let g = this.guictx;
        if (items_count <= 0)
            return Number.MAX_VALUE;
        return (g.FontLineHeight + g.Style.ItemSpacing.y) * items_count -
            g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
    }
};
// =====================================================================================================================
// widgets/combo.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/inputtext.js BEGIN
// =====================================================================================================================

/* global App */

var InputTextFlags =
{
    None: 0,
    CharsDecimal: 1 << 0,   // Allow 0123456789.+-*/
    CharsHexadecimal: 1 << 1,   // Allow 0123456789ABCDEFabcdef
    CharsUppercase: 1 << 2,   // Turn a..z into A..Z
    CharsNoBlank: 1 << 3,   // Filter out spaces, tabs
    AutoSelectAll: 1 << 4,   // Select entire text when first taking mouse focus
    EnterReturnsTrue: 1 << 5,
        // Return 'true' when Enter is pressed (as opposed to every time the
        // value was modified). Consider looking at the
        // IsItemDeactivatedAfterEdit() function.
    CallbackCompletion: 1 << 6,   // Callback on pressing TAB (for completion handling)
    CallbackHistory: 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)
    CallbackAlways: 1 << 8,
        // Callback on each iteration. User code may query cursor position,
        // modify text buffer.
    CallbackCharFilter: 1 << 9,
        // Callback on character inputs to replace or discard them.
        // Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
    AllowTabInput: 1 << 10,  // Pressing TAB input a '\t' character into the text field
    CtrlEnterForNewLine: 1 << 11,
        // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter
        // (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
    NoHorizontalScroll: 1 << 12,  // Disable following the cursor horizontally
    AlwaysInsertMode: 1 << 13,  // Insert mode
    ReadOnly: 1 << 14,  // Read-only mode
    Password: 1 << 15,  // Password mode, display all characters as '*'
    NoUndoRedo: 1 << 16,
        // Disable undo/redo. Note that input text owns the text data while
        // active, if you want to provide your own undo/redo stack you need
        // e.g. to call clearActiveID().
    CharsScientific: 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
    CallbackResize: 1 << 18,
        // Callback on buffer capacity changes request (beyond 'buf_size'
        // parameter value), allowing the string to grow. Notify when the string
        // wants to be resized (for string types which hold a cache of their
        // Size). You will be provided a new BufSize in the callback and NEED
        // to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
    // [Internal] -----------------
    Multiline: 1 << 20   // For internal use by InputTextMultiline()
};

const ValidChars =
{
    Decimal: "0123456789.-+*/",
    Scientific: "0123456789.-+*/eE",
    Hex: "0123456789AaBbCcDdEeFf",
};

const MaxDisplayLength = 2 * 1024 * 1024; // 2M chars (seems like a lot!)o
let DOMTextEditing = null;  // in order to trigger mobile input, we expose 
                            // input text fields to the DOM.

// Internal state of the currently focused/edited text input box
// This is stored on guictx and valid for <= 1 active/focused text
// fields.
//
// javascript strings:
//      are internally utf-16
//      values are immutable
//
class InputTextState // NB: contains TextEditState
{
    constructor(imgui)
    {
        this.imgui = imgui;
        this.ID = 0; // widget id owning the text state
        this.Text = null;
        this.TextIsValid = false;
        this.CurrentLen = 0;
        this.InitialText = null;
        this.ScrollX = 0.; // horizontal scrolling/offset
        this.EditState = new TextEditState(imgui);
        this.CursorAnim = 0.; // timer for cursor blink, reset on every user action so the cursor reappears immediately
        this.CursorFollow = false; // set when we want scrolling to follow the current cursor position (not always!)
        this.SelectedAllMouseLock = false;  // after a double-click to select all, we ignore further mouse drags to update selection

        // Temporarily set when active
        this.UserFlags = 0;
        this.UserCallback = null;
        this.UserCallbackData = null;

        if(DOMTextEditing == null)
            DOMTextEditing = App.IsMobileDevice(); // for debugging: || true;
    }

    Init(text)
    {
        if(text.IsMutable)
        {
            this.Text = text.Clone();
            this.InitialText = text.toString();
        }
        else
        {
            this.Text = new MutableString(text);
            this.InitialText = text;
        }
    }

    InitTextEdit(singleLine, fontScale) //
    {
        this.EditState.Init(singleLine, fontScale);
    }

    Update(imgui, id, frame, vis, multiline)
    {
        if(DOMTextEditing)
        {
            // InputTextState instances are shared accross multiple
            // inputtext fields. Update messages are delivered
            // to create as well as to hide our inputtext entry.
            // We have only a two DOM entriews, but only act on
            // the hide request if the hiding id is currently visible.
            if(!this.domElements) this.domElements = {};
            let eltype;
            if(multiline)
                eltype = "_multi";
            else
                eltype = "_single";
            let idstr = `imgui_inputtext${eltype}`;
            let domEl = this.domElements[eltype];
            if(vis)
            {
                let io = imgui.GetIO();
                if(!domEl)
                {
                    let style = imgui.GetStyle();
                    let bgcolor = style.GetColor("FrameBg").AsHashStr(true);
                    let txtcolor = style.GetColor("Text").AsStr();
                    let bordercolor = style.GetColor("Border").AsStr();
                    let rad = style.FrameRounding;
                    // make element child of canvas so absolute positioning is
                    // relative to its location.
                    if(multiline)
                        domEl = document.createElement("textarea");
                    else
                    {
                        domEl = document.createElement("input");
                        domEl.setAttribute("type", "text");
                    }
                    this.domElements[eltype] = domEl;
                    domEl.style.position = "absolute";
                    domEl.style.display = "inline";
                    domEl.style.backgroundColor = bgcolor;
                    domEl.style.color = txtcolor;
                    domEl.style.borderRadius = `${rad}px ${rad}px`;
                    domEl.style.borderWidth = ".5px";
                    domEl.style.borderColor = bordercolor;
                    // keypress doesn't work on android browser
                    // keyup only returns a keycode of 229 (buffer busy) 
                    // unless enter is pressed (13) because auto-correct, etc
                    domEl.onkeyup = (evt) => 
                    {
                        if(evt.keyCode == 13 && !multiline) // Enter
                        {
                            // Transfer text from domElement to our internal state.
                            // dismiss overlay.
                            // console.debug("yippee:" + domEl.value);
                            this.Text.Set(domEl.value);
                            domEl.blur();
                            domEl.style.display = "none";
                            imgui.FocusWindow(null);
                        }
                        else
                        {
                            // console.debug("hm:" + evt.keyCode);
                            if(multiline)
                                this.Text.Set(domEl.value);
                        }
                    };
                    document.body.appendChild(domEl);
                }
                domEl.setAttribute("id", idstr);
                let el = io.canvas;
                let top = el.offsetTop;
                let left = el.offsetLeft;
                while(el.offsetParent) 
                {
                    el = el.offsetParent;
                    top += el.offsetTop;
                    left += el.offsetLeft;
                }
                domEl.style.left = left + frame.Min.x + "px";
                domEl.style.top = top + frame.Min.y + "px";
                domEl.style.width = (frame.Max.x - frame.Min.x) + "px";
                domEl.style.height = (frame.Max.y - frame.Min.y) + "px";
                domEl.style.display = "inline";
                /*
                let s = domEl.style;
                console.debug("inputtext style\n" + 
                                `  left: ${s.left}\n` +
                                `  top: ${s.top}\n` +
                                `  width: ${s.width}\n` +
                                `  heigth: ${s.height}\n`);
                */
                domEl.value = this.Text.Get();
                domEl.focus();
            }
            else
            if(domEl && domEl.id == idstr)
                domEl.style.display = "none";
        }
    }

    CursorAnimReset()
    {
        // After a user-input the cursor stays on for a while without blinking
        this.CursorAnim = -0.3;
    }

    CursorClamp()
    {
        this.EditState.ClampCursor(this.Text);
    }

    Cut()
    {
        this.EditState.Cut(this.Text);
    }

    Paste(pasteTxt)
    {
        this.EditState.Paste(this.Text, pasteTxt);
    }

    HasSelection()
    {
        return this.EditState.HasSelection();
    }

    GetSelectedText()
    {
        return this.EditState.GetSelectedText(this.Text);
    }

    ClearSelection()
    {
        return this.EditState.ClearSelection();
    }

    SelectAll()
    {
        this.EditState.SelectAll(this.Text);
    }

    GetUndoAvailCount()
    {
        return this.EditState.GetUndoAvailCount();
    }

    GetRedoAvailCount()
    {
        return this.EditState.GetRedoAvailCount();
    }

    Click(x, y)
    {
        this.EditState.Click(this.Text, x, y);
    }

    Drag(x, y)
    {
        return this.EditState.Drag(this.Text, x, y);
    }

    OnKeyPressed(key)
    {
        this.EditState.Key(this.Text, key);
        this.CursorFollow = true;
        this.CursorAnimReset();
    }
}

// Shared state of InputText(), passed as an argument to your callback when a
// InputTextFlags.Callback* flag is used. The callback function should return
//  0 by default.
// Callbacks (follow a flag name and see comments in InputTextFlags declarations
//  for more details)
// - InputTextFlags.CallbackCompletion:  Callback on pressing TAB
// - InputTextFlags.CallbackHistory:     Callback on pressing Up/Down arrows
// - InputTextFlags.CallbackAlways:      Callback on each iteration
// - InputTextFlags.CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - InputTextFlags.CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
class InputTextCallbackData
{
    constructor()
    {
        this.EventFlag = 0;
        this.Flags = 0; //  values passed into InputText
        this.UserData = null;

        // Arguments for the different callback events
        // - To modify the text buffer in a callback, prefer using the
        //   InsertChars() / DeleteChars() function. InsertChars() will take
        //   care of calling the resize callback if necessary.
        // - If you know your edits are not going to resize the underlying
        //   buffer allocation, you may modify the contents of 'Buf[]' directly.
        //   You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize)
        //   and set 'BufDirty'' to true so InputText can update its internal state.
        this.EventChar = 0; // Character input Read-write [CharFilter]
                            // Replace character with another one, or set to
                            // zero to drop. return 1 is equivalent to setting
                            // EventChar=0;
        this.EventKey = 0;   // Key pressed (Up/Down/TAB) Read-only [Completion,History]
        this.Text = null;    // Mutable Text instance (to internal state)
        this.TextDirty = false; // callback should signal dirty if Text changed
        this.CursorPos = 0;     // Read-write   // [Completion,History,Always]
        this.SelectionStart = 0; // Read-write
                                // [Completion,History,Always] == to SelectionEnd
                                // when no selection)
        this.SelectionEnd = 0;  // Read-write [Completion,History,Always]
    }

    // Helper method for text manipulation.
    // Use those function to benefit from the CallbackResize behaviors. Calling
    // those function reset the selection.
    ImGuiInputTextCallbackData()
    {
    }

    DeleteChars(pos, num)
    {

    }

    InsertChars(pos, text)
    {

    }

    HasSelection()
    {
        return this.SelectionStart != this.SelectionEnd;
    }
}

const InputtextIFmt = "%d";
const InputtextFFmt = "%.3f";
const InputtextDFmt = "%.6f";
const InputtextHFmt = "%.8x"; // XXX;b

var ImguiInputMixin =
{
    InputText(label, mstr, flags=0, onEdit=null, editData=null, onChange=null)
    {
        console.assert(!(flags & InputTextFlags.Multiline)); // call InputTextMultiline()
        return this.inputTextEx(label, null, mstr, new Vec2(0,0), flags,
                        onEdit, editData, onChange);
    },

    InputTextMultiline(label, mstr, size, flags=0, onEdit=null, editData=null)
    {
        return this.inputTextEx(label, null, mstr, size,
                         flags|InputTextFlags.Multiline, onEdit, editData);
    },

    InputTextWithHint(label, hint, mstr, flags, onEdit, editData)
    {
        console.assert(!(flags & InputTextFlags.Multiline)); // call InputTextMultiline()
        return this.inputTextEx(label, hint, mstr, new Vec2(0,0), flags, onEdit, editData);
    },

    InputFloat(label, v, step=0, step_fast=0, format=null,
                flags=0, onChange)
    {
        if(format==null) format = InputtextFFmt;
        flags |= InputTextFlags.CharsScientific;
        return this.InputScalar(label, DataType.Float, v, step > 0 ? step : null,
                step_fast >0 ? step_fast : null, format, flags, onChange);
    },

    InputDouble(label, v, step=0, step_fast=0, format=null,
                flags=0, onChange)
    {
        if(format==null) format = InputtextDFmt;
        return this.InputFloat(label, v, step, step_fast, format, flags, onChange);
    },

    InputFloat2(label, v, format=null, flags=0, onChange)
    {
        if(format==null) format = InputtextFFmt;
        return this.InputScalarN(label, DataType.Float, v, 2, null, null,
                                format, flags, onChange);
    },

    InputFloat3(label, v, format=null, flags=0, onChange)
    {
        if(format==null) format = InputtextFFmt;
        return this.InputScalarN(label, DataType.Float, v, 3, null, null,
                                format, flags, onChange);
    },

    InputFloat4(label, v, format=null, flags=0, onChange)
    {
        if(format==null) format = InputtextFFmt;
        return this.InputScalarN(label, DataType.Float, v, 4, null, null,
                                format, flags, onChange);
    },

    InputInt(label, v, step=1, step_fast=100, flags=0, onChange)
    {
        // Hexadecimal input provided as a convenience but the flag name is
        // awkward. Typically you'd use InputText() to parse your own data, if
        // you want to handle prefixes.
        const format = (flags & InputTextFlags.CharsHexadecimal) ? InputtextHFmt : InputtextIFmt;
        return this.InputScalar(label, DataType.S32, v, step>0 ? step : null,
                    step_fast >0 ? step_fast : null, format, flags, onChange);
    },

    InputInt2(label, v, flags=0, onChange)
    {
        return this.InputScalarN(label, DataType.S32, v, 2, null, null,
                                InputtextIFmt, flags, onChange);
    },

    InputInt3(label, v, flags=0, onChange)
    {
        return this.InputScalarN(label, DataType.S32, v, 3, null, null,
                                InputtextIFmt, flags, onChange);
    },

    InputInt4(label, v, flags=0, onChange)
    {
        return this.InputScalarN(label, DataType.S32, v, 4, null, null,
                                InputtextIFmt, flags, onChange);
    },

    InputScalarN(label, data_type, v, nch, step, step_fast, fmt,
                flags, onChange)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let  g = this.guictx;
        let value_changed = false;
        this.BeginGroup();
        this.PushID(label);
        this.pushMultiItemsWidths(nch, this.getNextItemWidth());
        for (let i=0; i < nch; i++)
        {
            this.PushID(i);
            value_changed |= this.InputScalar("", data_type, v[i], step, step_fast,
                                            fmt, flags, function(newval) {
                                                v[i] = newval;
                                            });
            this.SameLine(0, g.Style.ItemInnerSpacing.x);
            this.PopID();
            this.PopItemWidth();
        }
        this.PopID();
        this.textEx(label.split("##")[0]);
        this.EndGroup();
        if(value_changed && onChange)
            onChange(v);
        return value_changed;
    },

    InputScalar(label, data_type, v, step, step_fast, format=null,
                flags=0, onChange=null)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        let style = g.Style;
        if (format == null)
            format = (data_type == DataType.Float) ? InputtextFFmt : InputtextIFmt;
        let buf = FormatValues(format, [v]); // import from dataype.js
        let value_changed = false;
        if ((flags & (InputTextFlags.CharsHexadecimal |
                      InputTextFlags.CharsScientific)) == 0)
            flags |= InputTextFlags.CharsDecimal;
        flags |= InputTextFlags.AutoSelectAll;
        let origStr = g.InputTextState.InitialText;
        if (step != null && step != 0)
        {
            const button_size = this.GetFrameHeight();

            // The only purpose of the group here is to allow the caller to
            // query item data e.g. IsItemActive()
            this.BeginGroup();
            this.PushID(label);
            this.SetNextItemWidth(Math.max(1,
                    this.getNextItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));
            this.InputText("", buf, flags, null, null, function(newval)
            {
                value_changed = DataTypeApplyOpFromText(newval, origStr, data_type, format,
                                            (newval) => { buf = newval; });
            });
            // PushId(label) + "" gives us the expected ID from outside point of view

            // Step buttons
            const backup_frame_padding = style.FramePadding.Clone();
            style.FramePadding.x = style.FramePadding.y;
            let button_flags = ButtonFlags.Repeat | ButtonFlags.DontClosePopups;
            if (flags & InputTextFlags.ReadOnly)
                button_flags |= ButtonFlags.Disabled;
            this.SameLine(0, style.ItemInnerSpacing.x);
            if (this.ButtonEx("-", new Vec2(button_size, button_size), button_flags))
            {
                buf = DataTypeApplyOp(data_type, "-", buf,
                                    g.IO.KeyCtrl && step_fast ? step_fast : step);
                value_changed = true;
            }
            this.SameLine(0, style.ItemInnerSpacing.x);
            if (this.ButtonEx("+", new Vec2(button_size, button_size), button_flags))
            {
                buf = DataTypeApplyOp(data_type, "+", buf,
                                    g.IO.KeyCtrl && step_fast ? step_fast : step);
                value_changed = true;
            }
            this.SameLine(0, style.ItemInnerSpacing.x);
            this.textEx(label.split("##")[0]);
            style.FramePadding = backup_frame_padding;
            this.PopID();
            this.EndGroup();
        }
        else
        {
            this.InputText(label, buf, flags, null, null, function(newval)
                {
                    value_changed = DataTypeApplyOpFromText(
                                        newval, origStr, data_type, format,
                                        (newval) => buf = newval);
                });
        }

        if(value_changed && onChange)
            onChange(buf);

        return value_changed;
    },

    // Create text input in place of an active drag/slider (used when doing
    // a CTRL+Click on drag/slider widgets)
    inputScalarAsWidgetReplacement(bb, id, label, datatype, val, format)
    {
        // IM_UNUSED(id);
        let g = this.guictx;

        // On the first frame, g.ScalarAsInputTextId == 0, then on subsequent
        // frames it becomes == id. We clear ActiveID on the first frame to
        // allow the InputText() taking it back.
        if (g.ScalarAsInputTextId == 0)
            this.clearActiveID();

        console.assert(0, "implement me");
        /*  WIP
        let fmt_buf[32];
        char data_buf[32];
        let format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));
        DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, data_ptr, format);
        ImStrTrimBlanks(data_buf);
        ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);
        bool value_changed = InputTextEx(label, NULL, data_buf, IM_ARRAYSIZE(data_buf), bb.GetSize(), flags);
        if (g.ScalarAsInputTextId == 0)
        {
            // First frame we started displaying the InputText widget, we expect it to take the active id.
            IM_ASSERT(g.ActiveId == id);
            g.ScalarAsInputTextId = g.ActiveId;
        }
        if (value_changed)
            return DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, NULL);
        */
        return false;
    },

    // Edit a string of text
    // - When active, hold on a privately held copy of the text (and apply
    // back to 'buf'). So changing 'buf' while the InputText is active has
    // no effect.
    inputTextEx(label, hint, val, size_arg, flags, onEdit, editData, onChange)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        // Can't use both together (they both use up/down keys)
        console.assert(!((flags & InputTextFlags.CallbackHistory) &&
                         (flags & InputTextFlags.Multiline)));
        // Can't use both together (they both use tab key)
        console.assert(!((flags & InputTextFlags.CallbackCompletion) &&
                         (flags & InputTextFlags.AllowTabInput)));

        let g = this.guictx;
        let io = g.IO;
        const style = g.Style;
        const ismultiline = flags & InputTextFlags.Multiline;

        const RENDER_SELECTION_WHEN_INACTIVE = false;
        const is_multiline = (flags & InputTextFlags.Multiline) != 0;
        const is_readonly = (flags & InputTextFlags.ReadOnly) != 0;
        const is_password = (flags & InputTextFlags.Password) != 0;
        const is_undoable = (flags & InputTextFlags.NoUndoRedo) == 0;
        const is_resizable = (flags & InputTextFlags.CallbackResize) != 0;

        // Must provide a callback when InputTextFlags.CallbackResize
        if (is_resizable)
            console.assert(onEdit != null);

        // Open group before calling GetID() because groups tracks id
        // created within their scope,
        if (is_multiline)
            this.BeginGroup();
        const id = win.GetID(label);
        const label_size = this.CalcTextSize(label, true);
        // Arbitrary default of 8 lines high for multi-line
        let size = this.calcItemSize(size_arg, this.getNextItemWidth(),
                    (is_multiline ? this.GetTextLineHeight() * 8. : label_size.y) +
                        style.FramePadding.y*2);
        const frame_bb = new Rect(win.DC.CursorPos, Vec2.Add(win.DC.CursorPos, size));
        const total_bb = new Rect(frame_bb.Min,
                                Vec2.AddXY(frame_bb.Max,
                                    label_size.x > 0 ? (style.ItemInnerSpacing.x + label_size.x) : 0,
                                    0));

        let draw_window = win;
        if (is_multiline)
        {
            if (!this.itemAdd(total_bb, id, frame_bb))
            {
                this.itemSize(total_bb, style.FramePadding.y);
                this.EndGroup();
                return false;
            }
            if (!this.BeginChildFrame(id, frame_bb.GetSize()))
            {
                this.EndChildFrame();
                this.EndGroup();
                return false;
            }
            draw_window = this.getCurrentWindow();
            // This is to ensure that EndChild() will display a navigation highlight
            draw_window.DC.NavLayerActiveMaskNext |= draw_window.DC.NavLayerCurrentMask;
            size.x -= draw_window.ScrollbarSizes.x;
        }
        else
        {
            this.itemSize(total_bb, style.FramePadding.y);
            if (!this.itemAdd(total_bb, id, frame_bb))
                return false;
        }
        const hovered = this.itemHoverable(frame_bb, id);
        if (hovered)
        {
            g.MouseCursor = MouseCursor.TextInput;
            // console.log("hovered");
        }

        // NB: we are only allowed to access 'edit_state' if we are the active widget.
        let istate = null;
        if (g.InputTextState.ID == id)
            istate = g.InputTextState;

        const focus_requested = this.focusableItemRegister(win, id);
        const focus_requested_by_code = focus_requested &&
                                (g.FocusRequestCurrWindow == win &&
                                g.FocusRequestCurrCounterAll == win.DC.FocusCounterAll);
        const focus_requested_by_tab = focus_requested && !focus_requested_by_code;

        const user_clicked = hovered && io.MouseClicked[0];
        const user_nav_input_start = (g.ActiveId != id) &&
                                      ((g.NavInputId == id) ||
                                        (g.NavActivateId == id &&
                                         g.NavInputSource == InputSource.NavKeyboard));
        const user_scroll_finish = is_multiline && istate != null && g.ActiveId == 0 &&
                g.ActiveIdPreviousFrame == this.getScrollbarID(draw_window, Axis.Y);
        const user_scroll_active = is_multiline && istate != null &&
                    g.ActiveId == this.getScrollbarID(draw_window, Axis.Y);

        let clear_active_id = false;
        let select_all = (g.ActiveId != id) &&
            ((flags & InputTextFlags.AutoSelectAll) != 0 || user_nav_input_start)
                && (!is_multiline);

        const init_make_active = (focus_requested || user_clicked ||
                                user_scroll_finish || user_nav_input_start);
        const init_state = (init_make_active || user_scroll_active);
        if (init_state && g.ActiveId != id)
        {
            // Access state even if we don't own it yet.
            istate = g.InputTextState;
            istate.CursorAnimReset();

            // Take a copy of the initial value. From the moment we focused we are
            // ignoring the content of 'buf' (unless we are in read-only mode)
            istate.Init(val);

            // Preserve cursor position and undo/redo stack if we come back to
            // same widget FIXME: For non-readonly widgets we might be able to
            // require that TextIsValid && Text == val ? (untested) and
            // discard undo stack if user buffer has changed.
            const recycle_state = (istate.ID == id);
            if (recycle_state)
            {
                // Recycle existing cursor/selection/undo stack but clamp position
                // Note a single mouse click will override the cursor/position
                // immediately by calling stb_textedit_click handler.
                istate.CursorClamp();
            }
            else
            {
                istate.ID = id;
                istate.ScrollX = 0;
                istate.InitTextEdit(!is_multiline);
                if (!is_multiline && focus_requested_by_code)
                    select_all = true;
            }
            istate.EditState.InsertMode = (flags & InputTextFlags.AlwaysInsertMode);
            if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))
                select_all = true;
        }

        if (g.ActiveId != id && init_make_active)
        {
            console.assert(istate && istate.ID == id);
            this.setActiveID(id, win);
            this.setFocusID(id, win);
            this.FocusWindow(win);
            istate.Update(this, id, frame_bb, true, ismultiline);
            console.assert(NavInput.COUNT < 32);
            g.ActiveIdBlockNavInputFlags = (1 << NavInput.Cancel);
            if (flags & (InputTextFlags.CallbackCompletion | InputTextFlags.AllowTabInput))
            {
                // Disable keyboard tabbing out as we will use the \t character.
                g.ActiveIdBlockNavInputFlags |= (1 << NavInput.KeyTab);
            }
            if (!is_multiline && !(flags & InputTextFlags.CallbackHistory))
                g.ActiveIdAllowNavDirFlags = ((1 << Dir.Up) | (1 << Dir.Down));
            if(App.IsMobileDevice() || true)
            {
                // console.log(`make active ${frame_bb.Min.x}, ${frame_bb.Min.y}`);
            }
        }

        // We have an edge case if ActiveId was set through another widget (e.g.
        // widget being swapped), clear id immediately (don't wait until the end
        // of the function)
        if (g.ActiveId == id && istate == null)
            this.clearActiveID();

        // Release focus when we click outside
        if (g.ActiveId == id && io.MouseClicked[0] && !init_state && !init_make_active) //-V560
            clear_active_id = true;

        // Lock the decision of whether we are going to take the path displaying
        // the cursor or selection
        const render_cursor = (g.ActiveId == id) || (istate && user_scroll_active);
        let render_selection = istate && istate.HasSelection() &&
                               (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
        let value_changed = false;
        let enter_pressed = false;
        let enter_returns_true = (flags & InputTextFlags.EnterReturnsTrue) != 0;

        // When read-only we always use the live data passed to the function
        // FIXME-OPT: Because our selection/cursor code currently needs the
        // wide text we need to convert it when active, which is not ideal :(
        if (is_readonly && istate != null && (render_cursor || render_selection))
        {
            istate.Init(val);
            istate.CursorClamp();
            render_selection &= istate.HasSelection();
        }

        // Select the buffer to render.
        const val_display_from_state = (render_cursor || render_selection ||
                    g.ActiveId == id) && !is_readonly && istate && istate.TextIsValid;
        let is_displaying_hint = false;
        if(hint != null)
        {
            if(val_display_from_state)
                is_displaying_hint = (istate.Text.Length() == 0);
            else
                is_displaying_hint = (val.Length() == 0);
        }
        // k(hint != null && (buf_display_from_state ? state->TextA.Data : buf)[0] == 0);

        // Password pushes a temporary font with only a fallback glyph
        if (is_password && !is_displaying_hint)
        {
            this.PushFont(g.InputTextPasswordFont);
        }

        // Process mouse inputs and character inputs
        if (g.ActiveId == id)
        {
            console.assert(istate != null);
            istate.UserFlags = flags;
            istate.UserCallback = onEdit;
            istate.UserCallbackData = editData;

            // Although we are active we don't prevent mouse from hovering other
            // elements unless we are interacting right now with the widget.
            // Down the line we should have a cleaner library-wide concept of
            // Selected vs Active.
            g.ActiveIdAllowOverlap = !io.MouseDown[0];
            g.WantTextInputNextFrame = 1;

            // Edit in progress
            const mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + istate.ScrollX;
            const mouse_y = is_multiline ? (io.MousePos.y - draw_window.DC.CursorPos.y - style.FramePadding.y)
                                        : (g.FontLineHeight*0.5);

            const is_osx = io.ConfigMacOSXBehaviors;
            if (select_all || (hovered && !is_osx && io.MouseDoubleClicked[0]))
            {
                istate.SelectAll();
                istate.SelectedAllMouseLock = true;
            }
            else
            if (hovered && is_osx && io.MouseDoubleClicked[0])
            {
                // Double-click select a word only, OS X style (by simulating keystrokes)
                istate.OnKeyPressed(TextEditMetaKeys.WordLeft);
                istate.OnKeyPressed(TextEditMetaKeys.WordRight | TextEditMetaKeys.Shift);
            }
            else
            if (io.MouseClicked[0] && !istate.SelectedAllMouseLock)
            {
                if (hovered)
                {
                    istate.Click(mouse_x, mouse_y);
                    istate.CursorAnimReset();
                }
            }
            else
            if (io.MouseDown[0] && !istate.SelectedAllMouseLock &&
                (io.MouseDelta.x != 0 || io.MouseDelta.y != 0.))
            {
                istate.Drag(mouse_x, mouse_y);
                istate.CursorAnimReset();
                istate.CursorFollow = true;
            }
            if (istate.SelectedAllMouseLock && !io.MouseDown[0])
                istate.SelectedAllMouseLock = false;

            // It is ill-defined whether the back-end needs to send a \t
            // character when pressing the TAB keys. Win32 and GLFW naturally
            // do it but not SDL.
            const ignore_char_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);
            if ((flags & InputTextFlags.AllowTabInput) &&
                this.isKeyPressedMap(Key.Tab) && !ignore_char_inputs &&
                !io.KeyShift && !is_readonly)
            {
                // Insert TAB (XXX?)
                let c = this.inputTextFilterChar("\t", flags, onEdit, editData);
                if (c)
                    istate.OnKeyPressed(c.charCodeAt(0));
            }

            // Process regular text input (before we check for Return because
            // using some IME will effectively send a Return?) We ignore CTRL
            // inputs, but need to allow ALT+CTRL as some keyboards
            // (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
            if (io.InputKeyEvents.length > 0)
            {
                if (!ignore_char_inputs && !is_readonly && !user_nav_input_start)
                {
                    for (let n = 0; n < io.InputKeyEvents.length; n++)
                    {
                        // Insert character if they pass filtering
                        let evt = io.InputKeyEvents[n];
                        let key = evt.key; // May be "a", "A", "Tab"", "Escape",
                        let keyCode = evt.keyCode; // a _KEY_, not _CHAR_ code
                        if (keyCode == 9 && evt.shiftKey) // shift-tab
                            continue;
                        // skip all control and nav keys since we handle
                        // them below
                        if(evt.ctrlKey || evt.metaKey || evt.altKey)
                            continue;
                        if(io.NavKeys[key] != undefined)
                            continue;
                        let char = this.inputTextFilterChar(
                                            key, flags, onEdit, editData);
                        if (char)
                            istate.OnKeyPressed(char.charCodeAt(0));
                    }
                }
                // Consume all characters, even navkeys.
                io.InputKeyEvents.resize(0);
            }
        }

        // Process other shortcuts/key-presses
        let cancel_edit = false;
        if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)
        {
            console.assert(istate != null);
            const k_mask = (io.KeyShift ? TextEditMetaKeys.Shift : 0);
            const is_osx = io.ConfigMacOSXBehaviors;
            // OS X style: Shortcuts using Cmd/Super instead of Ctrl
            const is_shortcut_key = (is_osx ? (io.KeySuper && !io.KeyCtrl) :
                    (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift;
            const is_osx_shift_shortcut = is_osx && io.KeySuper && io.KeyShift
                                            && !io.KeyCtrl && !io.KeyAlt;
            // OS X style: Text editing cursor movement using Alt instead of Ctrl
            const is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;
            // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End
            const is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;
            const is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;
            const is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;

            const is_cut   = ((is_shortcut_key && this.isKeyPressedMap(Key.X)) ||
                              (is_shift_key_only && this.isKeyPressedMap(Key.Delete)))
                            && !is_readonly && !is_password &&
                            (!is_multiline || istate.HasSelection());
            const is_copy  = ((is_shortcut_key && this.isKeyPressedMap(Key.C)) ||
                            (is_ctrl_key_only  && this.isKeyPressedMap(Key.Insert)))
                            && !is_password && (!is_multiline || istate.HasSelection());
            const is_paste = ((is_shortcut_key && this.isKeyPressedMap(Key.V)) ||
                            (is_shift_key_only && this.isKeyPressedMap(Key.Insert)))
                            && !is_readonly;
            const is_undo  = ((is_shortcut_key && this.isKeyPressedMap(Key.Z)) &&
                            !is_readonly && is_undoable);
            const is_redo  = ((is_shortcut_key && this.isKeyPressedMap(Key.Y)) ||
                            (is_osx_shift_shortcut && this.isKeyPressedMap(Key.Z)))
                            && !is_readonly && is_undoable;

            if (this.isKeyPressedMap(Key.LeftArrow))
            {
                istate.OnKeyPressed((is_startend_key_down ? TextEditMetaKeys.LineStart :
                        is_wordmove_key_down ? TextEditMetaKeys.WordLeft :
                        TextEditMetaKeys.Left) | k_mask);
            }
            else
            if (this.isKeyPressedMap(Key.RightArrow))
            {
                istate.OnKeyPressed((is_startend_key_down ?
                        TextEditMetaKeys.LineEnd : is_wordmove_key_down ?
                        TextEditMetaKeys.WordRight :
                        TextEditMetaKeys.Right) | k_mask);
            }
            else
            if (this.isKeyPressedMap(Key.UpArrow) && is_multiline)
            {
                if (io.KeyCtrl)
                    draw_window.SetWindowScrollY(Math.max(draw_window.Scroll.y - g.FontLineHeight, 0.));
                else
                    istate.OnKeyPressed((is_startend_key_down ?
                            TextEditMetaKeys.TextStart :
                            TextEditMetaKeys.Up) | k_mask);
            }
            else
            if (this.isKeyPressedMap(Key.DownArrow) && is_multiline)
            {
                if (io.KeyCtrl)
                    draw_window.SetWindowScrollY(Math.max(draw_window.Scroll.y + g.FontLineHeight,
                                                                this.GetScrollMaxY()));
                else
                    istate.OnKeyPressed((is_startend_key_down ?
                            TextEditMetaKeys.TextEnd :
                            TextEditMetaKeys.Down) | k_mask);
            }
            else
            if (this.isKeyPressedMap(Key.Home))
            {
                istate.OnKeyPressed(io.KeyCtrl ?
                    (TextEditMetaKeys.TextStart | k_mask) :
                    (TextEditMetaKeys.LineStart | k_mask));
            }
            else
            if (this.isKeyPressedMap(Key.End))
            {
                istate.OnKeyPressed(io.KeyCtrl ?
                    (TextEditMetaKeys.TextEnd | k_mask) :
                    (TextEditMetaKeys.LineEnd | k_mask));
            }
            else
            if (this.isKeyPressedMap(Key.Delete) && !is_readonly)
            {
                istate.OnKeyPressed(TextEditMetaKeys.Delete | k_mask);
            }
            else
            if (this.isKeyPressedMap(Key.Backspace) && !is_readonly)
            {
                if (!istate.HasSelection())
                {
                    if (is_wordmove_key_down)
                        istate.OnKeyPressed(TextEditMetaKeys.WordLeft|
                                           TextEditMetaKeys.Shift);
                    else
                    if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl)
                        istate.OnKeyPressed(TextEditMetaKeys.LineStart|
                                           TextEditMetaKeys.Shift);
                }
                istate.OnKeyPressed(TextEditMetaKeys.Backspace | k_mask);
            }
            else
            if (this.isKeyPressedMap(Key.Enter))
            {
                let ctrl_nl = (flags & InputTextFlags.CtrlEnterForNewLine) != 0;
                if (!is_multiline || (ctrl_nl && !io.KeyCtrl) ||
                    (!ctrl_nl && io.KeyCtrl))
                {
                    enter_pressed = clear_active_id = true;
                }
                else
                if (!is_readonly)
                {
                    let c = this.inputTextFilterChar("\n", flags, onEdit, editData);
                    if(c)
                        istate.OnKeyPressed(c.charCodeAt(0));
                }
            }
            else
            if (this.isKeyPressedMap(Key.Escape))
            {
                clear_active_id = cancel_edit = true;
            }
            else
            if (is_undo || is_redo)
            {
                istate.OnKeyPressed(is_undo ?
                    TextEditMetaKeys.Undo : TextEditMetaKeys.Redo);
                istate.ClearSelection();
            }
            else
            if (is_shortcut_key && this.isKeyPressedMap(Key.A))
            {
                istate.SelectAll();
                istate.CursorFollow = true;
            }
            else
            if (is_cut || is_copy)
            {
                // Cut, Copy
                const selTxt = istate.GetSelectedText();
                if(selTxt != null)
                    this.SetClipboardText(selTxt);
                if (is_cut)
                {
                    if (!istate.HasSelection())
                        istate.SelectAll();
                    istate.CursorFollow = true;
                    istate.Cut();
                }
            }
            else
            if (is_paste)
            {
                // NB: GetClipboardText is async
                this.GetClipboardText((clipboard) =>
                {
                    if (!clipboard || !clipboard.length)
                    {
                        console.debug("empty clipboard");
                        return;
                    }

                    // Filter pasted buffer
                    let clipFiltered = [];
                    for(let i=0;i<clipboard.length;i++)
                    {
                        let c = clipboard[i];
                        let code = c.charCodeAt(0);
                        if (code == 0)
                            break;
                        if (code >= 0x10000)
                            continue;
                        c = this.inputTextFilterChar(c, flags, onEdit, editData);
                        if(!c)
                            continue;
                        clipFiltered.push(c);
                    }
                    clipFiltered = clipFiltered.join("");
                    // If everything was filtered, ignore the pasting operation
                    if (clipFiltered.length > 0)
                    {
                        istate.Paste(clipFiltered);
                        istate.CursorFollow = true;
                    }
                });
            }

            // Update render selection flag after events have been handled, so
            // selection highlight can be displayed during the same frame.
            render_selection |= istate.HasSelection() &&
                            (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
        }

        // Process callbacks and apply result back to user's buffer.
        if (g.ActiveId == id)
        {
            console.assert(istate != null);
            let apply_new_text = null;
            if (cancel_edit)
            {
                // Restore initial value. Only return true if restoring to the
                // initial value changes the current buffer contents.
                if (!is_readonly && val != istate.InitialText)
                    apply_new_text = istate.InitialText;
            }

            // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special
            // case we reapply the live buffer back to the input buffer before
            // clearing ActiveId, even though strictly speaking it wasn't
            // modified on this frame. If we didn't do that, code like
            // InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.
            // Also this allows the user to use InputText() with
            // InputTextFlags.EnterReturnsTrue without maintaining any user-side
            // storage.
            let apply_edit_back_to_user_buffer = !cancel_edit || 
                                    (enter_pressed && enter_returns_true);
            if (apply_edit_back_to_user_buffer)
            {
                // Apply new value immediately - copy modified buffer back
                // Note that as soon as the input box is active, the in-widget
                // value gets priority over any underlying modification of the
                // input buffer FIXME: We actually always render 'buf' when
                // calling DrawList->AddText, making the comment above incorrect.
                // FIXME-OPT: CPU waste to do this every time the widget is
                // active, should mark dirty state from the stb_textedit callbacks.
                if (!is_readonly)
                {
                    istate.TextIsValid = true;
                }

                // User callback
                if ((flags & (InputTextFlags.CallbackCompletion |
                             InputTextFlags.CallbackHistory |
                             InputTextFlags.CallbackAlways)) != 0)
                {
                    console.assert(onEdit != null || enter_returns_true);

                    // The reason we specify the usage semantic
                    // (Completion/History) is that Completion needs to disable
                    // keyboard TABBING at the moment.
                    let event_flag = 0;
                    let event_key = Key.COUNT;
                    if ((flags & InputTextFlags.CallbackCompletion) != 0 &&
                        this.isKeyPressedMap(Key.Tab))
                    {
                        event_flag = InputTextFlags.CallbackCompletion;
                        event_key = Key.Tab;
                    }
                    else
                    if ((flags & InputTextFlags.CallbackHistory) != 0 &&
                        this.isKeyPressedMap(Key.UpArrow))
                    {
                        event_flag = InputTextFlags.CallbackHistory;
                        event_key = Key.UpArrow;
                    }
                    else
                    if ((flags & InputTextFlags.CallbackHistory) != 0 &&
                        this.isKeyPressedMap(Key.DownArrow))
                    {
                        event_flag = InputTextFlags.CallbackHistory;
                        event_key = Key.DownArrow;
                    }
                    else
                    if (flags & InputTextFlags.CallbackAlways)
                        event_flag = InputTextFlags.CallbackAlways;

                    if (event_flag)
                    {
                        let callback_data = new InputTextCallbackData();
                        callback_data.EventFlag = event_flag;
                        callback_data.Flags = flags;
                        callback_data.UserData = editData;

                        callback_data.EventKey = event_key;
                        callback_data.Text = istate.Text;
                        callback_data.TextDirty = false;

                        callback_data.CursorPos = istate.EditState.Cursor;
                        callback_data.SelectionStart = istate.EditState.SelectionStart;
                        callback_data.SelectionEnd = istate.EditState.SelectionEnd;

                        // Call user code
                        if(onEdit)
                            onEdit(callback_data);
                        else
                        if(event_key == Key.Tab && enter_returns_true)
                        {
                            // or return true on Tab
                            enter_pressed = clear_active_id = true;
                        }

                        // Read back what user may have modified
                        console.assert(callback_data.Flags == flags);
                        istate.EditState.Cursor = callback_data.CursorPos;
                        istate.EditState.SelectionStart = callback_data.SelectionStart;
                        istate.EditState.SelectionEnd = callback_data.SelectionEnd;
                        if (callback_data.TextDirty)
                        {
                            istate.CursorAnimReset();
                        }
                    }
                }

                // Will copy result string if modified
                if (!is_readonly && !istate.Text.Equals(val))
                {
                    apply_new_text = istate.Text;
                }
            }

            // Copy result to user buffer
            if (apply_new_text)
            {
                // no resize event here...
                if(val.Copy != undefined)
                    val.Copy(apply_new_text); // otherwise, onchange is responsible
                value_changed = true;
            }

            // Clear temporary user storage
            istate.UserFlags = 0;
            istate.UserCallback = null;
            istate.UserCallbackData = null;
        }

        // Release active ID at the end of the function (so e.g. pressing
        // Return still does a final application of the value)
        if (clear_active_id && g.ActiveId == id)
        {
            this.clearActiveID();
            istate.Update(this, id, frame_bb, false, ismultiline);
        }

        // Render frame
        if (!is_multiline)
        {
            this.renderNavHighlight(frame_bb, id);
            this.renderFrame(frame_bb.Min, frame_bb.Max, style.GetColor("FrameBg"),
                            true, style.FrameRounding);
        }

        // Not using frame_bb.Max because we have adjusted size
        const clip_rect = Rect.FromXY(frame_bb.Min.x, frame_bb.Min.y,
                            frame_bb.Min.x + size.x, frame_bb.Min.y + size.y);

        let draw_pos = is_multiline ? draw_window.DC.CursorPos.Clone() :
                        Vec2.Add(frame_bb.Min, style.FramePadding);
        let text_size = Vec2.Zero();

        // val_display can either be str or MutableString
        let val_display = val_display_from_state ? istate.Text : val; //-V595
        let val_display_length=0;
        if (is_displaying_hint)
        {
            val_display = hint;
        }

        // Render text. We currently only render selection when the widget is
        // active or while scrolling. FIXME: We could remove the '&& render_cursor'
        // to keep rendering selection when inactive.
        if (render_cursor || render_selection)
        {
            console.assert(istate != null);

            // Render text (with cursor and selection)
            // This is going to be messy. We need to:
            // - Display the text (this alone can be more easily clipped)
            // - Handle scrolling, highlight selection, display cursor (those
            //   all requires some form of 1d->2d cursor position calculation)
            // - Measure text height (for scrollbar)
            // We are attempting to do most of that in **one main pass** to
            // minimize the computation cost (non-negligible for large amount
            //  of text) + 2nd pass for selection rendering (we could merge them
            //  by an extra refactoring effort)
            // FIXME: This should occur on val_display but we'd need to maintain
            //  cursor/select_start/select_end for UTF-8.
            let cursor_offset = new Vec2();
            let select_start_offset = new Vec2();

            {
                // Find line numbers straddling 'cursor' (slot 0) and
                // 'SelectStart' (slot 1) positions.
                let searches_input_offset = [ 0, 0 ];
                let searches_result_line_no = [ -1000, -1000 ];
                let searches_remaining = 0;
                if (render_cursor)
                {
                    searches_input_offset[0] = istate.EditState.Cursor;
                    searches_result_line_no[0] = -1;
                    searches_remaining++;
                }
                if (render_selection)
                {
                    searches_input_offset[1] = Math.min(istate.EditState.SelectStart,
                                                     istate.EditState.SelectEnd);
                    searches_result_line_no[1] = -1;
                    searches_remaining++;
                }

                // Iterate all lines to find our line numbers
                // In multi-line mode, we never exit the loop until all lines
                // are counted, so add one extra to the searches_remaining counter.
                searches_remaining += is_multiline ? 1 : 0;
                let line_count = 0;
                for (let i=0;i<istate.Text.Length();i++)
                {
                    if (istate.Text.IsNewline(i))
                    {
                        line_count++;
                        if (searches_result_line_no[0] == -1 &&
                            i >= searches_input_offset[0])
                        {
                            searches_result_line_no[0] = line_count;
                            if (--searches_remaining <= 0)
                                break;
                        }
                        if (searches_result_line_no[1] == -1 &&
                            i >= searches_input_offset[1])
                        {
                            searches_result_line_no[1] = line_count;
                            if (--searches_remaining <= 0)
                                break;
                        }
                    }
                }
                line_count++;
                if (searches_result_line_no[0] == -1)
                    searches_result_line_no[0] = line_count;
                if (searches_result_line_no[1] == -1)
                    searches_result_line_no[1] = line_count;

                // Calculate 2d position by finding the beginning of the line
                // and measuring distance
                let lineBegin = istate.Text.FindLineBegin(searches_input_offset[0]);
                cursor_offset.x = istate.EditState.CalcTextRunSize(istate.Text, lineBegin,
                                                searches_input_offset[0], true).x;
                cursor_offset.y = searches_result_line_no[0] * g.FontLineHeight;
                if (searches_result_line_no[1] >= 0)
                {
                    lineBegin = istate.Text.FindLineBegin(searches_input_offset[1]);
                    select_start_offset.x = istate.EditState.CalcTextRunSize(istate.Text,
                                                lineBegin, searches_input_offset[1],
                                                true).x;
                   select_start_offset.y = searches_result_line_no[1] * g.FontLineHeight;
                }

                // Store text height (note that we haven't calculated text width
                // at all, see GitHub issues #383, #1224)
                if (is_multiline)
                    text_size = new Vec2(size.x, line_count * g.FontLineHeight);
            }

            // Scroll
            if (render_cursor && istate.CursorFollow)
            {
                // Horizontal scroll in chunks of quarter width
                if (!(flags & InputTextFlags.NoHorizontalScroll))
                {
                    const scroll_increment_x = size.x * 0.25;
                    if (cursor_offset.x < istate.ScrollX)
                        istate.ScrollX = Math.floor(Math.max(0, cursor_offset.x - scroll_increment_x));
                    else
                    if (cursor_offset.x - size.x >= istate.ScrollX)
                        istate.ScrollX = Math.floor(cursor_offset.x - size.x + scroll_increment_x);
                }
                else
                {
                    istate.ScrollX = 0.;
                }

                // Vertical scroll
                if (is_multiline)
                {
                    let scroll_y = draw_window.Scroll.y;
                    if (cursor_offset.y - g.FontLineHeight < scroll_y)
                        scroll_y = Math.max(0, cursor_offset.y - g.FontLineHeight);
                    else
                    if (cursor_offset.y - size.y >= scroll_y)
                        scroll_y = cursor_offset.y - size.y;
                    // Manipulate cursor pos immediately avoid a frame of lag
                    draw_window.DC.CursorPos.y += (draw_window.Scroll.y - scroll_y);
                    draw_window.Scroll.y = scroll_y;
                    draw_pos.y = draw_window.DC.CursorPos.y;
                }

                istate.CursorFollow = false;
            }

            // Draw selection
            const draw_scroll = new Vec2(istate.ScrollX, 0);
            if (render_selection)
            {
                let text_selected_begin = Math.min(istate.EditState.SelectStart, istate.EditState.SelectEnd);
                let text_selected_end = Math.max(istate.EditState.SelectStart, istate.EditState.SelectEnd);

                // FIXME: current code flow mandate that render_cursor is always
                // true here, we are leaving the transparent one for tests.
                let bg_color = style.GetColor("TextSelectedBg",
                                            render_cursor ? 1 : 0.6);
                // FIXME: those offsets should be part of the style? they don't
                // play so well with multi-line selection.
                let bg_offy_up = is_multiline ? 0 : -1;
                let bg_offy_dn = is_multiline ? 0 : 2;
                let rect_pos = Vec2.Subtract(Vec2.Add(draw_pos, select_start_offset),
                                             draw_scroll);
                g.Font.MeasureBegin();
                for (let p = text_selected_begin; p < text_selected_end; )
                {
                    if (rect_pos.y > clip_rect.w + g.FontLineHeight)
                        break;
                    if (rect_pos.y < clip_rect.y)
                    {
                        //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bits
                        //p = p ? p + 1 : text_selected_end;
                        while (p < text_selected_end)
                        {
                            if(istate.Text.IsNewline(p++))
                                break;
                        }
                    }
                    else
                    {
                        let ret = istate.EditState.CalcTextRunSize(istate.Text,
                                                p, text_selected_end, true);
                        p = ret.lastIndex;
                        if (ret.x <= 0)
                            ret.x = Math.floor(g.Font.MeasureWidth(" ") * 0.5); // So we can see selected empty lines
                        let rect = new Rect(Vec2.AddXY(rect_pos, 0., bg_offy_up - g.FontLineHeight),
                                            Vec2.AddXY(rect_pos, ret.x, bg_offy_dn));
                        rect.ClipWith(clip_rect);
                        if (rect.Overlaps(clip_rect))
                            draw_window.DrawList.AddRectFilled(rect.Min, rect.Max, bg_color);
                    }
                    rect_pos.x = draw_pos.x - draw_scroll.x;
                    rect_pos.y += g.FontLineHeight;
                }
                g.Font.MeasureEnd();
            }

            // We test for 'val_display_max_length' as a way to avoid some
            // pathological cases (e.g. single-line 1 MB string) which would
            // make ImDrawList crash.
            if (is_multiline || val_display_length < MaxDisplayLength)
            {
                let col = style.GetColor(is_displaying_hint ? "TextDisabled" : "Text");
                let str = val_display.toString(); // to handle polymorphism
                draw_window.DrawList.AddText(str,
                                Vec2.Subtract(draw_pos, draw_scroll),
                                g.Font, g.FontLineHeight, col, 0,
                                is_multiline ? null : clip_rect);
            }

            // Draw blinking cursor
            if (render_cursor)
            {
                istate.CursorAnim += io.DeltaTime;
                let cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) ||
                            (istate.CursorAnim <= 0) ||
                            ((istate.CursorAnim % 1.2) <= 0.8);
                let cursor_screen_pos = Vec2.Subtract(Vec2.Add(draw_pos, cursor_offset),
                                                    draw_scroll);
                let cursor_screen_rect = Rect.FromXY(cursor_screen_pos.x,
                                            cursor_screen_pos.y - g.FontLineHeight + 0.5,
                                            cursor_screen_pos.x + 1.0,
                                            cursor_screen_pos.y - 1.5);
                if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))
                {
                    draw_window.DrawList.AddLine(cursor_screen_rect.Min,
                                        cursor_screen_rect.GetBL(),
                                        style.GetColor("Text"));
                }

                // Notify OS of text input position for advanced IME (-1 x
                // offset so that Windows IME can cover our cursor. Bit of an
                // extra nicety.)
                if (!is_readonly)
                    g.PlatformImePos = new Vec2(cursor_screen_pos.x - 1,
                                            cursor_screen_pos.y - g.FontLineHeight);
            }
        }
        else // !(render_cursor || render_selection)
        {
            // Render text only (no selection, no cursor)
            let str = val_display.toString();
            if (is_multiline)
            {
                // We don't need width
                text_size = new Vec2(size.x,
                                this.calcTextLineCount(val_display)*g.FontLineHeight);
            }
            else
                val_display_length = str ? str.length : 0;

            if (is_multiline || val_display_length < MaxDisplayLength)
            {
                let col = style.GetColor(is_displaying_hint ? "TextDisabled" : "Text");
                draw_window.DrawList.AddText(str, draw_pos, g.Font, g.FontLineHeight,
                            col, 0.0, is_multiline ? null : clip_rect);
            }
        }

        if (is_multiline)
        {
            // Always add room to scroll an extra line
            this.Dummy(Vec2.AddXY(text_size, 0., g.FontLineHeight));
            this.EndChildFrame();
            this.EndGroup();
        }

        if (is_password && !is_displaying_hint)
            this.PopFont();

        // Log as text
        if (g.LogEnabled && !(is_password && !is_displaying_hint))
            this.logRenderedText(draw_pos, val_display);

        if (label_size.x > 0)
            this.renderText(new Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                                     frame_bb.Min.y + style.FramePadding.y), label);

        if (value_changed)
        {
            this.markItemEdited(id);
            if(onChange)
                onChange(istate.Text.toString());
        }

        if ((flags & InputTextFlags.EnterReturnsTrue) != 0)
            return enter_pressed;
        else
            return value_changed;
    }, // end inputTextEx

    calcTextLineCount(mstr)
    {
        return mstr.CountLines();
    },

    // return null to discard a character, potentially replace
    // c with altc if requested.
    inputTextFilterChar(c, flags, onEdit, userdata)
    {
        // Filter non-printable (NB: isprint is unreliable! see #2467)
        let ccode = c.charCodeAt(0);
        if (ccode < 0x20)
        {
            let pass = false;
            pass |= (c == "\n" && (flags & InputTextFlags.Multiline));
            pass |= (c == "\t" && (flags & InputTextFlags.AllowTabInput));
            if (!pass)
                return null;
        }

        // Filter private Unicode range. GLFW on OSX seems to send private
        // characters for special keys like arrow keys (FIXME)
        if (ccode >= 0xE000 && ccode <= 0xF8FF)
            return null;

        // Generic named filters
        if (flags & (InputTextFlags.CharsDecimal | InputTextFlags.CharsHexadecimal |
                    InputTextFlags.CharsUppercase | InputTextFlags.CharsNoBlank |
                    InputTextFlags.CharsScientific))
        {
            if (flags & InputTextFlags.CharsDecimal)
            {
                if(ValidChars.Decimal.indexOf(c) == -1)
                    return null;
            }

            if (flags & InputTextFlags.CharsScientific)
            {
                if(ValidChars.Scientific.indexOf(c) == -1)
                    return null;
            }

            if (flags & InputTextFlags.CharsHexadecimal)
            {
                if(ValidChars.Hex.indexOf(c) == -1)
                    return null;
            }

            if (flags & InputTextFlags.CharsUppercase)
            {
                if (c >= "a" && c <= "z")
                {
                    c = c.toUpperCase();
                }
            }

            if (flags & InputTextFlags.CharsNoBlank)
            {
                if (/\s/.test(c))
                    return null;
            }
        }

        // Custom callback filter
        if (flags & InputTextFlags.CallbackCharFilter)
        {
            let callback_data = new InputTextCallbackData();
            callback_data.EventFlag = InputTextFlags.CallbackCharFilter;
            callback_data.EventChar = c;
            callback_data.Flags = flags;
            callback_data.UserData = userdata;
            if (onEdit(callback_data) != 0)
                return null;
            if (!callback_data.EventChar)
                return null;
            if(callback_data.EventChar != c)
            {
                c = callback_data.EventChar;
            }
        }
        return c;
    },

}; // end InputTextMixin
// =====================================================================================================================
// widgets/inputtext.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/menu.js BEGIN
// =====================================================================================================================


//-------------------------------------------------------------------------
// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
//-------------------------------------------------------------------------
// - ImGuiMenuColumns [Internal]
// - BeginMainMenuBar()
// - EndMainMenuBar()
// - BeginMenuBar()
// - EndMenuBar()
// - BeginMenu()
// - EndMenu()
// - MenuItem()
//-------------------------------------------------------------------------

/**
 * Used to track three columns associated with menu:
 *    0: label offset
 *    1: hot-key text (optional)
 *    2: selected checkbox (or pullaside) (optional)
 */
class MenuColumns
{
    constructor()
    {
        this.Spacing = 0;
        this.Width = 0;
        this.NextWidth = 0;
        this.Pos = [0, 0, 0];
        this.NextWidths = [0, 0, 0];
    }

    Update(count, spacing, clear)
    {
        this.Pos.length = count;
        this.NextWidths.length = count;
        this.Width = 0;
        this.NextWidth = 0;
        this.Spacing = spacing;
        if(clear)
            this.NextWidths = [0, 0, 0];
        for(let i=0;i<this.Pos.length;i++)
        {
            if(i > 0 && this.NextWidths[i] > 0)
                this.Width += this.Spacing;
            this.Pos[i] = Math.floor(this.Width);
            this.Width += this.NextWidths[i];
            this.NextWidths[i] = 0;
        }
    }

    DeclColumns(w0, w1, w2)
    {
        this.NextWidth = 0.;
        this.NextWidths[0] = Math.max(this.NextWidths[0], w0);
        this.NextWidths[1] = Math.max(this.NextWidths[1], w1);
        this.NextWidths[2] = Math.max(this.NextWidths[2], w2);
        for (let i=0; i<this.Pos.length; i++)
        {
            this.NextWidth += this.NextWidths[i] +
                ((i > 0 && this.NextWidths[i] > 0.) ? this.Spacing : 0.);
        }
        return Math.max(this.Width, this.NextWidth);
    }

    CalcExtraSpace(availW)
    {
        return Math.max(0, availW - this.Width);
    }
}

var ImguiMenuMixin =
{
    BeginMainMenuBar()
    {
        let g = this.guictx;
        g.NextWindowData.MenuBarOffsetMinVal =
            new Vec2(g.Style.DisplaySafeAreaPadding.x,
                Math.max(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0));
        this.SetNextWindowPos(new Vec2(0, 0));
        this.SetNextWindowSize(new Vec2(g.IO.DisplaySize.x,
            g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y));
        this.PushStyleVar("WindowRounding", 0);
        this.PushStyleVar("WindowMinSize", Vec2.Zero());
        let window_flags = WindowFlags.NoTitleBar | WindowFlags.NoResize |
                        WindowFlags.NoMove | WindowFlags.NoScrollbar |
                        WindowFlags.NoSavedSettings | WindowFlags.MenuBar;
        let is_open = this.Begin("##MainMenuBar", null, window_flags) && this.BeginMenuBar();
        this.PopStyleVar(2);
        g.NextWindowData.MenuBarOffsetMinVal = new Vec2(0, 0);
        if (!is_open)
        {
            this.End();
            return false;
        }
        return true; //-V1020
    },

    EndMainMenuBar()
    {
        this.EndMenuBar();

        // When the user has left the menu layer (typically: closed menus through
        // activation of an item), we restore focus to the previous window
        let g = this.guictx;
        if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0)
            this.focusPreviousWindowIgnoringOne(g.NavWindow);
        this.End();
    },

    BeginMenuBar()
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;
        if (!(win.Flags & WindowFlags.MenuBar))
            return false;

        console.assert(!win.DC.MenuBarAppending);
        this.BeginGroup(); // Backup position on layer 0
        this.PushID("##menubar");

        // We don't clip with current window clipping rectangle as it is already
        // set to the area below. However we clip with window full rect.
        // We remove 1 worth of rounding to max.x to that text in long menus
        // and small windows don't tend to display over the lower-right rounded
        // area, which looks particularly glitchy.
        let bar_rect = win.MenuBarRect();
        let clip_rect = Rect.FromXY(
            Math.floor(bar_rect.Min.x + 0.5),
            Math.floor(bar_rect.Min.y + win.WindowBorderSize + 0.5),
            Math.floor(Math.max(bar_rect.Min.x, bar_rect.Max.x - win.WindowRounding) + 0.5),
            Math.floor(bar_rect.Max.y + 0.5));
        clip_rect.ClipWith(win.OuterRectClipped);
        this.PushClipRect(clip_rect.Min, clip_rect.Max, false);

        win.DC.CursorPos = new Vec2(bar_rect.Min.x + win.DC.MenuBarOffset.x,
                                    bar_rect.Min.y + win.DC.MenuBarOffset.y);
        win.DC.LayoutType = LayoutType.Horizontal;
        win.DC.NavLayerCurrent = NavLayer.Menu;
        win.DC.NavLayerCurrentMask = (1 << NavLayer.Menu);
        win.DC.MenuBarAppending = true;
        this.AlignTextToFramePadding();
        return true;
    },

    EndMenuBar()
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;
        let g = this.guictx;

        // Nav: When a move request within one of our child menu failed, capture
        // the request to navigate among our siblings.
        if (this.navMoveRequestButNoResultYet() &&
            (g.NavMoveDir == Dir.Left || g.NavMoveDir == Dir.Right) &&
            (g.NavWindow.Flags & WindowFlags.ChildMenu))
        {
            let nav_earliest_child = g.NavWindow;
            while (nav_earliest_child.ParentWindow &&
                    (nav_earliest_child.ParentWindow.Flags & WindowFlags.ChildMenu))
            {
                nav_earliest_child = nav_earliest_child.ParentWindow;
            }
            if (nav_earliest_child.ParentWindow == win &&
                nav_earliest_child.DC.ParentLayoutType == LayoutType.Horizontal &&
                g.NavMoveRequestForward == NavForward.None)
            {
                // To do so we claim focus back, restore NavId and then process
                // the movement request for yet another frame. This involve a
                // one-frame delay which isn't very problematic in this situation.
                // We could remove it by scoring in advance for multiple window
                // (probably not worth the hassle/cost)
                console.assert(win.DC.NavLayerActiveMaskNext & 0x02); // Sanity check
                this.FocusWindow(win);
                this.setNavIDWithRectRel(win.NavLastIds[1], 1, win.NavRectRel[1]);
                g.NavLayer = NavLayer.Menu;
                // Hide highlight for the current frame so we don't see the
                // intermediary selection.
                g.NavDisableHighlight = true;
                g.NavMoveRequestForward = NavForward.ForwardQueued;
                this.navMoveRequestCancel();
            }
        }

        console.assert(win.Flags & WindowFlags.MenuBar);
        console.assert(win.DC.MenuBarAppending);
        this.PopClipRect();
        this.PopID();
        // Save horizontal position so next append can reuse it. This is kinda
        // equivalent to a per-layer CursorPos.
        win.DC.MenuBarOffset.x = win.DC.CursorPos.x - win.MenuBarRect().Min.x;
        let grp = win.DC.GroupStack[win.DC.GroupStack.length-1];
        grp.AdvanceCursor = false;
        this.EndGroup(); // Restore position on layer 0
        win.DC.LayoutType = LayoutType.Vertical;
        win.DC.NavLayerCurrent = NavLayer.Main;
        win.DC.NavLayerCurrentMask = (1 << NavLayer.Main);
        win.DC.MenuBarAppending = false;
    },

    BeginMenu(label, enabled=true)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        let style = g.Style;
        const id = win.GetID(label);

        let label_size = this.CalcTextSize(label, true);
        let pressed;
        let menu_is_open = this.isPopupOpen(id);
        let menuset_is_open = !(win.Flags & WindowFlags.Popup) &&
                        (g.OpenPopupStack.length > g.BeginPopupStack.length &&
                        g.OpenPopupStack[g.BeginPopupStack.length].OpenParentId ==
                            win.IDStack[win.IDStack.length-1]);
        let backed_nav_window = g.NavWindow;
        if (menuset_is_open)
        {
            // Odd hack to allow hovering across menus of a same menu-set
            // (otherwise we wouldn't be able to hover parent)
            g.NavWindow = win;
        }

        // The reference position stored in popup_pos will be used by Begin()
        // to find a suitable position for the child menu, However the final
        // position is going to be different! It is choosen by FindBestWindowPosForPopup().
        // e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
        let popup_pos, pos = win.DC.CursorPos.Clone();
        if (win.DC.LayoutType == LayoutType.Horizontal)
        {
            // Menu inside an horizontal menu bar
            // Selectable extend their highlight by half ItemSpacing in each direction.
            // For ChildMenu, the popup position will be overwritten by the call
            // to FindBestWindowPosForPopup() in Begin()
            popup_pos = new Vec2(pos.x - 1 - Math.floor(style.ItemSpacing.x * 0.5),
                                pos.y - style.FramePadding.y + win.MenuBarHeight());
            win.DC.CursorPos.x += Math.floor(style.ItemSpacing.x * 0.5);
            this.PushStyleVar("ItemSpacing", Vec2.Mult(style.ItemSpacing, 2.));
            let w = label_size.x;
            pressed = this.Selectable(label, menu_is_open,
                            SelectableFlags.NoHoldingActiveID |
                            SelectableFlags.PressedOnClick |
                            SelectableFlags.DontClosePopups |
                            (!enabled ? SelectableFlags.Disabled : 0),
                            new Vec2(w, 0));
            this.PopStyleVar();
            win.DC.CursorPos.x += Math.floor(style.ItemSpacing.x * (-1. + 0.5));
            // -1 spacing to compensate the spacing added when Selectable() did
            // a SameLine(). It would also work to call SameLine() ourselves after
            // the PopStyleVar().
        }
        else
        {
            // Menu inside a menu
            popup_pos = new Vec2(pos.x, pos.y - style.WindowPadding.y);
            let w = win.MenuColumns.DeclColumns(label_size.x, 0,
                                            Math.floor(g.FontSize * 1.2));
                                            // Feedback to next frame
            let extra_w = Math.max(0., this.GetContentRegionAvail().x - w);
            pressed = this.Selectable(label, menu_is_open,
                            SelectableFlags.NoHoldingActiveID |
                            SelectableFlags.PressedOnClick |
                            SelectableFlags.DontClosePopups |
                            SelectableFlags.DrawFillAvailWidth |
                            (!enabled ? SelectableFlags.Disabled : 0),
                            new Vec2(w, 0));
            if (!enabled)
                this.PushStyleColor("Text", g.Style.Colors["TextDisabled"]);
            this.renderArrow(Vec2.AddXY(pos,
                        win.MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30, 0.),
                        Dir.Right);
            if (!enabled)
                this.PopStyleColor();
        }

        const hovered = enabled && this.itemHoverable(win.DC.LastItemRect, id);
        if (menuset_is_open)
            g.NavWindow = backed_nav_window;

        let want_open = false, want_close = false;
        if (win.DC.LayoutType == LayoutType.Vertical) // (win.Flags & (WindowFlags.Popup|WindowFlags.ChildMenu))
        {
            // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown
            // to avoid using timers, so menus feels more reactive.
            let inOpenTri = false;
            if (g.HoveredWindow == win &&
                g.OpenPopupStack.length > g.BeginPopupStack.length &&
                g.OpenPopupStack[g.BeginPopupStack.length].ParentWindow == win &&
                !(win.Flags & WindowFlags.MenuBar))
            {
                let next_window = g.OpenPopupStack[g.BeginPopupStack.length].Window;
                if (next_window)
                {
                    // FIXME-DPI: Values should be derived from a master "scale" factor.
                    let next_window_rect = next_window.Rect();
                    let ta = Vec2.Subtract(g.IO.MousePos, g.IO.MouseDelta);
                    let tb = (win.Pos.x < next_window.Pos.x) ?
                            next_window_rect.GetTL() : next_window_rect.GetTR();
                    let tc = (win.Pos.x < next_window.Pos.x) ?
                            next_window_rect.GetBL() : next_window_rect.GetBR();
                    let extra = Vec1.Clamp(Math.abs(ta.x - tb.x) * 0.3, 5., 30.); // add a bit of extra slack.
                    ta.x += (win.Pos.x < next_window.Pos.x) ? -0.5 : +0.5;    // to avoid numerical issues
                    tb.y = ta.y + Math.max((tb.y - extra) - ta.y, -100.);
                    // triangle is maximum 200 high to limit the slope and the bias
                    // toward large sub-menus // FIXME: Multiply by fb_scale?
                    tc.y = ta.y + Math.min((tc.y + extra) - ta.y, +100.);
                    inOpenTri = TriangleContainsPoint(ta, tb, tc, g.IO.MousePos);
                    // win.DrawList.PushClipRectFullScreen();
                    // win.DrawList.AddTriangleFilled(ta, tb, tc, inOpenTri ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128));
                    // win.DrawList.PopClipRect(); // Debug
                }
            }

            want_close = (menu_is_open && !hovered && g.HoveredWindow == win &&
                    g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id &&
                    !inOpenTri);
            want_open = (!menu_is_open && hovered && !inOpenTri) ||
                    (!menu_is_open && hovered && pressed);

            if (g.NavActivateId == id)
            {
                want_close = menu_is_open;
                want_open = !menu_is_open;
            }
            if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == Dir.Right) // Nav-Right to open
            {
                want_open = true;
                this.navMoveRequestCancel();
            }
        }
        else
        {
            // Menu bar
            // Click an open menu again to close it
            if (menu_is_open && pressed && menuset_is_open)
            {
                want_close = true;
                want_open = menu_is_open = false;
            }
            else
            // First click to open, then hover to open others
            if (pressed || (hovered && menuset_is_open && !menu_is_open))
            {
                want_open = true;
            }
            else
            if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == Dir.Down) // Nav-Down to open
            {
                want_open = true;
                this.navMoveRequestCancel();
            }
        }

        if (!enabled)
        {
            // explicitly close if an open menu becomes disabled, facilitate users
            // code a lot in pattern such as
            //  'if (BeginMenu("options", has_object)) { ..use object.. }'
            want_close = true;
        }
        if (want_close && this.isPopupOpen(id))
            this.closePopupToLevel(g.BeginPopupStack.length, true);

        if (!menu_is_open && want_open &&
            g.OpenPopupStack.length > g.BeginPopupStack.length)
        {
            // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
            this.OpenPopup(label);
            return false;
        }

        menu_is_open |= want_open;
        if (want_open)
            this.OpenPopup(label);

        if (menu_is_open)
        {
            // Sub-menus are ChildWindow so that mouse can be hovering across them
            // (otherwise top-most popup menu would steal focus and not allow hovering
            // on parent menu)
            this.SetNextWindowPos(popup_pos, CondFlags.Always);
            let flags = WindowFlags.ChildMenu | WindowFlags.AlwaysAutoResize |
                        WindowFlags.NoMove | WindowFlags.NoTitleBar |
                        WindowFlags.NoSavedSettings | WindowFlags.NoNavFocus;
            if (win.Flags & (WindowFlags.Popup|WindowFlags.ChildMenu))
                flags |= WindowFlags.ChildWindow;
            // menu_is_open can be 'false' when the popup is completely clipped
            // (e.g. zero size display)
            menu_is_open = this.beginPopupEx(id, flags);
        }
        return menu_is_open;
    },

    EndMenu()
    {
        // Nav: When a left move request _within our child menu_ failed, close ourselves (the _parent_ menu).
        // A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.
        // However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (g.NavWindow && g.NavWindow.ParentWindow == win &&
            g.NavMoveDir == Dir.Left && this.navMoveRequestButNoResultYet() &&
            win.DC.LayoutType == LayoutType.Vertical)
        {
            this.closePopupToLevel(g.BeginPopupStack.length, true);
            this.navMoveRequestCancel();
        }
        this.EndPopup();
    },

    /**
    * 
    * @param {*} label 
    * @param {*} shortcut 
    * @param {*} selected 
    * @param {*} enabled 
    * 
    * return true when activated. shortcuts are displayed for convenience but
    * not processed by ImGui at the moment. 'selected' can be either a
    * boolean or a ValRef.
    */
    MenuItem(label, shortcut=null, selected=false, enabled=true)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        let style = g.Style;
        let pos = win.DC.CursorPos.Clone();
        let label_size = this.CalcTextSize(label, true);
        let flags = SelectableFlags.PressedOnRelease | (enabled ? 0 : SelectableFlags.Disabled);
        let pressed;
        if (win.DC.LayoutType == LayoutType.Horizontal)
        {
            // Mimic the exact layout spacing of BeginMenu() to allow MenuItem()
            // inside a menu bar, which is a little misleading but may be useful
            // Note that in this situation we render neither the shortcut neither o
            // the selected tick mark
            let w = label_size.x;
            win.DC.CursorPos.x += Math.floor(style.ItemSpacing.x * 0.5);
            this.PushStyleVar("ItemSpacing", style.ItemSpacing * 2.);
            pressed = this.Selectable(label, false, flags, new Vec2(w, 0));
            this.PopStyleVar();
            // -1 spacing to compensate the spacing added when Selectable() did a
            // SameLine(). It would also work to call SameLine() ourselves after
            // the PopStyleVar().
            win.DC.CursorPos.x += Math.floor(style.ItemSpacing.x * (-1.+ 0.5));
        }
        else
        {
            // Vertical menu
            let shortcut_size = shortcut ? this.CalcTextSize(shortcut) : Vec2.Zero();
            let w = win.MenuColumns.DeclColumns(label_size.x, shortcut_size.x,
                                                    Math.floor(g.FontSize * 1.2)); // Feedback for next frame
            let extra_w = Math.max(0., this.GetContentRegionAvail().x - w);
            pressed = this.Selectable(label, false, flags | SelectableFlags.DrawFillAvailWidth,
                                new Vec2(w, 0.0));
            if (shortcut_size.x > 0.)
            {
                this.PushStyleColor("Text", g.Style.Colors["TextDisabled"]);
                this.renderText(Vec2.AddXY(pos, win.MenuColumns.Pos[1] + extra_w, 0),
                                shortcut, false);
                this.PopStyleColor();
            }

            let sel = typeof(selected) === "boolean" ? selected : selected.get();
            if (sel)
            {
                this.renderCheckMark(Vec2.AddXY(pos,
                                                win.MenuColumns.Pos[2]+extra_w+g.FontSize*0.4,
                                                g.FontLineHeight * 0.134 * 0.5),
                                        g.Style.GetColor(enabled ? "Text" : "TextDisabled"),
                                        g.FontSize  * 0.866);
            }
        }
        if(pressed && typeof(selected) !== "boolean")
        {
            // pressed means toggle
            selected.set(!selected.get());
        }
        return pressed;
    }
}; // end mixin
// =====================================================================================================================
// widgets/menu.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/colorpicker.js BEGIN
// =====================================================================================================================


// - ColorPicker3()
// - ColorPicker4()
var ImguiColorPickerMixin =
{
    // here
    ColorPicker3(label, col, flags, onChange)
    {
        let col4 = col.Clone();
        col4.a = 1;
        if (!this.ColorPicker4(label, col4, flags | ColorEditFlags.NoAlpha, onChange))
            return false;
        col.x = col4.x; col.y = col4; col.z = col4.z;
        return true;
    },

    // nb: since we're working on canvas where we don't have vertex colors
    //   we adopt a simpler approach using combinations of linear gradients.
    //   This means our color picker offers a subset of the capabilities
    //   of the dear-imgui solution. Currnetly we don't support the
    //   Hue Wheel + SV variant, only the Hue Bar.

    ColorPicker4(label, col, flags, ref_col=null, onChange=null)
    {
        let g = this.guictx;
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let draw_list = win.DrawList;
        let style = g.Style;
        let io = g.IO;

        this.PushID(label);
        this.BeginGroup();

        if (!(flags & ColorEditFlags.NoSidePreview))
            flags |= ColorEditFlags.NoSmallPreview;

        // Context menu: display and store options.
        if (!(flags & ColorEditFlags.NoOptions)|| true)
            this.colorPickerOptionsPopup(col, flags);

        // Read stored options
        if (!(flags & ColorEditFlags.PickerMask))
            flags |= ((g.ColorEditOptions & ColorEditFlags.PickerMask) ?
                        g.ColorEditOptions : ColorEditFlags.OptionsDefault) &
                        ColorEditFlags.PickerMask;
        if (!(flags & ColorEditFlags.InputMask))
        {
            flags |= ((g.ColorEditOptions & ColorEditFlags.InputMask) ?
                        g.ColorEditOptions : ColorEditFlags.OptionsDefault) &
                        ColorEditFlags.InputMask;
        }
        console.assert(IsPowerOfTwo(flags & ColorEditFlags.PickerMask));
        console.assert(IsPowerOfTwo(flags & ColorEditFlags.InputMask));
        if (!(flags & ColorEditFlags.NoOptions))
            flags |= (g.ColorEditOptions & ColorEditFlags.AlphaBar);

        // Setup
        let components = (flags & ColorEditFlags.NoAlpha) ? 3 : 4;
        let alpha_bar = (flags & ColorEditFlags.AlphaBar) &&
                         !(flags & ColorEditFlags.NoAlpha);
        let picker_pos = win.DC.CursorPos.Clone();
        let square_sz = this.GetFrameHeight();
        let bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
                                    // Saturation/Value picking box
        let sv_picker_size = Math.max(bars_width * 1, this.CalcItemWidth() -
                        (alpha_bar?2:1)*(bars_width+style.ItemInnerSpacing.x));
        let bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
        let bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
        let bars_triangles_half_sz = Math.floor(bars_width * 0.2);
        let backup_initial_col = col.Clone();
        let hsv, rgb;
        if (flags & ColorEditFlags.InputRGB)
        {
            rgb = col;
            hsv = col.AsHSV();
        }
        else
        if (flags & ColorEditFlags.InputHSV)
        {
            hsv = col;
            rgb = col.AsRGB();
        }

        let value_changed = false;
        let value_changed_h = false;
        let value_changed_sv = false;

        this.PushItemFlag(ItemFlags.NoNav, true);
        if (flags & ColorEditFlags.PickerHueWheel)
        {
            console.assert("picker hue wheel not supported");
        }
        else
        if (flags & ColorEditFlags.PickerHueBar)
        {
            // SV rectangle logic
            this.InvisibleButton("sv", new Vec2(sv_picker_size, sv_picker_size));
            if (this.IsItemActive())
            {
                hsv.y = Vec1.Saturate((io.MousePos.x - picker_pos.x) / (sv_picker_size-1));
                hsv.z = 1. - Vec1.Saturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
                value_changed = value_changed_sv = true;
            }
            if (false && !(flags & ColorEditFlags.NoOptions))
                this.OpenPopupOnItemClick("context");

            // Hue bar logic
            this.SetCursorScreenPos(new Vec2(bar0_pos_x, picker_pos.y));
            this.InvisibleButton("hue", new Vec2(bars_width, sv_picker_size));
            if (this.IsItemActive())
            {
                hsv.x = Vec1.Saturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
                value_changed = value_changed_h = true;
            }
        }

        // Alpha bar logic
        if (alpha_bar)
        {
            this.SetCursorScreenPos(new Vec2(bar1_pos_x, picker_pos.y));
            this.InvisibleButton("alpha", new Vec2(bars_width, sv_picker_size));
            if (this.IsItemActive())
            {
                col.a = 1. - Vec1.Saturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
                value_changed = true;
            }
        }
        this.PopItemFlag(); // ItemFlags.NoNav

        if (!(flags & ColorEditFlags.NoSidePreview))
        {
            this.SameLine(0, style.ItemInnerSpacing.x);
            this.BeginGroup();
        }

        if (!(flags & ColorEditFlags.NoLabel))
        {
            let title = label.split("##")[0];
            if (title.length)
            {
                if ((flags & ColorEditFlags.NoSidePreview))
                    this.SameLine(0, style.ItemInnerSpacing.x);
                this.textEx(title);
            }
        }
        if (!(flags & ColorEditFlags.NoSidePreview))
        {
            // hm: this appears to be "behind" one edit since that happens
            // below
            this.PushItemFlag(ItemFlags.NoNavDefaultFocus, true);
            let col_v4 = col.Clone();
            if(flags & ColorEditFlags.NoAlpha)
                col_v4.a = 1.;
            if ((flags & ColorEditFlags.NoLabel))
                this.Text("Current");

            let sub_flags_to_forward = ColorEditFlags.InputMask |
                                      ColorEditFlags.HDR |
                                      ColorEditFlags.AlphaPreview |
                                      ColorEditFlags.AlphaPreviewHalf |
                                      ColorEditFlags.NoTooltip;
            this.ColorButton("##current", col_v4, (flags & sub_flags_to_forward),
                            new Vec2(square_sz * 3, square_sz * 2));
            if (ref_col != null)
            {
                this.Text("Original");
                let ref_col_v4 = ref_col.Clone();
                if(flags & ColorEditFlags.NoAlpha)
                    ref_col_v4.a = 1.;
                if (this.ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward),
                                     new Vec2(square_sz * 3, square_sz * 2)))
                {
                    col.Copy(ref_col);
                    value_changed = true;
                }
            }
            this.PopItemFlag();
            this.EndGroup();
        }

        // Convert back color to RGB
        if (value_changed_h || value_changed_sv)
        {
            if (flags & ColorEditFlags.InputRGB)
            {
                col.Copy(hsv.AsRGB());
            }
            else
            if (flags & ColorEditFlags.InputHSV)
            {
                col.Copy(hsv);
            }
        }

        // R,G,B and H,S,V slider color editor
        let value_changed_fix_hue_wrap = false;
        if ((flags & ColorEditFlags.NoInputs) == 0)
        {
            this.PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);
            let sub_flags_to_forward = ColorEditFlags.DataTypeMask |
                                       ColorEditFlags.InputMask |
                                       ColorEditFlags.HDR |
                                       ColorEditFlags.NoAlpha |
                                       ColorEditFlags.NoOptions |
                                       ColorEditFlags.NoSmallPreview |
                                       ColorEditFlags.AlphaPreview |
                                       ColorEditFlags.AlphaPreviewHalf;
            let sub_flags = (flags & sub_flags_to_forward) | ColorEditFlags.NoPicker;
            if (flags & ColorEditFlags.DisplayRGB || (flags & ColorEditFlags.DisplayMask) == 0)
            {
                if (this.ColorEdit4("##rgb", col, sub_flags | ColorEditFlags.DisplayRGB))
                {
                    // FIXME: Hackily differentiating using the DragInt
                    //  (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the
                    //  InputText or DropTarget.
                    // For the later we don't want to run the hue-wrap canceling
                    // code. If you are well versed in HSV picker please provide
                    // your input! (See #2050)
                    value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);
                    value_changed = true;
                }
            }
            if (flags & ColorEditFlags.DisplayHSV || (flags & ColorEditFlags.DisplayMask) == 0)
            {
                value_changed |= this.ColorEdit4("##hsv", col, sub_flags | ColorEditFlags.DisplayHSV);
            }
            if (flags & ColorEditFlags.DisplayHex || (flags & ColorEditFlags.DisplayMask) == 0)
            {
                value_changed |= this.ColorEdit4("##hex", col, sub_flags | ColorEditFlags.DisplayHex);
            }
            this.PopItemWidth();
        }
        // Try to cancel hue wrap (after ColorEdit4 call), if any
        if (value_changed_fix_hue_wrap && (flags & ColorEditFlags.InputRGB))
        {
            let newhsv = col.AsHSV();
            if (newhsv.x <= 0 && hsv.x > 0)
            {
                console.assert(0, "unverified");
                if (newhsv.z <= 0 && hsv.z != newhsv.z)
                {
                    newhsv.x = hsv.x;
                    newhsv.y = hsv.y;
                    newhsv.z = hsv.z * .5; // Value wrap
                    col = newhsv.AsRGB();
                }
                else
                if (newhsv.y <= 0) // Sat
                {
                    newhsv.x = hsv.x;
                    newhsv.y = hsv.y * .5;
                    col = newhsv.AsRGB();
                }
            }
        }

        if (value_changed)
        {
            if (flags & ColorEditFlags.InputRGB)
            {
                hsv = col.AsHSV();
            }
            else
            if (flags & ColorEditFlags.InputHSV)
            {
                rgb = col.AsRGB();
            }
        }

        // draw---------------------------------------------------------
        let hue_color = new Color(hsv.x, 1, 1, 1, "hsv").AsRGB();
        let colOpaque = rgb.AsOpaque();
        let colClear = Colors.clear;
        let sv_cursor_pos = new Vec2();
        if (flags & ColorEditFlags.PickerHueWheel)
        {
            // Render Hue Wheel
            console.assert(0, "hue wheel not implemented");
        }
        else
        if (flags & ColorEditFlags.PickerHueBar)
        {
            // Render SV Square
            let svRect = new Rect(picker_pos, Vec2.AddXY(picker_pos, sv_picker_size, sv_picker_size));
            // uleft, uright, bright, bleft
            // first we have a hue ramp left-to right
            draw_list.AddRectFilledMultiColor(svRect.Min, svRect.Max,
                                            Colors.white, hue_color,
                                            hue_color, Colors.white);
            // next we have a brightness ramp top to bottom
            draw_list.AddRectFilledMultiColor(svRect.Min, svRect.Max,
                                            Colors.clear, Colors.clear,
                                            Colors.black, Colors.black);
            this.renderFrameBorder(svRect.Min, svRect.Max, 0);

            // Sneakily prevent the circle to stick out too much
            sv_cursor_pos.x = Vec1.Clamp(Math.floor(picker_pos.x + Vec1.Saturate(hsv.y) * sv_picker_size + 0.5),
                                        picker_pos.x + 2, picker_pos.x + sv_picker_size - 2);
            sv_cursor_pos.y = Vec1.Clamp(Math.floor(picker_pos.y + Vec1.Saturate(1 - hsv.z) * sv_picker_size + 0.5),
                                         picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

            // Render Hue Bar
            let hueBarR = new Rect(new Vec2(bar0_pos_x, picker_pos.y),
                                  new Vec2(bar0_pos_x+bars_width, picker_pos.y+sv_picker_size));
            draw_list.AddRectRamp(hueBarR.Min, hueBarR.Max,
                                  HueRampStr, true/*top-to-bottom*/);
            let bar0_line_y = Math.floor(picker_pos.y + hsv.x * sv_picker_size + 0.5);
            this.renderFrameBorder(hueBarR.Min, hueBarR.Max,
                                   0/*no rounding*/);
            this.renderArrowsForVerticalBar(draw_list,
                                    new Vec2(bar0_pos_x - 1, bar0_line_y),
                                    new Vec2(bars_triangles_half_sz + 1, bars_triangles_half_sz),
                                    bars_width + 2.0);
        }

        // Render cursor/preview circle (clamp S/V within 0..1 range because
        // floating points colors may lead HSV values to be out of range)
        let sv_cursor_rad = value_changed_sv ? 4 : 2;
        draw_list.AddCircleFilled(sv_cursor_pos, sv_cursor_rad, colOpaque);
        draw_list.AddCircle(sv_cursor_pos, sv_cursor_rad+1, Colors.gray);
        draw_list.AddCircle(sv_cursor_pos, sv_cursor_rad, Colors.white);

        // Render alpha bar
        if (alpha_bar)
        {
            let alpha = Vec1.Saturate(col.a);
            let bar1_bb = Rect.FromXY(bar1_pos_x, picker_pos.y,
                                     bar1_pos_x + bars_width,
                                     picker_pos.y + sv_picker_size);
            this.renderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max,
                    Colors.clear, bar1_bb.GetWidth() / 2, Vec2.Zero());
            draw_list.AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max,
                    colOpaque, colOpaque,
                    colClear, colClear);
            let bar1_line_y = Math.floor(picker_pos.y + (1-alpha) * sv_picker_size + 0.5);
            this.renderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0);
            this.renderArrowsForVerticalBar(draw_list,
                    new Vec2(bar1_pos_x - 1, bar1_line_y),
                    new Vec2(bars_triangles_half_sz + 1, bars_triangles_half_sz),
                    bars_width + 2.);
        }

        this.EndGroup();

        if (value_changed && backup_initial_col.Equals(col))
            value_changed = false;
        if (value_changed)
            this.markItemEdited(win.DC.LastItemId);

        this.PopID();
        return value_changed;
    },

    // initialize current options (generally on application startup) if you
    // want to select a default format, picker type, etc. User will be able to
    // change many settings, unless you pass the _NoOptions flag to your calls.
    SetColorEditOptions(flags)
    {
        let g = this.guictx;
        if ((flags & ColorEditFlags.DisplayMask) == 0)
            flags |= ColorEditFlags.OptionsDefault & ColorEditFlags.DisplayMask;
        if ((flags & ColorEditFlags.DataTypeMask) == 0)
            flags |= ColorEditFlags.OptionsDefault & ColorEditFlags.DataTypeMask;
        if ((flags & ColorEditFlags.PickerMask) == 0)
            flags |= ColorEditFlags.OptionsDefault & ColorEditFlags.PickerMask;
        if ((flags & ColorEditFlags.InputMask) == 0)
            flags |= ColorEditFlags.OptionsDefault & ColorEditFlags.InputMask;
        // Check only 1 option is selected
        console.assert(IsPowerOfTwo(flags & ColorEditFlags.DisplayMask));
        console.assert(IsPowerOfTwo(flags & ColorEditFlags.DataTypeMask));
        console.assert(IsPowerOfTwo(flags & ColorEditFlags.PickerMask));
        console.assert(IsPowerOfTwo(flags & ColorEditFlags.InputMask));
        g.ColorEditOptions = flags;
    },

    /*-----------------------------------------------------------------*/
    colorEditOptionsPopup(col, flags)
    {
        let allow_opt_inputs = !(flags & ColorEditFlags.DisplayMask);
        let allow_opt_datatype = !(flags &ColorEditFlags.DataTypeMask);
        if ((!allow_opt_inputs && !allow_opt_datatype) ||
            !this.BeginPopup("context"))
        {
            return;
        }
        let g = this.guictx;
        let opts = g.ColorEditOptions;
        if (allow_opt_inputs)
        {
            if (this.RadioButton("RGB", (opts & ColorEditFlags.DisplayRGB) != 0))
                opts = (opts & ~ColorEditFlags.DisplayMask) | ColorEditFlags.DisplayRGB;
            if (this.RadioButton("HSV", (opts & ColorEditFlags.DisplayHSV) != 0))
                opts = (opts & ~ColorEditFlags.DisplayMask) | ColorEditFlags.DisplayHSV;
            if (this.RadioButton("Hex", (opts & ColorEditFlags.DisplayHex) != 0))
                opts = (opts & ~ColorEditFlags.DisplayMask) | ColorEditFlags.DisplayHex;
        }
        if (allow_opt_datatype)
        {
            if (allow_opt_inputs)
                this.Separator();
            if (this.RadioButton("0..255",     (opts & ColorEditFlags.Uint8) != 0))
                opts = (opts & ~ColorEditFlags.DataTypeMask)|ColorEditFlags.Uint8;
            if (this.RadioButton("0.00..1.00", (opts & ColorEditFlags.Float) != 0))
                opts = (opts & ~ColorEditFlags.DataTypeMask) | ColorEditFlags.Float;
        }

        if (allow_opt_inputs || allow_opt_datatype)
            this.Separator();
        if (this.Button("Copy as..", new Vec2(-1,0)))
            this.OpenPopup("Copy");
        if (this.BeginPopup("Copy"))
        {
            let cc = col.Array();
            let buf = cc.AsFloatStr();
            if (this.Selectable(buf))
                this.SetClipboardText(buf);
            buf = cc.AsIntStr();
            if (this.Selectable(buf))
                this.SetClipboardText(buf);
            buf = cc.asHexStr(flags & ColorEditFlags.NoAlpha);
            if (this.Selectable(buf))
                this.SetClipboardText(buf);
            this.EndPopup();
        }

        g.ColorEditOptions = opts;
        this.EndPopup();
    },

    // Helper for ColorPicker4()
    renderArrowsForVerticalBar(draw_list, pos, half_sz, bar_w)
    {

        this.renderArrowPointingAt(draw_list,
                            new Vec2(pos.x + half_sz.x + 1, pos.y),
                            new Vec2(half_sz.x + 2, half_sz.y + 1),
                            Dir.Right,
                            Colors.black);
        this.renderArrowPointingAt(draw_list,
                            new Vec2(pos.x + half_sz.x, pos.y),
                            half_sz,
                            Dir.Right,
                            Colors.white);
        this.renderArrowPointingAt(draw_list,
                            new Vec2(pos.x + bar_w - half_sz.x - 1, pos.y),
                            new Vec2(half_sz.x + 2, half_sz.y + 1),
                            Dir.Left,
                            Colors.black);
        this.renderArrowPointingAt(draw_list,
                            new Vec2(pos.x + bar_w - half_sz.x, pos.y),
                            half_sz,
                            Dir.Left,
                            Colors.white);
    },

    colorPickerOptionsPopup()
    {
        // unimplemented
    }
};
// =====================================================================================================================
// widgets/colorpicker.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/drag.js BEGIN
// =====================================================================================================================


var DragPayloads =
{
    "COLOR_3F": "_COL3F",
    "COLOR_4F": "_COL4F",
};

var DragFlags =
{
    None: 0,
    Vertical: 1,
    AsHyperText: 2,
    LongPress: 4, // only register drag after IO.LongPressInterval
                  //  we used the same id as ButtonFlags 
};

const DragFFmt = "%.3f";
const DragIFmt = "%d";

var ImguiDragMixin =
{
    // - CTRL+Click on any drag box to turn them into an input box. Manually
    //   input values aren't clamped and can go off-bounds.
    // - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every
    //   functions, note that a 'float v[X]' function argument is the same
    //   as 'float* v', the array syntax is just a way to document the number
    //   of elements that are expected to be accessible. You can pass address
    //   of your first element out of a contiguous set, e.g. &myvector.x
    // - Adjust format string to decorate the value with a prefix, a suffix,
    //   or adapt the editing and display precision e.g. "%.3f" -> 1.234;
    //   "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
    // - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to
    //   move by 5 pixels to increase value by 1). For gamepad/keyboard
    //   navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).
    DragFloat(label, val, v_speed=1, v_min=0, v_max=0, format=null,
            power=1, onChange=null, onDone=null, flags=0)
    {
        if(format==null) format=DragFFmt;
        return this.DragScalar(label, DataType.Float, val, v_speed, v_min, v_max,
                            format, power, onChange, onDone, flags);
    },

    DragVec2(label, val, v_speed=1, v_min=0, v_max=0, format=null,
            power=1, onChange=null, onDone=null, flags=0)
    {
        let value_changed = this.DragFloat2(label, [val.x, val.y],
                                        v_speed, v_min, v_max, format,
                                        power, (newval => {
                                            val.x = newval[0];
                                            val.y = newval[1];
                                        }), onDone, flags);
        if(value_changed && onChange)
            onChange(val);
        return value_changed;
    },

    // If v_min >= v_max we have no bound
    DragFloat2(label, val, v_speed=1, v_min=0, v_max=0, format=null,
                power=1, onChange=null, onDone=null, flags=0)
    {
        if(format==null) format=DragFFmt;
        return this.DragScalarN(label, DataType.Float, val, 2,
                                v_speed, v_min, v_max, format, power, 
                                onChange, onDone, flags);
    },

    DragFloat3(label, val, v_speed=1, v_min=0, v_max=0, format=null,
                power=1, onChange=null, onDone=null, flags=0)
    {
        if(format==null) format=DragFFmt;
        return this.DragScalarN(label, DataType.Float, val, 3,
                                v_speed, v_min, v_max, format, power, 
                                onChange, onDone, flags);
    },

    DragFloat4(label, val, v_speed=1, v_min=0, v_max=0, format=null,
                power=1, onChange=null, onDone=null, flags=0)
    {
        if(format==null) format=DragFFmt;
        if(val.AsArray != undefined)
        {
            let va = val.AsArray();
            return this.DragScalarN(label, DataType.Float, va, 4,
                            v_speed, v_min, v_max, format, 1,
                            function(newval)
                            {
                                val.CopyArray(newval);
                                if(onChange)
                                    onChange(val);
                            }, onDone, flags);
        }
        else
        {
            return this.DragScalarN(label, DataType.Float, val, 4,
                                v_speed, v_min, v_max, format, power, 
                                onChange, onDone, flags);
        }
    },

    DragFloatRange2(label, v_current_min, v_current_max, v_speed=1,
                v_min=0, v_max=0, format=null, format_max=null, power=1, 
                onChange=null, onDone=null, flags=0)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        this.PushID(label);
        this.BeginGroup();
        this.PushMultiItemsWidths(2, this.getNextItemWidth());

        let value_changed = this.DragFloat("##min", v_current_min, v_speed,
            (v_min >= v_max) ? -Number.MAX_VALUE : v_min,
            (v_min >= v_max) ? v_current_max : Math.min(v_max, v_current_max),
            format, power, 
            (newval)=>v_current_min = newval, onDone, flags);

        this.PopItemWidth();
        this.SameLine(0, g.Style.ItemInnerSpacing.x);
        value_changed |= this.DragFloat("##max", v_current_max, v_speed,
            (v_min >= v_max) ? v_current_min : Math.max(v_min, v_current_min),
            (v_min >= v_max) ? Number.MAX_VALUE : v_max,
            format_max ? format_max : format, power, 
            (newval)=>v_current_max=newval, onDone, flags);
        this.PopItemWidth();
        this.SameLine(0, g.Style.ItemInnerSpacing.x);

        this.textEx(label.split("##")[0]);
        this.EndGroup();
        this.PopID();

        if(value_changed && onChange)
        {
            onChange(v_current_min, v_current_max);
        }
        return value_changed;
    },

    DragInt(label, v, v_speed=1, v_min=0, v_max=0, format=null, 
            onChange=null, onDone=null, flags=0)
    {
        if(format==null) format=DragIFmt;
        return this.DragScalar(label, DataType.S32, v, v_speed, v_min, v_max,
                            format, 1, onChange, onDone, flags);
    },

    // If v_min >= v_max we have no bound
    DragInt2(label, v, v_speed=1, v_min=0, v_max=0, format=null, 
            onChange=null, onDone=null, flags=0)
    {
        if(format==null) format=DragIFmt;
        return this.DragScalarN(label, DataType.S32, v, 2, v_speed, v_min, v_max,
                            format, 1, onChange, onDone, flags);
    },

    // If v_min >= v_max we have no bound
    DragInt3(label, v, v_speed=1, v_min=0, v_max=0, format=null, 
            onChange=null, onDone=null, flags=0)
    {
        if(format==null) format=DragIFmt;
        return this.DragScalarN(label, DataType.S32, v, 3, v_speed, v_min, v_max,
                            format, 1, onChange, onDone, flags);
    },

    // If v_min >= v_max we have no bound
    DragInt4(label, v, v_speed=1, v_min=0, v_max=0, format=null, 
                            onChange=null, onDone=null, flags=0)
    {
        if(format==null) format=DragIFmt;
        return this.DragScalarN(label, DataType.S32, v, 4, v_speed,
                                v_min, v_max, format, 1, 
                                onChange, onDone, flags);
    },

    // If v_min >= v_max we have no bound
    DragIntRange2(label, v_current_min, v_current_max,
                  v_speed=1, v_min=0, v_max=0,
                  format=null, format_max=null, 
                  onChange=null, onDone=null, flags=0)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        this.PushID(label);
        this.BeginGroup();
        this.PushMultiItemsWidths(2, this.getNextItemWidth());
        let value_changed = this.DragInt("##min", v_current_min, v_speed,
            (v_min >= v_max) ? -Number.MAX_SAFE_INTEGER : v_min,
            (v_min >= v_max) ? v_current_max : Math.min(v_max, v_current_max),
            format,
            (newval)=>{v_current_min = newval;}, onDone, flags);
        this.PopItemWidth();
        this.SameLine(0, g.Style.ItemInnerSpacing.x);
        value_changed |= this.DragInt("##max", v_current_max, v_speed,
            (v_min >= v_max) ? v_current_min : Math.max(v_min, v_current_min),
            (v_min >= v_max) ? Number.MAX_SAFE_INTEGER : v_max,
            format_max ? format_max : format,
            (newval)=>v_current_max=newval, onDone, flags);
        this.PopItemWidth();
        this.SameLine(0, g.Style.ItemInnerSpacing.x);

        this.textEx(label.split("##")[0]);
        this.EndGroup();
        this.PopID();

        if(value_changed && onChange)
        {
            onChange(v_current_min, v_current_max);
        }
        return value_changed;
    },

    DragScalar(label, data_type, v, v_speed=1, v_min=0, v_max=0, format=null,
                power=1, onChange=null, onDone=null, flags=0)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        if (power != 1)
        {
            // When using a power curve the drag needs to have known bounds
            console.assert(v_min != null && v_max != null);
        }

        let g = this.guictx;
        const style = g.Style;
        const id = win.GetID(label);
        const w = this.CalcItemWidth();
        const label_size = this.CalcTextSize(label, true);
        let frame_bb, total_bb;
        let text_pos;
        if(flags & DragFlags.AsHyperText)
        {
            text_pos = new Vec2(win.DC.CursorPos.x, 
                        win.DC.CursorPos.y + win.DC.CurrentLineTextBaseOffset);

            frame_bb = new Rect(text_pos, Vec2.AddXY(text_pos, w, label_size.y));
            total_bb = new Rect(frame_bb.Min,
                            Vec2.AddXY(frame_bb.Max,
                                label_size.x>0 ? style.ItemInnerSpacing.x + label_size.x : 0,
                                0));
            this.itemSize(total_bb);
            if (!this.itemAdd(total_bb, id, frame_bb))
                return false;
        }
        else
        {
            frame_bb = new Rect(win.DC.CursorPos,
                                   Vec2.AddXY(win.DC.CursorPos,
                                            w, label_size.y+style.FramePadding.y*2));
            total_bb = new Rect(frame_bb.Min,
                                  Vec2.AddXY(frame_bb.Max,
                                    label_size.x > 0 ? 
                                        style.ItemInnerSpacing.x + label_size.x
                                        : 0,
                                    0));
            this.itemSize(total_bb, style.FramePadding.y);
            if (!this.itemAdd(total_bb, id, frame_bb))
                return false;
        }

        const hovered = this.itemHoverable(frame_bb, id);

        // Tabbing or CTRL-clicking on Drag turns it into an input box
        let start_text_input = false;
        const focus_requested = this.focusableItemRegister(win, id);
        if (focus_requested ||
            (hovered && (g.IO.MouseClicked[0] || g.IO.MouseDoubleClicked[0])) ||
            g.NavActivateId == id ||
            (g.NavInputId == id && g.ScalarAsInputTextId != id))
        {
            this.setActiveID(id, win);
            this.setFocusID(id, win);
            this.FocusWindow(win);
            g.ActiveIdAllowNavDirFlags = (1 << Dir.Up) | (1 << Dir.Down);
            if (focus_requested || g.IO.KeyCtrl ||
                g.IO.MouseDoubleClicked[0] || g.NavInputId == id)
            {
                start_text_input = true;
                g.ScalarAsInputTextId = 0;
            }
        }
        if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
        {
            win.DC.CursorPos = frame_bb.Min.Clone();
            this.focusableItemUnregister(win);
            return this.inputScalarAsWidgetReplacement(frame_bb, id, label,
                                                    data_type, v, format);
        }

        // Actual drag behavior
        const value_changed = this.dragBehavior(id, data_type, v, v_speed, v_min,
                                        v_max, format, power, flags,
                                        function(newval)
                                        {
                                            v = newval;
                                            if(onChange)
                                                onChange(v);
                                        },
                                        function()
                                        {
                                            if(onDone)
                                                onDone();
                                        });
        if (value_changed)
            this.markItemEdited(id);


        // Display value using user-provided display format so user 
        // can add prefix/suffix/decorations to the value.
        let valstr = FormatValues(format, [v]);

        if(flags & DragFlags.AsHyperText)
        {
            this.renderFrameBorder(frame_bb.Min, frame_bb.Max, 0, .5);

            let active = g.ActiveId == id && 
                         g.ActiveIdSource == InputSource.Mouse && 
                         g.IO.MouseDown[0];

            let col = style.GetColor((active||hovered) ? "LinkHovered" : "Link");
            this.PushStyleColor("Text", col);
            this.renderTextClipped(frame_bb.Min, frame_bb.Max, valstr, null,
                                new Vec2(0.5, 0.5));
            this.PopStyleColor();
        }
        else
        {
            const frame_col = style.GetColor(g.ActiveId == id ? "FrameBgActive" :
                    g.HoveredId == id ? "FrameBgHovered" : "FrameBg");
            this.renderNavHighlight(frame_bb, id);
            this.renderFrame(frame_bb.Min, frame_bb.Max, frame_col, true,
                            style.FrameRounding);

            // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
            this.renderTextClipped(frame_bb.Min, frame_bb.Max, valstr, null,
                                new Vec2(0.5, 0.5));

        }
        if (label_size.x > 0)
        {
            this.renderText(new Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                                        frame_bb.Min.y + style.FramePadding.y),
                                label);
        }

        return value_changed;
    },

    DragScalarN(label, data_type, v, components, v_speed=1, v_min=0, v_max=0,
                format=null, power=1, onChange=null, onDone=null, flags=0)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let g = this.guictx;
        let value_changed = false;
        this.BeginGroup();
        this.PushID(label);
        this.PushMultiItemsWidths(components, this.getNextItemWidth());
        for (let i = 0; i < components; i++)
        {
            this.PushID(i);
            this.DragScalar("", data_type, v[i], v_speed, v_min, v_max,
                            format, power, function(newval)
                            {
                                v[i] = newval;
                                value_changed = true;
                            }, onDone, flags);
            this.SameLine(0, g.Style.ItemInnerSpacing.x);
            this.PopID();
            this.PopItemWidth();
        }
        this.PopID();
        this.textEx(label.split("##")[0]);
        this.EndGroup();
        if(value_changed && onChange)
        {
            onChange(v);
        }
        return value_changed;
    },

    /*-------------------------------------------------------------*/
    // used by drag-text widgets
    dragBehavior(id, data_type, v, v_speed, v_min, v_max, format, power, 
                flags, onChange, onDone)
    {
        let g = this.guictx;
        if(g.ActiveId == id)
        {
            if(g.ActiveIdSource == InputSource.Mouse && !g.IO.MouseDown[0])
            {
                this.clearActiveID();
                if(onDone) onDone();
            }
            else
            if(g.ActiveIdSource == InputSource.Nav &&
                g.NavActivatePressedId == id && g.ActiveIdIsJustActivated)
            {
                this.clearActiveID();
                if(onDone) onDone();
            }
        }
        if(g.ActiveId != id)
            return false;

        const axis = (flags & DragFlags.Vertical) ? Axis.Y : Axis.X;
        const axisS = (flags & DragFlags.Vertical) ? "y" : "x";
        const isfloat = (data_type == DataType.Float);
        const has_min_max = (v_min != v_max);
        const is_power = (power != 1 && isfloat && has_min_max &&
                           (v_max - v_min < Number.MAX_VALUE));
        let precision = isfloat ? ParseFormatPrecision(format) : 0;

        // Default tweak speed
        if (v_speed == 0. && has_min_max && (v_max - v_min < Number.MAX_VALUE))
            v_speed = (v_max - v_min) * g.DragSpeedDefaultRatio;

        // Inputs accumulates into g.DragCurrentAccum, which is flushed into
        // the current value as soon as it makes a difference with our precision
        // settings
        let adjust_delta = 0.;
        if (g.ActiveIdSource == InputSource.Mouse && this.IsMousePosValid()
            && g.IO.MouseDragMaxDistanceSqr[0] > 1.)
        {
            if(!(flags & DragFlags.LongPress) ||
                 g.IO.MouseDownDuration[0] >= g.IO.LongPressInterval)
            {
                adjust_delta = g.IO.MouseDelta[axisS];
                if (g.IO.KeyAlt)
                    adjust_delta *= 1. / 100;
                if (g.IO.KeyShift)
                    adjust_delta *= 10;
            }
        }
        else
        if (g.ActiveIdSource == InputSource.Nav)
        {
            adjust_delta = this.getNavInputAmount2d(
                            NavDirSourceFlags.Keyboard | NavDirSourceFlags.PadDPad,
                            InputReadMode.RepeatFast, 1./10, 10)[axisS];
            v_speed = Math.max(v_speed, GetMinStepAtFloatPrecision(precision));
        }
        adjust_delta *= v_speed;

        // For vertical drag we currently assume that Up=higher value (like we
        // do with vertical sliders). This may become a parameter.
        if (axis == Axis.Y)
            adjust_delta = -adjust_delta;

        // Clear current value on activation
        // Avoid altering values and clamping when we are _already_ past the
        // limits and heading in the same direction, so e.g. if range is 0..255,
        // current value is 300 and we are pushing to the right side, keep the 300.
        let is_just_activated = g.ActiveIdIsJustActivated;
        let is_already_past_limits_and_pushing_outward = has_min_max &&
            ((v >= v_max && adjust_delta > 0) || (v <= v_min && adjust_delta < 0.));
        let is_drag_direction_change_with_power = is_power &&
            ((adjust_delta < 0 && g.DragCurrentAccum > 0) ||
             (adjust_delta > 0 && g.DragCurrentAccum < 0));
        if (is_just_activated || is_already_past_limits_and_pushing_outward
            || is_drag_direction_change_with_power)
        {
            g.DragCurrentAccum = 0.;
            g.DragCurrentAccumDirty = false;
        }
        else
        if (adjust_delta != 0.)
        {
            g.DragCurrentAccum += adjust_delta;
            g.DragCurrentAccumDirty = true;
        }

        if (!g.DragCurrentAccumDirty)
            return false;

        let v_cur = v;
        let v_old_ref_for_accum_remainder = 0.;

        if (is_power)
        {
            // Offset + round to user desired precision, with a curve on the
            // v_min..v_max range to get more precision on one side of the range
            let v_old_norm_curved = Math.pow((v_cur - v_min) / (v_max - v_min), 1/power);
            let v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));
            v_cur = v_min + Math.pow(Vec1.Saturate(v_new_norm_curved), power) * (v_max - v_min);
            v_old_ref_for_accum_remainder = v_old_norm_curved;
        }
        else
        {
            v_cur += g.DragCurrentAccum;
        }

        // Round to user desired precision based on format string
        v_cur = RoundScalarToPrecision(v_cur, precision);

        // Preserve remainder after rounding has been applied. This also
        // allow slow tweaking of values.
        g.DragCurrentAccumDirty = false;
        if (is_power)
        {
            let v_cur_norm_curved = Math.pow((v_cur - v_min) /(v_max - v_min), 1./power);
            g.DragCurrentAccum -= (v_cur_norm_curved - v_old_ref_for_accum_remainder);
        }
        else
        {
            g.DragCurrentAccum -= (v_cur - v); //XXX: sloppy for signed types?
        }

        // Clamp values (+ handle overflow/wrap-around for integer types)
        if (v != v_cur && has_min_max)
        {
            if (v_cur < v_min || (v_cur > v && adjust_delta < 0 && !isfloat))
                v_cur = v_min;
            if (v_cur > v_max || (v_cur < v && adjust_delta > 0 && !isfloat))
                v_cur = v_max;
        }

        if (v == v_cur)
            return false;
        // Apply result
        if(onChange)
            onChange(v_cur);
        return true;
    },
};
// =====================================================================================================================
// widgets/drag.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/column.js BEGIN
// =====================================================================================================================


//-----------------------------------------------------------------------------
// [SECTION] COLUMNS
// In the current version, Columns are very weak. Needs to be replaced with a
// more full-featured system.
//-----------------------------------------------------------------------------

var ColumnsFlags =
{
    None: 0,
    NoBorder: 1 << 0,   // Disable column dividers
    NoResize: 1 << 1,   // Disable resizing columns when clicking on the dividers
    NoPreserveWidths: 1 << 2,   // Disable column width preservation when adjusting columns
    NoForceWithinWindow: 1 << 3,   // Disable forcing columns to fit within window
    GrowParentContentsSize: 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.
};

class ColumnData
{
    constructor()
    {
        this.OffsetNorm = 0;
        this.OffsetNormBeforeResize = 0;
        this.Flags = 0; // None
        this.ClipRect = null;
    }
}

const ColumnsHitRectHalfWidth = 4;

class Columns
{
    constructor()
    {
        this.Columns = new ArrayEx();
        this.Clear();
    }

    Clear()
    {
        this.ID = 0;
        this.Flags = 0;
        this.IsFirstFrame = false;
        this.IsBeingResized = false;
        this.Current = 0;
        this.Count = 1;
        this.MinX = this.MaxX = 0.0;
        this.LineMinY = this.LineMaxY = 0.;
        this.BackupCursorPosY = 0.; // cursor at BeginColumns
        this.BackupCurosrMaxPosX = 0.;
        this.Columns.resize(0); // clear
    }
}

var ImguiColumnMixin =
{
    // Columns -----------------------------------
    // - You can also use SameLine(pos_x) to mimic simplified columns.
    // - The columns API is work-in-progress and rather lacking (columns are
    //   arguably the worst part of dear imgui at the moment!)
    Columns(count=1, id=null, border=true)
    {
        let win = this.getCurrentWindow();
        console.assert(count >= 1);

        let flags = (border ? 0 : ColumnsFlags.NoBorder);
        //flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
        let columns = win.DC.CurrentColumns;
        if (columns != null && columns.count == count && columns.Flags == flags)
            return;

        if (columns != null)
            this.endColumns();

        if (count != 1)
            this.beginColumns(id, count, flags);
    },

    // next column, defaults to current row or next row if the current row
    // is finished
    NextColumn()
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems || win.DC.CurrentColumns == null)
            return;

        let g = this.guictx;
        let columns = win.DC.CurrentColumns;
        if (columns.Count == 1)
        {
            win.DC.CursorPos.x = Math.floor(win.Pos.x + win.DC.Indent.x + win.DC.ColumnsOffset.x);
            console.assert(columns.Current == 0);
            return;
        }

        this.PopItemWidth();
        this.PopClipRect();

        columns.LineMaxY = Math.max(columns.LineMaxY, win.DC.CursorPos.y);
        if (++columns.Current < columns.Count)
        {
            // Columns 1+ cancel out IndentX
            win.DC.ColumnsOffset.x = this.GetColumnOffset(columns.Current) -
                                        win.DC.Indent.x + g.Style.ItemSpacing.x;
            win.DrawList.ChannelsSetCurrent(columns.Current);
        }
        else
        {
            // New line
            win.DC.ColumnsOffset.x = 0;
            win.DrawList.ChannelsSetCurrent(0);
            columns.Current = 0;
            columns.LineMinY = columns.LineMaxY;
        }
        win.DC.CursorPos.x = Math.floor(win.Pos.x + win.DC.Indent.x + win.DC.ColumnsOffset.x);
        win.DC.CursorPos.y = columns.LineMinY;
        win.DC.CurrentLineHeight = 0;
        win.DC.CurrentLineHeightMax = 0;
        win.DC.CurrentLineTextBaseOffset = 0;

        this.pushColumnClipRect();
        this.PushItemWidth(this.GetColumnWidth() * 0.65);  // FIXME: Move on columns setup
    },

    // get current column index
    GetColumnIndex()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.CurrentColumns ? win.DC.CurrentColumns.Current : 0;
    },

    GetColumnsCount()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.CurrentColumns ? win.DC.CurrentColumns.Count : 1;
    },

    offsetNormToPixels(columns, offset_norm)
    {
        return offset_norm * (columns.MaxX - columns.MinX);
    },

    pixelsToOffsetNorm(columns, offset)
    {
        return offset / (columns.MaxX - columns.MinX);
    },

    getDraggedColumnOffset(columns, column_index)
    {
        // Active (dragged) column always follow mouse. The reason we need
        // this is that dragging a column to the right edge of an auto-resizing
        // window creates a feedback loop because we store normalized positions.
        // So while dragging we enforce absolute positioning.
        let g = this.guictx;
        let win = g.CurrentWindow;
        console.assert(column_index > 0); // We are not supposed to drag column 0.
        console.assert(g.ActiveId == columns.ID + column_index);

        let x = g.IO.MousePos.x - g.ActiveIdClickOffset.x
                    + ColumnsHitRectHalfWidth - win.Pos.x;
        x = Math.max(x, this.GetColumnOffset(column_index-1) + g.Style.ColumnsMinSpacing);
        if ((columns.Flags & ColumnsFlags.NoPreserveWidths))
            x = Math.min(x, this.GetColumnOffset(column_index+1) - g.Style.ColumnsMinSpacing);
        return x;
    },

    // get position of column line (in pixels, from the left side of the
    // contents region). pass -1 to use current column, otherwise
    // 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
    GetColumnOffset(column_index=-1)
    {
        let win = this.getCurrentWindowRead();
        let columns = win.DC.CurrentColumns;
        console.assert(columns);
        if (column_index < 0)
            column_index = columns.Current;
        console.assert(column_index < columns.Columns.length);
        const t = columns.Columns[column_index].OffsetNorm;
        const x_offset = Vec1.Lerp(columns.MinX, columns.MaxX, t);
        return x_offset;
    },

    getColumnWidthEx(columns, column_index, before_resize=false)
    {
        if (column_index < 0)
            column_index = columns.Current;
        let offset_norm;
        if (before_resize)
            offset_norm = columns.Columns[column_index+1].OffsetNormBeforeResize
                        - columns.Columns[column_index].OffsetNormBeforeResize;
        else
            offset_norm = columns.Columns[column_index+1].OffsetNorm
                        - columns.Columns[column_index].OffsetNorm;
        return this.offsetNormToPixels(columns, offset_norm);
    },

    // get column width (in pixels). pass -1 to use current column
    GetColumnWidth(column_index=-1)
    {
        let win = this.getCurrentWindowRead();
        let columns = win.DC.CurrentColumns;
        console.assert(columns);
        if (column_index < 0)
            column_index = columns.Current;
        return this.offsetNormToPixels(columns,
                       columns.Columns[column_index+1].OffsetNorm -
                       columns.Columns[column_index].OffsetNorm);
    },

    // set position of column line (in pixels, from the left side of the
    // contents region). pass -1 to use current column
    SetColumnOffset(column_index, offset)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        let columns = win.DC.CurrentColumns;
        console.assert(columns);
        if (column_index < 0)
            column_index = columns.Current;
        console.assert(column_index < columns.Columns.length);
        const preserve_width = !(columns.Flags & ColumnsFlags.NoPreserveWidths) &&
                                (column_index < columns.Count-1);
        const width = preserve_width ? this.getColumnWidthEx(columns, column_index,
                                                columns.IsBeingResized) : 0;

        if (!(columns.Flags & ColumnsFlags.NoForceWithinWindow))
            offset = Math.min(offset, columns.MaxX -
                            g.Style.ColumnsMinSpacing*(columns.Count-column_index));
        columns.Columns[column_index].OffsetNorm =
                    this.pixelsToOffsetNorm(columns, offset - columns.MinX);

        if (preserve_width)
        {
            this.SetColumnOffset(column_index + 1,
                        offset + Math.max(g.Style.ColumnsMinSpacing, width));
        }
    },

    // set column width (in pixels). pass -1 to use current column
    SetColumnWidth(column_index, width)
    {
        let win = this.getCurrentWindowRead();
        let columns = win.DC.CurrentColumns;
        console.assert(columns);
        if (column_index < 0)
            column_index = columns.Current;
        this.SetColumnOffset(column_index + 1,
                        this.GetColumnOffset(column_index) + width);
    },

    pushColumnClipRect(column_index=-1)
    {
        let win = this.getCurrentWindowRead();
        let columns = win.DC.CurrentColumns;
        if (column_index < 0)
            column_index = columns.Current;
        let column = columns.Columns[column_index];
        this.PushClipRect(column.ClipRect.Min, column.ClipRect.Max, false);
    },

    findOrCreateColumns(win, id)
    {
        // We have few columns per window so for now we don't need bother
        // much with turning this into a faster lookup.
        for (let n = 0; n < win.ColumnsStorage.length; n++)
        {
            if (win.ColumnsStorage[n].ID == id)
                return win.ColumnsStorage[n];
        }
        win.ColumnsStorage.push(new Columns());
        let columns = win.ColumnsStorage.back();
        columns.ID = id;
        return columns;
    },

    getColumnsID(str_id, columns_count)
    {
        let win = this.getCurrentWindow();
        // Differentiate column ID with an arbitrary prefix for cases where
        // users name their columns set the same as another widget. In
        // addition, when an identifier isn't explicitly provided we include
        // the number of columns in the hash to make it uniquer.
        this.PushID(0x11223347 + (str_id ? 0 : columns_count));
        let id = win.GetID(str_id ? str_id : "columns");
        this.PopID();
        return id;
    },

    beginColumns(str_id, columns_count, flags)
    {
        let g = this.guictx;
        let win = this.getCurrentWindow();

        console.assert(columns_count >= 1);
        // Nested columns are currently not supported
        console.assert(win.DC.CurrentColumns == null);

        let id = this.getColumnsID(str_id, columns_count);

        // Acquire storage for the columns set
        let columns = this.findOrCreateColumns(win, id);
        console.assert(columns.ID == id);
        columns.Current = 0;
        columns.Count = columns_count;
        columns.Flags = flags;
        win.DC.CurrentColumns = columns;

        // Set state for first column
        const content_region_width = (win.SizeContentsExplicit.x != 0) ?
            (win.SizeContentsExplicit.x) : (win.InnerClipRect.Max.x - win.Pos.x);
        columns.MinX = win.DC.Indent.x - g.Style.ItemSpacing.x; // Lock our horizontal range
        columns.MaxX = Math.max(content_region_width - win.Scroll.x, columns.MinX + 1.);
        columns.BackupCursorPosY = win.DC.CursorPos.y;
        columns.BackupCursorMaxPosX = win.DC.CursorMaxPos.x;
        columns.LineMinY = columns.LineMaxY = win.DC.CursorPos.y;
        win.DC.ColumnsOffset.x = 0;
        win.DC.CursorPos.x = Math.floor(win.Pos.x + win.DC.Indent.x + win.DC.ColumnsOffset.x);

        // Clear data if columns count changed
        if (columns.Columns.length != 0 && columns.Columns.length != columns_count + 1)
            columns.Columns.resize(0);

        // Initialize defaults
        columns.IsFirstFrame = (columns.Columns.length == 0);
        if (columns.Columns.length == 0)
        {
            columns.Columns.length = columns_count+1; // reserve
            for (let n = 0; n < columns.Columns.length; n++)
            {
                let column = new ColumnData();
                column.OffsetNorm = n / columns_count;
                columns.Columns[n] = column;
            }
        }

        for (let n = 0; n < columns_count; n++)
        {
            // Compute clipping rectangle
            let column = columns.Columns[n];
            let clip_x1 = Math.floor(0.5 + win.Pos.x + this.GetColumnOffset(n) - 1.);
            let clip_x2 = Math.floor(0.5 + win.Pos.x + this.GetColumnOffset(n+1) - 1.);
            column.ClipRect = new Rect(clip_x1, -Number.MAX_VALUE,
                                       clip_x2, Number.MAX_VALUE);
            column.ClipRect.ClipWith(win.ClipRect);
        }

        if (columns.Count > 1)
        {
            win.DrawList.ChannelsSplit(columns.Count);
            this.pushColumnClipRect();
        }
        this.PushItemWidth(this.GetColumnWidth() * 0.65);
    },

    endColumns()
    {
        let g = this.guictx;
        let style = g.Style;
        let win = this.getCurrentWindow();
        let columns = win.DC.CurrentColumns;
        console.assert(columns);

        this.PopItemWidth();
        if (columns.Count > 1)
        {
            this.PopClipRect();
            win.DrawList.ChannelsMerge();
        }

        columns.LineMaxY = Math.max(columns.LineMaxY, win.DC.CursorPos.y);
        win.DC.CursorPos.y = columns.LineMaxY;
        if (!(columns.Flags & ColumnsFlags.GrowParentContentsSize))
        {
            // Restore cursor max pos, as columns don't grow parent
            win.DC.CursorMaxPos.x = columns.BackupCursorMaxPosX;
        }

        // Draw columns borders and handle resize
        let is_being_resized = false;
        if (!(columns.Flags & ColumnsFlags.NoBorder) && !win.SkipItems)
        {
            const y1 = Math.max(columns.BackupCursorPosY, win.ClipRect.Min.y);
            const y2 = Math.min(win.DC.CursorPos.y, win.ClipRect.Max.y);
            let dragging_column = -1;
            for (let n = 1; n < columns.Count; n++)
            {
                let column = columns.Columns[n];
                let x = win.Pos.x + this.GetColumnOffset(n);
                const column_id = columns.ID + n;
                const column_hit_hw = ColumnsHitRectHalfWidth;
                const column_rect = Rect.FromXY(x - column_hit_hw, y1,
                                                x + column_hit_hw, y2);
                this.keepAliveID(column_id);
                if (this.isClippedEx(column_rect, column_id, false))
                    continue;

                let hovered = new ValRef(false), held = new ValRef(false);
                if (!(columns.Flags & ColumnsFlags.NoResize))
                {
                    this.ButtonBehavior(column_rect, column_id, hovered, held);
                    if (hovered.get() || held.get())
                        g.MouseCursor = MouseCursor.ResizeEW;
                    if (held.get() && !(column.Flags & ColumnsFlags.NoResize))
                        dragging_column = n;
                }

                // Draw column (we clip the Y boundaries CPU side because very
                // long triangles are mishandled by some GPU drivers.)
                const col = style.GetColor(held.get() ? "SeparatorActive" :
                                hovered.get() ? "SeparatorHovered" : "Separator");
                const xi = Math.floor(x);
                win.DrawList.AddLine(new Vec2(xi, y1 + 1),
                                     new Vec2(xi, y2), col);
            }

            // Apply dragging after drawing the column lines, so our rendered
            // lines are in sync with how items were displayed during the frame.
            if (dragging_column != -1)
            {
                if (!columns.IsBeingResized)
                {
                    for (let n = 0; n < columns.Count + 1; n++)
                    {
                        columns.Columns[n].OffsetNormBeforeResize =
                                            columns.Columns[n].OffsetNorm;
                    }
                }
                columns.IsBeingResized = is_being_resized = true;
                let x = this.getDraggedColumnOffset(columns, dragging_column);
                this.SetColumnOffset(dragging_column, x);
            }
        }
        columns.IsBeingResized = is_being_resized;
        win.DC.CurrentColumns = null;
        win.DC.ColumnsOffset.x = 0;
        win.DC.CursorPos.x = Math.floor(win.Pos.x + win.DC.Indent.x + win.DC.ColumnsOffset.x);
    },

};

// =====================================================================================================================
// widgets/column.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/button.js BEGIN
// =====================================================================================================================


//-------------------------------------------------------------------------
// [SECTION] Widgets: Main
//-------------------------------------------------------------------------
// - ButtonBehavior() [Internal]
// - Button()
// - SmallButton()
// - InvisibleButton()
// - ArrowButton()
// - CloseButton() [Internal]
// - CollapseButton() [Internal]
// - Image()
// - ImageButton()
// - Checkbox()
// - CheckboxFlags()
// - RadioButton()
// - ProgressBar()
// - Bullet()

var ButtonFlags =
{
    None: 0,
    Repeat: 1 << 0,   // hold to repeat
    PressedOnClickRelease: 1 << 1,   // return true on click + release on same item [DEFAULT if no PressedOn* flag is set]
    PressedOnClick: 1 << 2,   // return true on click (default requires click+release)
    PressedOnRelease: 1 << 3,   // return true on release (default requires click+release)
    PressedOnDoubleClick: 1 << 4,   // return true on double-click (default requires click+release)
    FlattenChildren: 1 << 5,   // allow interactions even if a child window is overlapping
    AllowItemOverlap: 1 << 6,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()
    DontClosePopups: 1 << 7,   // disable automatically closing parent popup on press // [UNUSED]
    Disabled: 1 << 8,   // disable interactions
    AlignTextBaseLine: 1 << 9,   // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
    NoKeyModifiers: 1 << 10,  // disable interaction if a key modifier is held
    NoHoldingActiveID: 1 << 11,  // don't set ActiveId while holding the mouse (ButtonFlags.PressedOnClick only)
    PressedOnDragDropHold: 1 << 12,  // press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
    NoNavFocus: 1 << 13,   // don't override navigation focus when activated,
    Circle: 1 << 14,
    LongPress: 1 << 15, // only register release-click if held for 
                        //  greater than  IO.LongPressInterval, meaningful
                        // only if PressedOnClickRelease
};

var Icons =
{
    RightArrow: String.fromCodePoint(0x25B6),
    RightArrow2: String.fromCodePoint(0x25BA),
    DownArrow: String.fromCodePoint(0x25BC),
    Hamburger: String.fromCodePoint(0x2630),
    Gear: String.fromCodePoint(0x2699),
};

var ImguiButtonMixin =
{
    // out_hovered, out_held are either null or types.ValRef
    ButtonBehavior(bbox, id, out_hovered, out_held, flags=0)
    {
        let win = this.getCurrentWindow();
        let g = this.guictx;

        if (flags & ButtonFlags.Disabled)
        {
            if (out_hovered) out_hovered.set(false);
            if (out_held) out_held.set(false);
            if (g.ActiveId == id) this.clearActiveID();
            return false;
        }

        // Default behavior requires click+release on same spot
        if ((flags & (ButtonFlags.PressedOnClickRelease | ButtonFlags.PressedOnClick |
            ButtonFlags.PressedOnRelease | ButtonFlags.PressedOnDoubleClick)) == 0)
        {
            flags |= ButtonFlags.PressedOnClickRelease;
        }

        let backup_hovered_window = g.HoveredWindow;
        if ((flags & ButtonFlags.FlattenChildren) && g.HoveredRootWindow == win)
            g.HoveredWindow = win;

        let pressed = false;
        let hovered = this.itemHoverable(bbox, id);

        // Drag source doesn't report as hovered
        if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id &&
            !(g.DragDropSourceFlags & DragDropFlags.SourceNoDisableHover))
        {
            hovered = false;
        }

        // Special mode for Drag and Drop where holding button pressed for a long
        // time while dragging another item triggers the button
        if (g.DragDropActive && (flags & ButtonFlags.PressedOnDragDropHold) &&
            !(g.DragDropSourceFlags & DragDropFlags.SourceNoHoldToOpenOthers))
        {
            if (this.IsItemHovered(HoveredFlags.AllowWhenBlockedByActiveItem))
            {
                hovered = true;
                this.setHoveredID(id);
                // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy
                if (this.calcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001,
                                g.HoveredIdTimer + 0.0001 - g.IO.DeltaTime,
                                0.01, 0.70))
                {
                    pressed = true;
                    this.FocusWindow(win);
                }
            }
        }

        if ((flags & ButtonFlags.FlattenChildren) && g.HoveredRootWindow == win)
            g.HoveredWindow = backup_hovered_window;

        // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
        if (hovered && (flags & ButtonFlags.AllowItemOverlap) &&
            (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))
        {
            hovered = false;
        }

        // Mouse
        if (hovered)
        {
            if (!(flags & ButtonFlags.NoKeyModifiers) ||
                (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
            {
                //                        | CLICKING        | HOLDING with ButtonFlags.Repeat
                // PressedOnClickRelease  |  <on release>*  |  <on repeat> <on repeat> .. (NOT on release)  <-- MOST COMMON! (*) only if both click/release were over bounds
                // PressedOnClick         |  <on click>     |  <on click> <on repeat> <on repeat> ..
                // PressedOnRelease       |  <on release>   |  <on repeat> <on repeat> .. (NOT on release)
                // PressedOnDoubleClick   |  <on dclick>    |  <on dclick> <on repeat> <on repeat> ..
                // FIXME-NAV: We don't honor those different behaviors.
                if ((flags & ButtonFlags.PressedOnClickRelease) && g.IO.MouseClicked[0])
                {
                    this.setActiveID(id, win);
                    if (!(flags & ButtonFlags.NoNavFocus))
                        this.setFocusID(id, win);
                    this.FocusWindow(win);
                }
                if (((flags & ButtonFlags.PressedOnClick) && g.IO.MouseClicked[0]) ||
                ((flags & ButtonFlags.PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))
                {
                    pressed = true;
                    if (flags & ButtonFlags.NoHoldingActiveID)
                        this.clearActiveID();
                    else
                        this.setActiveID(id, win); // Hold on ID
                    this.FocusWindow(win);
                }
                // NB: PressedOnRelease registers a click even if the
                //  mouse-wasn't initially pressed here.
                if ((flags & ButtonFlags.PressedOnRelease) && g.IO.MouseReleased[0])
                {
                    // Repeat mode trumps <on release>
                    if(flags & ButtonFlags.LongPress)
                    {
                        pressed = g.IO.MouseDownDuration[0] >= g.IO.LongPressInterval;
                        // 
                    }
                    else
                    if (!((flags & ButtonFlags.Repeat) &&
                        g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))
                    {
                        pressed = true;
                    }
                    this.clearActiveID();
                }

                // 'Repeat' mode acts when held regardless of _PressedOn flags (see
                // table above). Relies on repeat logic of IsMouseClicked() but we
                // may as well do it ourselves if we end up exposing finer
                // RepeatDelay/RepeatRate settings.
                if ((flags & ButtonFlags.Repeat) && g.ActiveId == id &&
                    g.IO.MouseDownDuration[0] > 0. && this.IsMouseClicked(0, true))
                {
                    pressed = true;
                }
            }

            if (pressed)
                g.NavDisableHighlight = true;
        }

        // Gamepad/Keyboard navigation
        // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
        if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover &&
            (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == win.MoveId))
        {
            hovered = true;
        }

        if (g.NavActivateDownId == id)
        {
            let nav_activated_by_code = (g.NavActivateId == id);
            let nav_activated_by_inputs = this.isNavInputPressed(NavInput.Activate,
                (flags & ButtonFlags.Repeat) ? InputReadMode.Repeat : InputReadMode.Pressed);
            if (nav_activated_by_code || nav_activated_by_inputs)
                pressed = true;
            if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)
            {
                // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
                g.NavActivateId = id; // This is so setActiveId assign a Nav source
                this.setActiveID(id, win);
                if ((nav_activated_by_code || nav_activated_by_inputs) &&
                    !(flags & ButtonFlags.NoNavFocus))
                {
                    this.setFocusID(id, win);
                }
                g.ActiveIdAllowNavDirFlags = (1 << Dir.Left) | (1 << Dir.Right) |
                                            (1 << Dir.Up) | (1 << Dir.Down);
            }
        }

        let held = false;
        if (g.ActiveId == id)
        {
            if (pressed)
                g.ActiveIdHasBeenPressed = true;
            if (g.ActiveIdSource == InputSource.Mouse)
            {
                if (g.ActiveIdIsJustActivated)
                    g.ActiveIdClickOffset = Vec2.Subtract(g.IO.MousePos, bbox.Min);
                if (g.IO.MouseDown[0])
                {
                    held = true;
                }
                else
                {
                    if (hovered && (flags & ButtonFlags.PressedOnClickRelease))
                    {
                        // Repeat mode trumps <on release>
                        if (!((flags & ButtonFlags.Repeat) &&
                            g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))
                        {
                            if (!g.DragDropActive)
                            {
                                if(flags & ButtonFlags.LongPress)
                                {
                                    if(g.IO.MouseDownDurationPrev[0] >= 
                                        g.IO.LongPressInterval)
                                    {
                                        pressed = true;
                                    }
                                }
                                else
                                    pressed = true;
                            }
                        }
                    }
                    this.clearActiveID();
                }
                if (!(flags & ButtonFlags.NoNavFocus))
                    g.NavDisableHighlight = true;
            }
            else
            if (g.ActiveIdSource == InputSource.Nav)
            {
                if (g.NavActivateDownId != id)
                    this.clearActiveID();
            }
        }

        if (out_hovered)
            out_hovered.set(hovered);
        if (out_held)
            out_held.set(held);
        return pressed;
    }, // End ButtonBehavior

    ButtonEx(label, size_arg=null, flags=0)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems) return false;

        let g = this.guictx;
        let style = g.Style;
        let id = win.GetID(label);
        let label_size = this.CalcTextSize(label, true); // Vec2
        let pos = win.DC.CursorPos;
        // Try to vertically align buttons that are smaller/have no padding so
        // that text baseline matches (bit hacky, since it shouldn't be a flag)
        if ((flags & ButtonFlags.AlignTextBaseLine) &&
            style.FramePadding.y < win.DC.CurrentLineTextBaseOffset)
        {
            pos.y += win.DC.CurrentLineTextBaseOffset - style.FramePadding.y;
        }
        let size = this.calcItemSize(size_arg ? size_arg : Vec2.Zero(),
                                    label_size.x + style.FramePadding.x * 2,
                                    label_size.y + style.FramePadding.y * 2);

        let bbox = new Rect(pos, Vec2.Add(pos, size));
        this.itemSize(size, style.FramePadding.y);
        if (!this.itemAdd(bbox, id))
            return false;

        if (win.DC.ItemFlags & ItemFlags.ButtonRepeat)
            flags |= ButtonFlags.Repeat;
        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(bbox, id, hovered, held, flags);
        if (pressed)
            this.markItemEdited(id);

        // Render
        let col = style.GetColor((held.get() && hovered.get() ?
                        "ButtonActive" : hovered.get() ? "ButtonHovered" : "Button"));
        this.renderNavHighlight(bbox, id);
        if(flags & ButtonFlags.Circle)
        {
            let radius = .65*Math.max(label_size.x, label_size.y);
            let center = new Vec2(bbox.Min.x + radius, bbox.Min.y + radius);
            win.DrawList.AddCircleFilled(center, Math.max(2., radius), col);
        }
        else
            this.renderFrame(bbox.Min, bbox.Max, col, true, style.FrameRounding);
        this.renderTextClipped(Vec2.Add(bbox.Min, style.FramePadding),
                                Vec2.Subtract(bbox.Max, style.FramePadding),
                                label.split("##")[0], label_size, style.ButtonTextAlign,
                                bbox);
        return pressed;
    },

    // icons may be available in current font https://graphemica.com/
    Button(label, size_arg=null, flags=0)
    {
        return this.ButtonEx(label, size_arg, flags);
    },

    PopupButton(label, size_arg=null, flags=0)
    {
        let fields = label.split("##");
        label = fields[0] + " " + Icons.RightArrow;
        if(fields.length == 2)
            label += "##" + fields[1];
        return this.ButtonEx(label, size_arg, flags);
    },

    // Small buttons fits within text without additional vertical spacing.
    SmallButton(label, flags=ButtonFlags.AlignTextBaseLine)
    {
        let g = this.guictx;
        let backup_padding_y = g.Style.FramePadding.y;
        g.Style.FramePadding.y = 0.;
        let pressed = this.ButtonEx(label, Vec2.Zero(), flags);
        g.Style.FramePadding.y = backup_padding_y;
        return pressed;
    },

    // Tip: use ::PushID()/PopID() to push indices or pointers in the ID stack.
    // Then you can keep 'str_id' empty or the same for all your buttons (instead
    // of creating a string based on a non-string id)
    InvisibleButton(str_id, size_arg)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        // Cannot use zero-size for InvisibleButton(). Unlike Button() there is
        // not way to fallback using the label size.
        console.assert(size_arg.x != 0 && size_arg.y != 0);

        let id = win.GetID(str_id);
        let size = this.calcItemSize(size_arg, 0., 0.); // Vec2
        let bbox = new Rect(win.DC.CursorPos, Vec2.Add(win.DC.CursorPos, size));
        this.itemSize(size);
        if (!this.itemAdd(bbox, id))
            return false;

        return this.ButtonBehavior(bbox, id, null, null);
    },

    ArrowButtonEx(str_id, dir, size, flags)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;
        if(!size)
        {
            let sz = this.GetFrameHeight();
            size = new Vec2(sz, sz);
        }
        let g = this.guictx;
        let id = win.GetID(str_id);
        let bbox = new Rect(win.DC.CursorPos, Vec2.Add(win.DC.CursorPos, size));
        let default_size = this.GetFrameHeight();
        this.itemSize(bbox, (size.y >= default_size) ? g.Style.FramePadding.y : 0);
        if (!this.itemAdd(bbox, id))
            return false;

        if (win.DC.ItemFlags & ItemFlags.ButtonRepeat)
            flags |= ButtonFlags.Repeat;

        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(bbox, id, hovered, held, flags);
        let disabled = flags & ButtonFlags.Disabled;

        // Render
        let col = g.Style.GetColor((held.get() && hovered.get() ?
                    "ButtonActive" : hovered.get() ? "ButtonHovered" : "Button"));
        this.renderNavHighlight(bbox, id);
        this.renderFrame(bbox.Min, bbox.Max, col, true, g.Style.FrameRounding);
        this.renderArrow(Vec2.Add(bbox.Min,
                            new Vec2(Math.max(0., (size.x - g.FontSize) * 0.5),
                                     Math.max(0., (size.y - g.FontSize) * 0.5))
                                ), dir, 1/*scale*/, disabled);

        return pressed;
    },

    ArrowButton(str_id, dir)
    {
        let sz = this.GetFrameHeight();
        return this.ArrowButtonEx(str_id, dir, new Vec2(sz, sz), 0);
    },

    IconButton(str_id, icon)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;

        let flags = 0;
        let h = this.GetFrameHeight();
        let size = new Vec2(h, h);
        let g = this.guictx;
        let id = win.GetID(str_id);
        let bbox = new Rect(win.DC.CursorPos, Vec2.Add(win.DC.CursorPos, size));
        let default_size = this.GetFrameHeight();
        this.itemSize(bbox, (size.y >= default_size) ? g.Style.FramePadding.y : 0);
        if (!this.itemAdd(bbox, id))
            return false;

        if (win.DC.ItemFlags & ItemFlags.ButtonRepeat)
            flags |= ButtonFlags.Repeat;

        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(bbox, id, hovered, held, flags);

        // Render
        let col = g.Style.GetColor((held.get() && hovered.get() ?
                    "ButtonActive" : hovered.get() ? "ButtonHovered" : "Button"));
        this.renderNavHighlight(bbox, id);
        this.renderFrame(bbox.Min, bbox.Max, col, true, g.Style.FrameRounding);
        this.renderIcon(icon, Vec2.AddXY(bbox.Min,
                            Math.max(0., (size.x - g.FontSize) * 0.5),
                            Math.max(0., (size.y - g.FontSize) * 0.5)));
        return pressed;

    },

    IconButtonAlt(label, icon) // icons may be available in current font https://graphemica.com/
    {
        this.PushFont(this.guictx.Style.GetFont("Icons"));
        let ret = this.Button(`${icon}##${label}`); // add hover
        this.PopFont();
        return ret;
    },

    // Button to close a window
    CloseButton(id=null, pos=null, radius=6)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if(id == null)
            id = win.GetID("#CLOSE");
        let restorePos = null;

        if(!pos)
        {
            restorePos = this.GetCursorPosY();
            if(isNaN(restorePos))
                restorePos = null;
            let startPos = this.GetCursorScreenStartPos(); // in screen coords
            pos = startPos.AddXY(this.GetWindowWidth()-4*radius, 2*radius);
        }

        // We intentionally allow interaction when clipped so that a mechanical
        // Alt,Right,Validate sequence close a window. (this isn't the regular
        // behavior of buttons, but it doesn't affect the user much because
        // navigation tends to keep items visible).
        let r2 = new Vec2(radius, radius);
        let bbox = new Rect(Vec2.Subtract(pos,r2), Vec2.Add(pos, r2));
        let is_clipped = !this.itemAdd(bbox, id);

        if(restorePos)
            this.SetCursorPosY(restorePos);

        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(bbox, id, hovered, held);
        if (is_clipped)
            return pressed;


        // Render
        let center = bbox.GetCenter();
        if (hovered.get())
        {
            win.DrawList.AddCircleFilled(center, Math.max(2., radius),
                        g.Style.GetColor(held ? "ButtonActive" : "ButtonHovered"));
        }

        let cross_extent = (radius * 0.7071) - 1.0;
        let cross_col = g.Style.GetColor("Text");
        // center.SubtractXY(0.5, 0.5);
        win.DrawList.AddLine(Vec2.AddXY(center, cross_extent, cross_extent),
                                Vec2.AddXY(center, -cross_extent,  -cross_extent),
                                cross_col, 1);
        win.DrawList.AddLine(Vec2.AddXY(center, cross_extent,-cross_extent),
                                Vec2.AddXY(center, -cross_extent,cross_extent),
                                cross_col, 1);
        return pressed;
    },

    CollapseButton(idOrStr, pos)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        let id;
        if(typeof(idOrStr) == "string")
            id = win.GetID(idOrStr);
        else
            id = idOrStr;

        let bbox = new Rect(pos, Vec2.Add(Vec2.AddXY(pos, g.FontSize, g.FontSize),
                                        Vec2.Mult(g.Style.FramePadding, 2.)));
        this.itemAdd(bbox, id);
        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(bbox, id, hovered, held, ButtonFlags.None);
        let col = g.Style.GetColor((held.get() && hovered.get() ?
                    "ButtonActive" : hovered.get() ? "ButtonHovered" : "Button"));
        if (hovered.get() || held.get())
        {
            win.DrawList.AddCircleFilled(bbox.GetCenter(),
                                            g.FontSize * 0.5+2, col);
        }
        let apos = bbox.Min.Add(g.Style.FramePadding);
        apos.x += .5; // apos.y += .5;
        this.renderArrow(apos, win.Collapsed ? Dir.Right : Dir.Down);

        // Switch to moving the window after mouse is moved beyond the initial drag threshold
        if (this.IsItemActive() && this.IsMouseDragging())
            this.startMouseMovingWindow(win);
        return pressed;
    },

    // selected can be boolean or ValRef, if boolean then optional toggleFunc is
    // invoked when selected state is changed
    Checkbox(label, selected, toggleFunc=null)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems) return false;

        let g = this.guictx;
        const style = g.Style;
        const id = win.GetID(label);
        const label_size = this.CalcTextSize(label, true);
        const square_sz = this.GetFrameHeight();
        const pos = win.DC.CursorPos.Clone();
        const sz = new Vec2(square_sz + (label_size.x>0?style.ItemInnerSpacing.x+label_size.x:0),
                            label_size.y + style.FramePadding.y * 2.0);
        const max = Vec2.Add(pos, sz);
        const total_bb = new Rect(pos, max);
        this.itemSize(total_bb, style.FramePadding.y);
        if (!this.itemAdd(total_bb, id))
            return false;

        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(total_bb, id, hovered, held);
        let sel = (selected.value == undefined) ? selected : selected.get();
        if (pressed)
        {
            // toggle val
            sel = !sel;
            if(selected.value != undefined)
                selected.set(sel);
            else
            if(toggleFunc)
                toggleFunc(sel);
            this.markItemEdited(id);
        }

        const check_bb = new Rect(pos, Vec2.AddXY(pos, square_sz, square_sz));
        this.renderNavHighlight(total_bb, id);
        this.renderFrame(check_bb.Min, check_bb.Max,
                        style.GetColor((held.get() && hovered.get()) ? "FrameBgActive" :
                                        hovered.get() ? "FrameBgHovered" : "FrameBg"),
                        true, style.FrameRounding);
        if (sel)
        {
            const pad = Math.max(1, Math.floor(square_sz / 6.0));
            this.renderCheckMark(Vec2.Add(check_bb.Min, pad),
                                style.GetColor("CheckMark"), square_sz - pad*2);
        }

        if (g.LogEnabled)
            this.logRenderedText(total_bb.Min, selected ? "[x]" : "[ ]");
        if (label_size.x > 0.)
        {
            this.renderText(new Vec2(check_bb.Max.x + style.ItemInnerSpacing.x,
                                     check_bb.Min.y + style.FramePadding.y),
                            label);
        }
        return pressed;
    },

    // modify one bit of a bitflag, toggleFunc is invoked on pressed
    // flags and flags_value are assumed integral numbers. toggleFunc only
    // invoked if on pressed.
    CheckboxFlags(label, flags, flags_bit, onChange=null)
    {
        let v = new ValRef(((flags & flags_bit) == flags_bit));
        let pressed = this.Checkbox(label, v);
        if (pressed && onChange)
        {
            if (v.get())
                flags |= flags_bit;
            else
                flags &= ~flags_bit;
            onChange(flags);
        }
        return pressed;
    },

    // use with e.g. if (RadioButton("one", my_value==1)) { my_value = 1; }
    RadioButton(label, active)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;
        let g = this.guictx;
        const style = g.Style;
        const id = win.GetID(label);
        const label_size = this.CalcTextSize(label, true);
        const square_sz = this.GetFrameHeight();
        const pos = win.DC.CursorPos;
        const check_bb = new Rect(pos, Vec2.AddXY(pos, square_sz, square_sz));
        const total_bb = new Rect(pos, Vec2.AddXY(pos,
                        square_sz + (label_size.x > 0 ? style.ItemInnerSpacing.x + label_size.x : 0),
                        label_size.y + style.FramePadding.y * 2));
        this.itemSize(total_bb, style.FramePadding.y);
        if (!this.itemAdd(total_bb, id))
            return false;

        let center = check_bb.GetCenter();
        center.x = Math.floor(center.x + 0.5);
        center.y = Math.floor(center.y + 0.5);
        const radius = (square_sz - 1) * 0.5;

        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(total_bb, id, hovered, held);
        if (pressed)
        {
            this.markItemEdited(id);
        }

        this.renderNavHighlight(total_bb, id);
        win.DrawList.AddCircleFilled(center, radius,
                style.GetColor((held.get() && hovered.get()) ? "FrameBgActive" :
                    hovered.get() ? "FrameBgHovered" : "FrameBg"),
                16);

        if (active)
        {
            const pad = Math.max(1, Math.floor(square_sz / 6));
            win.DrawList.AddCircleFilled(center, radius-pad,
                                        style.GetColor("CheckMark"), 16);
        }

        if (style.FrameBorderSize > 0)
        {
            win.DrawList.AddCircle(Vec2.AddXY(center, 1,1), radius,
                                    style.GetColor("BorderShadow"),
                                    16, style.FrameBorderSize);
            win.DrawList.AddCircle(center, radius,
                                    style.GetColor("Border"),
                                    16, style.FrameBorderSize);
        }

        if (g.LogEnabled)
            this.LogRenderedText(total_bb.Min, active ? "(x)" : "( )");

        if (label_size.x > 0)
        {
            this.renderText(new Vec2(check_bb.Max.x + style.ItemInnerSpacing.x,
                                     check_bb.Min.y + style.FramePadding.y),
                            label);
        }
        return pressed;
    },

    // draw a small circle and keep the cursor on the same line. advance cursor
    // x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses
    Bullet()
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return;

        let g = this.guictx;
        const style = g.Style;
        const line_height = Math.max(Math.min(win.DC.CurrentLineHeight,
                                        g.FontLineHeight + g.Style.FramePadding.y*2),
                                    g.FontLineHeight);
        const bb = new Rect(win.DC.CursorPos,
                        Vec2.AddXY(win.DC.CursorPos,g.FontSize, line_height));
        this.itemSize(bb);
        if (!this.itemAdd(bb, 0))
        {
            this.SameLine(0, style.FramePadding.x*2);
            return;
        }

        // Render and stay on same line
        this.renderBullet(Vec2.AddXY(bb.Min,
                            style.FramePadding.x + g.FontSize*0.5,
                            g.FontSize*0.5));
        this.SameLine(0, style.FramePadding.x*2);
    },

    // size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
    ProgressBar(fraction, size_arg, overlay)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems) return;

        let g = this.guictx;
        const style = g.Style;
        let pos = win.DC.CursorPos;
        let size = this.calcItemSize(size_arg, this.CalcItemWidth(),
                                    g.FontSize + style.FramePadding.y*2.0);
        let bb = new Rect(pos, Vec2.Add(pos, size));
        this.itemSize(bb, style.FramePadding.y);
        if (!this.itemAdd(bb, 1))
            return;

        // Render
        fraction = Vec1.Saturate(fraction);
        this.renderFrame(bb.Min, bb.Max, style.GetColor("FrameBg"), true, style.FrameRounding);
        bb.expandXY(-style.FrameBorderSize, -style.FrameBorderSize);
        const fill_br = new Vec2(Vec1.Lerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);
        this.renderRectFilledRangeH(win.DrawList, bb, style.GetColor("PlotHistogram"),
                                0., fraction, style.FrameRounding);

        // Default displaying the fraction as percentage string, but user can override it
        if (!overlay)
            overlay = `${Math.floor(fraction*100.01)}%`;

        let overlay_size = this.CalcTextSize(overlay);
        if (overlay_size.x > 0)
        {
            let pos = new Vec2();
            pos.x = Vec1.Clamp(fill_br.x + style.ItemSpacing.x, bb.Min.x,
                                bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x),
            pos.y = bb.Min.y;
            this.renderTextClipped(pos, bb.Max, overlay, overlay_size,
                                    new Vec2(0.0,0.5), bb);
        }
    },

    getImage(url, onerror=null)
    {
        if(!this.imageCache)
            this.imageCache = {};
        let cache = this.imageCache;
        let img = cache[url];
        if(img == undefined)
        {
            img = new Image();
            cache[url] = img;
            img.addEventListener("load", function() {
                img._loaded = true;
            });
            img.addEventListener("error", function() {
                img._loaded = false;
                img._error = true;
                if(onerror)
                    onerror(url, cache);
            });
            img.src = url;
            return null;
        }
        else
        if(img._loaded)
        {
            return img;
        }
        if(img._error)
        {
            return this.getImage("img/404.png");
        }
        else
            return null;
    },

    Image(url, size, uv0=null, uv1=null, tint_col=null,
            border_col=null, bg_col = null, onError=null)
    {
        let win = this.getCurrentWindow();
        let bb = new Rect(win.DC.CursorPos,
                        Vec2.Add(win.DC.CursorPos, size));
        if (border_col != null && border_col.a > 0)
            bb.Max.AddXY(2, 2);
        this.itemSize(bb);
        if (!this.itemAdd(bb, 0))
            return;
        let img = this.getImage(url, onError);
        if(bg_col != null && bg_col.a > 0)
            win.DrawList.AddRectFilled(bb.Min, bb.Max, bg_col, 0);
        if (border_col != null && border_col.a > 0)
        {
            win.DrawList.AddRect(bb.Min, bb.Max, border_col, 0);
            if(img)
                win.DrawList.AddImage(img, bb.Expand(-1), uv0, uv1, tint_col);
        }
        else
        {
            if(img)
                win.DrawList.AddImage(img, bb, uv0, uv1, tint_col);
        }
        return img;
    },

    ImageButton(url, size, uv0=null, uv1=null, frame_padding=0,
                bg_col=null, tint_col=null, flags=0, onError=null)
    {
        let win = this.getCurrentWindow();
        if (win.SkipItems)
            return false;
        let g = this.guictx;
        const style = g.Style;

        // Default to using texture ID as ID. User can still push
        // string/integer prefixes. We could hash the size/uv to create
        // a unique ID but that would prevent the user from animating UV.
        this.PushID(url);
        const id = win.GetID("#image");
        this.PopID();

        const padding = (frame_padding >= 0) ?
                new Vec2(frame_padding, frame_padding) : style.FramePadding;
        const bb = Rect.FromXY(win.DC.CursorPos,
                        win.DC.CursorPos.x + size.x + padding.x * 2,
                        win.DC.CursorPos.y + size.y + padding.y * 2);
        const image_bb = Rect.FromXY(
                        Vec2.Add(win.DC.CursorPos, padding),
                        win.DC.CursorPos.x + padding.x + size.x,
                        win.DC.CursorPos.y + padding.y + size.y);
        this.itemSize(bb);
        if (!this.itemAdd(bb, id))
            return false;

        let hovered = new ValRef(), held = new ValRef();
        let pressed = this.ButtonBehavior(bb, id, hovered, held, flags);

        // Render
        let img = this.getImage(url, onError);
        const col = style.GetColor((held.get() && hovered.get()) ? "ButtonActive" :
                                    hovered.get() ? "ButtonHovered" : "Button");
        this.renderNavHighlight(bb, id);
        this.renderFrame(bb.Min, bb.Max, col, true,
            Vec1.Clamp(Math.min(padding.x, padding.y), 0, style.FrameRounding));
        if (bg_col && bg_col.w > 0)
            win.DrawList.AddRectFilled(image_bb.Min, image_bb.Max, bg_col);
        if(img)
            win.DrawList.AddImage(img, image_bb, uv0, uv1, tint_col);
        return pressed;
    }

}; // end mixin

// =====================================================================================================================
// widgets/button.js END
// =====================================================================================================================
// =====================================================================================================================
// widgets/scrollbar.js BEGIN
// =====================================================================================================================

// - Widgets/scrollbar() [Internal]

let sLockedScroll = {}; // indexed by window id
var ImguiScrollbarMixin =
{
    // Vertical/Horizontal scrollbar
    //
    // The entire piece of code below is rather confusing because:
    // - We handle absolute seeking (when first clicking outside the grab) and
    //   relative manipulation (afterward or when clicking inside the grab)
    // - We store values as normalized ratio and in a form that allows the
    //   window content to change while we are holding on a scrollbar
    // - We handle both horizontal and vertical scrollbars, which makes the
    //   terminology not ideal.
    scrollbar(axis)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;

        const horizontal = (axis == Axis.X);
        const style = g.Style;
        const id = this.getScrollbarID(win, axis);
        this.keepAliveID(id);

        // Render background
        let other_scrollbar = (horizontal ? win.ScrollbarY : win.ScrollbarX);
        let other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0;
        const window_rect = win.Rect();
        const border_size = win.WindowBorderSize;
        let bb = horizontal ?
                Rect.FromXY(win.Pos.x + border_size,
                            window_rect.Max.y - style.ScrollbarSize,
                            window_rect.Max.x - other_scrollbar_size_w - border_size,
                            window_rect.Max.y - border_size) :
                Rect.FromXY(window_rect.Max.x - style.ScrollbarSize,
                            win.Pos.y + border_size,
                            window_rect.Max.x - border_size,
                            window_rect.Max.y - other_scrollbar_size_w - border_size);
        if (!horizontal)
        {
            bb.Min.y += win.TitleBarHeight() +
                ((win.Flags & WindowFlags.MenuBar) ? win.MenuBarHeight() : 0.);
        }

        const bb_height = bb.GetHeight();
        if (bb.GetWidth() <= 0 || bb_height <= 0)
            return;

        // When we are too small, start hiding and disabling the grab (this
        // reduce visual noise on very small window and facilitate using the
        // resize grab)
        let alpha = 1.;
        if ((axis == Axis.Y) && bb_height < g.FontLineHeight + g.Style.FramePadding.y * 2.)
        {
            alpha = Vec1.Saturate((bb_height - g.FontLineHeight) / (g.Style.FramePadding.y * 2));
            if (alpha <= 0.) return;
        }
        const allow_interaction = (alpha >= 1.);
        let window_rounding_corners;
        if (horizontal)
        {
            window_rounding_corners = CornerFlags.BotLeft |
                                (other_scrollbar ? 0 : CornerFlags.BotRight);
        }
        else
        {
            window_rounding_corners = (((win.Flags & WindowFlags.NoTitleBar) &&
                                        !(win.Flags & WindowFlags.MenuBar)) ?
                                        CornerFlags.TopRight : 0) |
                                    (other_scrollbar ? 0 : CornerFlags.BotRight);
        }
        win.DrawList.AddRectFilled(bb.Min, bb.Max, style.GetColor("ScrollbarBg"),
                            win.WindowRounding, window_rounding_corners);
        bb.expandXY(-Vec1.Clamp(Math.floor((bb.GetWidth() - 2) * 0.5), 0, 2),
                    -Vec1.Clamp(Math.floor((bb.GetHeight() - 2) * 0.5), 0, 2));

        // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
        let scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();
        let scroll_v = horizontal ? win.Scroll.x : win.Scroll.y;
        let win_size_avail_v = (horizontal ? win.SizeFull.x : win.SizeFull.y)
                                - other_scrollbar_size_w;
        let win_size_contents_v = horizontal ? win.SizeContents.x : win.SizeContents.y;

        // Calculate the height of our grabbable box. It generally represent
        // the amount visible (vs the total scrollable amount) But we maintain
        // a minimum size in pixel to allow for the user to still aim inside.
        // Adding this assert to check if the ImMax(XXX,1.0f) is still needed.
        // PLEASE CONTACT ME if this triggers.
        console.assert(Math.max(win_size_contents_v, win_size_avail_v) > 0.);
        const win_size_v = Math.max(win_size_contents_v, win_size_avail_v, 1);
        const grab_h_pixels = Vec1.Clamp(scrollbar_size_v * (win_size_avail_v / win_size_v),
                                    style.GrabMinSize, scrollbar_size_v);
        const grab_h_norm = grab_h_pixels / scrollbar_size_v;

        // Handle input right away. None of the code of Begin() is relying on
        // scrolling position before calling Scrollbar().
        let held = new ValRef(false);
        let hovered = new ValRef(false);
        const previously_held = (g.ActiveId == id);
        this.ButtonBehavior(bb, id, hovered, held, ButtonFlags.NoNavFocus);

        let scroll_max = Math.max(1, win_size_contents_v - win_size_avail_v);
        let scroll_ratio = Vec1.Saturate(scroll_v / scroll_max);
        let grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
        if (held.get() && allow_interaction && grab_h_norm < 1)
        {
            let scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;
            let mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
            let apply, getval;
            if(horizontal)
            {
                apply = function(delta) { g.ScrollbarClickDeltaToGrabCenter.x = delta; };
                getval = function() { return g.ScrollbarClickDeltaToGrabCenter.x; };
            }
            else
            {
                apply = function(delta) { g.ScrollbarClickDeltaToGrabCenter.y = delta; };
                getval = function() { return g.ScrollbarClickDeltaToGrabCenter.y; };
            }

            // Click position in scrollbar normalized space (0.0f->1.0f)
            const clicked_v_norm = Vec1.Saturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
            this.setHoveredID(id);

            let seek_absolute = false;
            if (!previously_held)
            {
                if(win.Flags & WindowFlags.LockScrollingContentSize)
                {
                    // console.info("begin locked scroll");
                    sLockedScroll[id] = win_size_contents_v;
                }
                // On initial click calculate the distance between mouse and the
                // center of the grab
                if (clicked_v_norm >= grab_v_norm &&
                    clicked_v_norm <= grab_v_norm + grab_h_norm)
                {
                    apply(clicked_v_norm - grab_v_norm - grab_h_norm*0.5);
                }
                else
                {
                    seek_absolute = true;
                    apply(0.0);
                }
            }
            else
            if(win.Flags & WindowFlags.LockScrollingContentSize)
            {
                scroll_max = Math.max(1, sLockedScroll[id] - win_size_avail_v);
                scroll_ratio = Vec1.Saturate(scroll_v / scroll_max);
                grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
            }
            // Apply scroll
            // It is ok to modify Scroll here because we are being called in
            // Begin() after the calculation of SizeContents and before setting
            // up our starting position
            let v = (clicked_v_norm - getval() - grab_h_norm*0.5) / (1. - grab_h_norm);
            const scroll_v_norm = Vec1.Saturate(v);
            //(win_size_contents_v - win_size_v));
            scroll_v = Math.floor(0.5 + scroll_v_norm * scroll_max);
            if (horizontal)
                win.Scroll.x = scroll_v;
            else
                win.Scroll.y = scroll_v;

            // Update values for rendering
            scroll_ratio = Vec1.Saturate(scroll_v / scroll_max);
            grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

            // Update distance to grab now that we have seeked and saturated
            if (seek_absolute)
                apply(clicked_v_norm - grab_v_norm - grab_h_norm*0.5);
        }
        else
            sLockedScroll[id] = 0;

        // Render grab
        const grab_col = style.GetColor(held.get() ? "ScrollbarGrabActive" :
                                    hovered.get() ? "ScrollbarGrabHovered" :
                                    "ScrollbarGrab", alpha);
        let grab_rect = null, min;
        if (horizontal)
        {
            min = Vec1.Lerp(bb.Min.x, bb.Max.x, grab_v_norm);
            grab_rect = Rect.FromXY(
                            min, bb.Min.y,
                            Math.min(min + grab_h_pixels, window_rect.Max.x),
                            bb.Max.y);
        }
        else
        {
            min = Vec1.Lerp(bb.Min.y, bb.Max.y, grab_v_norm);
            grab_rect = Rect.FromXY(
                            bb.Min.x, min,
                            bb.Max.x,
                            Math.min(min + grab_h_pixels, window_rect.Max.y));
        }
        win.DrawList.AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col,
                                    style.ScrollbarRounding);
    },

    getScrollbarID(win, axis)
    {
        return win.GetIDNoKeepAlive(axis == Axis.X ? "#SCROLLX" : "#SCROLLY");
    }

}; // end mixin
// =====================================================================================================================
// widgets/scrollbar.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/filebrowser.js BEGIN
// =====================================================================================================================


var FileBrowserMode =
{
    PickFile: 0,
    PickDir: 1,
    SaveFile: 2,
    ViewOnly: 3
};

const ClientModes = Object.keys(FileBrowserMode);
const RecentDirs = "FileBrowser/RecentDirs"; // first in list is last sel
const DefaultIcons =
{
    RecentDirs: String.fromCodePoint(0xe88a), // material icons history
    Filter: String.fromCodePoint(0xe152), // material icons filter_list

    Clock: String.fromCodePoint(0x1f551), // https://graphemica.com/
};

var TheFileBrowser = null;

class FileBrowser
{
    // filesys is an object that implements a subset of nodejs/fs&path
    // entrypoints. It exposes path entrypoints vis filesys.path
    //
    // prefs is an optional object with methods GetValue and SetValue
    // implementation expected to persist values of type string and
    // string array
    constructor(filesys, prefs=null, icons=DefaultIcons)
    {
        if(!TheFileBrowser) TheFileBrowser = this;
        this.IsOpen = new ValRef(false);
        this.filesys = filesys;
        this.path = filesys.path;
        this.opMode = FileBrowserMode.ViewOnly;
        this.selection = "";
        this.selectionIndex = -1;
        this.selectionIndexMax = -1;
        this.clientCB = null;
        this.clientPrompt = "Select file(s)";
        this.cwd = null;
        this.cwdList = null;
        this.cwdSubdirs = null;
        this.cwdFiles = null;
        this.filter = null;
        this.nameEntry = new MutableString();
        this.mkdirEntry = new MutableString();
        this.minSize = new Vec2(200, 200);
        this.prefs = prefs;
        this.icons = icons;
        this.zIndex = -1;
        this.recentDirs = []; // whether or not we have prefs support
        this.imgui = null;
    }

    InstallFilesys(filesys)
    {
        this.filesys = filesys;
    }

    Begin(imgui)
    {
        this.imgui = imgui;
    }

    End()
    {
    }

    GetDir()
    {
        return this.cwd;
    }

    SetDir(dir) // Async
    {
        let ndir = dir.replace(/\\/g, "/"); // backslashes begone!
        let driveSpec = ndir.indexOf(":");
        if(driveSpec != -1)
        {
            // "//C:/foo/bar" | "/C:/foo/bar" -> "C:/foo/bar"
            ndir = ndir.slice(driveSpec-1);
        }
        // console.log(`SetDir ${dir} -> ${ndir}`);
        this.cwd = ndir;
        this.cwdFiles = [];
        this.cwdSubdirs = [];
        this.cwdErrEntries = [];
        this.selection = "";
        this.selectionIndex = 0;
        this.selectionType = ""; // only valid if selection is non-empty
        if(this.filter)
            this.filter.Clear();
        if(this.cwd == "/")
        {
            this.cwdList = ["/"];
            this.filesys.listVolumes(this.readDirCB.bind(this));
        }
        else
        {
            this.cwdList = this.cwd.split("/");
            if(this.cwdList[0] == "") // path started with "/"
                this.cwdList[0] = "/";
            else
                this.cwdList.unshift("/"); // insert front
            if(this.cwdList[this.cwdList.length-1] == "") // path ended with '/'
                this.cwdList.pop();
            this.cwdSubdirs.push("..");
            let opts = {withFileTypes: true};
            // D: -> D:/ to prevent confusion over per-drive cwd
            this.filesys.readdir(this.cwd+"/", opts, this.readDirCB.bind(this));
        }
    }

    // In order to support multi and single-select,
    // client is expected to manually close via IsOpen.set(false)
    SetClient(prompt, cb, mode, ext, doopen=true, zIndex=-1)
    {
        if(typeof(mode) == "string")
            mode = ClientModes.indexOf(mode);
        this.opMode = mode;
        this.clientCB = cb;
        this.clientPrompt = prompt ? prompt : "View files(s)";
        this.clientExtensions = ext;
        this.zIndex = zIndex;
        if(doopen)
        {
            this.IsOpen.set(true);
            // need to refresh here in case file system has changed
            if(this.cwd)
                this.SetDir(this.cwd);
        }
    }

    GetSelection(asRelative=true)
    {
        let str = (this.opMode == FileBrowserMode.SaveFile) ?
                        this.nameEntry.toString() : this.selection;
        if(asRelative)
            return str;
        else
            return this.path.join(this.cwd, str).replace(/\\/g, "/"); // backslashes begone!
    }

    Show(imgui)
    {
        const topButtons = true;
        if(!this.IsOpen.get())
        {
            this.clientCB = null; // safety for close-button cancelation
            return;
        }

        if(!this.filter)
            this.filter = new TextFilter(imgui);
        const fontSize = imgui.GetFontSize();

        imgui.SetNextWindowPos(new Vec2(10, 10), CondFlags.FirstUseEver);
        imgui.SetNextWindowSize(new Vec2(400, 300), CondFlags.FirstUseEver); // XXX: add clientPrompt
        if(this.zIndex != -1)
            imgui.SetNextWindowZIndex(this.zIndex);

        let title = this.clientPrompt + "##File Browser";
        if (!imgui.Begin(title, this.IsOpen, WindowFlags.NoCollapse
             /* |WindowFlags.AlwaysAutoResize*/))
        {
            imgui.End();
            return;
        }

        let recentDirs = this.prefs ? this.prefs.GetValue(RecentDirs, []) : this.recentDirs;
        if(this.cwd == null)
        {
            let firstDir;
            if(recentDirs.length)
                firstDir = recentDirs[0];
            else
                firstDir = "/";
            this.SetDir(firstDir); // async...
            imgui.End();
            return;
        }

        // Recent locations
        const pnm = "RecentDirMenu";
        if(imgui.SmallButton(this.icons.Clock)) // IconButtonAlt("Recent", this.icons.RecentDirs))
            imgui.OpenPopup(pnm);
        if(imgui.BeginPopup(pnm))
        {
            for(let d of recentDirs)
            {
                if(imgui.MenuItem(d, false))
                    this.SetDir(d);
            }
            imgui.EndPopup();
        }
        imgui.SameLine();

        // show current path as buttons
        let lastX2 = 0;
        let winMax = imgui.GetWindowPos().x +
                     imgui.GetWindowContentRegionMax().x;
        if(this.cwdList.length == 0)
        {
            if(imgui.SmallButton("/")) // windows root dir
                this.SetDir("/"); // Async
        }
        else
        for (let i=0; i<this.cwdList.length; i++)
        {
            if(i > 0 && (winMax-lastX2) > 50)
                imgui.SameLine();
            if (imgui.SmallButton(this.cwdList[i]))
            {
                // button was clicked, so we need to rescan
                let subset = this.cwdList.slice(0, i+1);
                let newpath = subset.join("/"); // ["/", "C:"] -> "//C:"
                if(newpath.indexOf("//") == 0)
                    newpath = newpath.slice(1);
                this.SetDir(newpath); // Async
            }
            lastX2 = imgui.GetItemRectMax().x;
        }

        // new line
        imgui.Text("Filter");
        imgui.SameLine();
        this.filter.Draw("", 5*fontSize);
        if(topButtons)
        {
            imgui.SameLine();
            this.showButtons(imgui, fontSize);
        }

        if(this.checkShortcuts(imgui, "header"))
        {
            // eg: escape key always closes
            this.doClose();
            imgui.End();
            return;
        }

        imgui.Separator();

        let xsize = imgui.GetWindowContentRegionMax().x;
        let ysize = imgui.GetWindowContentRegionMax().y - imgui.GetCursorPosY();
        if(!topButtons)
            ysize -= (imgui.GetFrameHeight() - 10);
        imgui.BeginChild("##FileDialog_FileList", new Vec2(xsize, ysize));
        if(this.checkShortcuts(imgui, "filelist"))
        {
            // eg: escape key always closes
            imgui.EndChild();
            this.doClose();
            imgui.End();
            return;
        }

        // first list dirs (selection is navigation) ---------------------
        imgui.PushStyleColor("Text", imgui.GetStyleColor("FBDir"));
        for (let i=0;i<this.cwdSubdirs.length;i++)
        {
            let p = this.cwdSubdirs[i];
            if(this.filter.IsActive() && !this.filter.PassFilter(p))
                continue;
            if(p == ".") continue; // may not happen
            if (imgui.Selectable(p+"/", p == this.selection,
                SelectableFlags.AllowDoubleClick))
            {
                this.selection = p;
                this.selectionIndex = i;
                this.updateSelection();
                if(imgui.IsMouseDoubleClicked([0]) ||
                    this.opMode != FileBrowserMode.OpenDir)
                {
                    this.performAction();
                }
            }
        }
        imgui.PopStyleColor();
        if (this.opMode == FileBrowserMode.SaveFile && this.cwd != "/")
        {
            let id = "Create Folder";
            imgui.PushStyleColor("Text", imgui.GetStyleColor("FBMkDir"));
            if(imgui.Selectable("New folder...", false))
            {
                imgui.OpenPopup(id);
                this.selectionType == "newfolder";
                this.mkdirEntry.Set("");
            }
            imgui.PopStyleColor();
            if(imgui.BeginPopup(id))
            {
                imgui.Text("New Folder:"); imgui.SameLine();
                if(imgui.InputText("##newfolder", this.mkdirEntry,
                    InputTextFlags.EnterReturnsTrue))
                {
                    let dir = this.path.join(this.cwd, this.mkdirEntry.toString());
                    console.info("creating " + this.mkdirEntry.toString());
                    this.filesys.mkdir(dir, {recursive: true}, (err)=>
                    {
                        if(err)
                        {
                            console.error(err);
                            return;
                        }
                        this.mkdirEntry.Set("");
                        imgui.FocusWindow(null); // to dismiss popup
                        this.SetDir(this.cwd);
                    });
                }
                imgui.EndPopup();
            }
        }

        // next list files ---------------------
        imgui.PushStyleColor("Text", imgui.GetStyleColor("FBFile"));
        for (let i=0;i<this.cwdFiles.length;i++)
        {
            let p = this.cwdFiles[i];
            if(this.filter.IsActive() && !this.filter.PassFilter(p))
                continue;
            if (imgui.Selectable(p, p == this.selection,
                SelectableFlags.AllowDoubleClick))
            {
                this.selection = p;
                this.selectionIndex = i + this.cwdSubdirs.length;
                this.updateSelection();
                if(imgui.IsMouseDoubleClicked([0]))
                    this.performAction();
            }
            if(imgui.BeginPopupContextItem("##file"+i))
            {
                if(imgui.Selectable("delete " + p + "?"))
                {
                    let fp = this.path.join(this.cwd, p);
                    console.info("deleting " + fp);
                    this.filesys.unlink(fp, (err) => {
                        if(err)
                            console.error(err);
                        else
                            console.info(fp + " deleted");
                        this.SetDir(this.cwd);
                    });
                }
                imgui.EndPopup();
            }
        }
        this.selectionIndexMax = this.cwdSubdirs.length + this.cwdFiles.length - 1;
        imgui.PopStyleColor();
        imgui.EndChild();
        if(!topButtons)
        {
            imgui.Separator();
            this.showButtons(imgui, fontSize);
        }
        imgui.End();
    }

    disableSelection()
    {
        return this.selection.length == 0 ||
               (this.opMode == FileBrowserMode.PickFile &&
                this.selectionType != "file") ||
               (this.opMode == FileBrowserMode.PickDir &&
                this.selectionType != "dir");
    }

    performAction() // where is null when mouse performs op
    {
        switch(this.selectionType)
        {
        case "dir":
            if(this.opMode == FileBrowserMode.PickDir)
                this.performSelection();
            else
            if(this.selection == "..")
            {
                if(/^[a-zA-Z]:[/]?$/.test(this.cwd))  // C: and C:/
                    this.SetDir("/");
                else
                    this.SetDir(this.path.dirname(this.cwd)); // Async
            }
            else
            {
                let np = this.path.join(this.cwd, this.selection);
                np = this.path.normalize(np);
                this.SetDir(np); // Async
            }
            break;
        case "file":
            if(this.opMode == FileBrowserMode.PickFile)
                this.performSelection();
            break;
        case "newfolder":
            break;
        }
    }

    performSelection() // works to select file or dir
    {
        let path = this.GetSelection(false/*abs*/);
        this.updateRecentDirs();
        if(this.clientCB)
            this.clientCB(0, path);
        else
            console.notice("would have selected:" + path);
    }

    showButtons(imgui)
    {
        //let maxwidth = imgui.GetContentRegionAvailWidth();
        let disable = this.disableSelection();
        switch(this.opMode)
        {
        case FileBrowserMode.PickFile:
        case FileBrowserMode.PickDir:
        default:
            if(disable)
            {
                imgui.PushItemFlag(ItemFlags.Disabled);
                imgui.PushStyleVar("Alpha", .5);
            }
            if(imgui.Button("Select"))
            {
                this.performSelection();
            }
            if(disable)
            {
                imgui.PopItemFlag();
                imgui.PopStyleVar();
            }
            imgui.SameLine();
            imgui.Text(this.selection);
            break;
        case FileBrowserMode.SaveFile:
            imgui.InputText("##FileName", this.nameEntry);
            imgui.SameLine();
            if(this.nameEntry.Length() == 0)
            {
                imgui.PushItemFlag(ItemFlags.Disabled);
                imgui.PushStyleVar("Alpha", .5);
            }
            if(imgui.Button("Save"))
            {
                this.performSelection();
            }
            if(this.nameEntry.Length() == 0)
            {
                imgui.PopItemFlag();
                imgui.PopStyleVar();
            }
            break;
        }
    }

    updateRecentDirs()
    {
        if(!this.prefs) return;
        let recentDirs = this.prefs ? this.prefs.GetValue(RecentDirs, []) : this.recentDirs;
        // ensure only one instance of cwd in recentDirs
        let idx = recentDirs.indexOf(this.cwd);
        if(idx != 0)
        {
            if(idx != -1)
                recentDirs.splice(idx,1);
            recentDirs.unshift(this.cwd); // aka push_front
            if(this.prefs)
                this.prefs.SetValue(RecentDirs, recentDirs.slice(0, 15));
        }
        this.recentDirs = recentDirs; // used in the non-prefs case
    }

    // XXX: it's possible that our child window is the "navwindow"
    // and this
    checkShortcuts(imgui)
    {
        if(!imgui.IsWindowFocused()) // don't consume if nav isn't
            return false;

        // When focused we consume all input.
        let io = imgui.guictx.IO;
        for (let n=0; n<io.InputKeyEvents.length; n++)
        {
            let evt = io.InputKeyEvents[n];
            switch(evt.key)
            {
            case "ArrowUp":
                if(this.selectionIndex>0)
                {
                    this.selectionIndex--;
                    this.updateSelection();
                }
                else
                    this.selectionIndex = 0;
                break;
            case "ArrowDown":
                if(this.selectionIndex<this.selectionIndexMax)
                {
                    this.selectionIndex++;
                    this.updateSelection();
                }
                break;
            case "Escape":
                return true;
            case "Return":
            case "Enter":
                // should return ever trigger selection/close?
                // when in file-select mode, return on a dir
                // should open that dir
                this.performAction();
                break;
            default:
                // console.log(evt.key, imgui.IsItemFocused());
                // save-as typein?
                break;
            }
        }
    }

    updateSelection()
    {
        if(this.selectionIndex >= 0 && this.selectionIndex <= this.selectionIndexMax)
        {
            if(this.selectionIndex < this.cwdSubdirs.length)
            {
                this.selection = this.cwdSubdirs[this.selectionIndex];
                this.selectionType = "dir";
            }
            else
            {
                this.selection = this.cwdFiles[this.selectionIndex-this.cwdSubdirs.length];
                this.selectionType = "file";
                if(this.opMode == FileBrowserMode.SaveFile)
                    this.nameEntry.Set(this.selection);
            }
        }
    }

    doClose()
    {
        // reset prompt, callback, etc
        if(this.clientCB)
            this.clientCB(0, null); // not an error, but a nullfile
        this.IsOpen.set(false);
    }

    readDirCB(err, flist)
    {
        if(err)
        {
            console.error(err);
            return;
        }
        // bad to sort flist here, since stat is async
        let nfiles = 0;
        for(let i=0; i<flist.length; i++)
        {
            // Warning: BrowserFS doesn't support opts, and DirEnt
            //  so we currently make a slew of stat calls
            let f = flist[i];
            let fpath;
            if(this.cwd == "/" && this.path.sep == "\\")
                fpath = f; // cuz this.path.join("/", "C:") is bad
            else
                fpath = this.path.join(this.cwd, f);
            this.filesys.stat(fpath, (err, stats) => {
                if(err)
                    this.cwdErrEntries.push(f);
                else
                if(stats.isDirectory())
                    this.cwdSubdirs.push(f);
                else
                if(stats.isFile())
                    this.cwdFiles.push(f);
                else
                    console.debug("skipping " + f); // (links, specical files)
                nfiles++;
                if(nfiles == flist.length-1)
                {
                    // ".." sorts to top for my locale
                    this.cwdSubdirs.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
                    this.cwdFiles.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
                    this.selectionIndex = 0;
                    this.selectionType = "dir";
                    this.selection = this.cwdSubdirs[0];
                }
            });
        }
    }
}


// =====================================================================================================================
// panels/filebrowser.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/demoLayout.js BEGIN
// =====================================================================================================================


class DemoLayout
{
    constructor(imgui)
    {
        this.imgui = imgui;
    }

    Show()
    {
        let imgui = this.imgui;
        if (!imgui.CollapsingHeader("Layout"))
            return;

        if (imgui.TreeNode("Child windows"))
        {
            imgui.Tooltip("Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window.");
            if(this.CW_disable_mouse_wheel == undefined)
            {
                this.CW_disable_mouse_wheel = false;
                this.CW_disable_menu = false;
                this.CW_line = 50;
            }
            if(imgui.Checkbox("Disable Mouse Wheel", this.CW_disable_mouse_wheel))
                this.CW_disable_mouse_wheel ^= 1;
            if(imgui.Checkbox("Disable Menu", this.CW_disable_menu))
                this.CW_disable_menu ^= 1;

            let goto_line = imgui.Button("Goto");
            imgui.SameLine();
            imgui.SetNextItemWidth(100);
            goto_line |= imgui.InputInt("##Line", this.CW_line, 0, 0,
                                    InputTextFlags.EnterReturnsTrue,
                                    (newval)=>this.CW_line = newval);

            // Child 1: no border, enable horizontal scrollbar
            let window_flags = WindowFlags.HorizontalScrollbar |
                    (this.CW_disable_mouse_wheel ? WindowFlags.NoScrollWithMouse : 0);
            imgui.BeginChild("Child1", new Vec2(imgui.GetWindowContentRegionWidth() * 0.5, 260),
                            false, window_flags);
            for (let i=0; i < 100; i++)
            {
                imgui.Text("%4d: scrollable region", i);
                if (goto_line && this.CW_line == i)
                    imgui.SetScrollHereY();
            }
            if (goto_line && this.CW_line >= 100)
                imgui.SetScrollHereY();
            imgui.EndChild();

            imgui.SameLine();

            // Child 2: rounded border
            window_flags = (this.CW_disable_mouse_wheel ? WindowFlags.NoScrollWithMouse : 0) |
                            (this.CW_disable_menu ? 0 : WindowFlags.MenuBar);
            imgui.PushStyleVar("ChildRounding", 5);
            imgui.BeginChild("Child2", new Vec2(0, 260), true, window_flags);
            if (!this.CW_disable_menu && imgui.BeginMenuBar())
            {
                if (imgui.BeginMenu("Menu"))
                {
                    ExampleFileMenu(imgui);
                    imgui.EndMenu();
                }
                imgui.EndMenuBar();
            }
            imgui.Columns(2);
            for (let i = 0; i < 100; i++)
            {
                imgui.Button(("000"+i).slice(-3), new Vec2(-1., 0.));
                imgui.NextColumn();
            }
            imgui.EndChild();
            imgui.PopStyleVar();

            imgui.Separator();

            // Demonstrate a few extra things
            // - Changing ChildBg (which is transparent black in default styles)
            // - Using SetCursorPos() to position the child window (because
            //   the child window is an item from the POV of the parent window)
            //   You can also call SetNextWindowPos() to position the child
            //   window. The parent window will effectively layout from this
            //   position.
            // - Using imgui.GetItemRectMin/Max() to query the "item" state
            //   (because the child window is an item from the POV of the parent
            //   window) See "Widgets" -> "Querying Status (Active/Focused/Hovered
            //   etc.)" section for more details about this.
            imgui.SetCursorPosX(50);
            imgui.PushStyleColor("ChildBg", Color.rgbai(255, 0, 0, 100));
            imgui.BeginChild("blah", new Vec2(200, 100), true, WindowFlags.None);
            for (let n = 0; n < 50; n++)
                imgui.Text("Some test %d", n);
            imgui.EndChild();
            let child_rect_min = imgui.GetItemRectMin();
            let child_rect_max = imgui.GetItemRectMax();
            imgui.PopStyleColor();
            imgui.Text("Rect of child window is: (%d,%d) (%d,%d)",
                child_rect_min.x, child_rect_min.y,
                child_rect_max.x, child_rect_max.y);

            imgui.TreePop();
        }
        if (imgui.TreeNode("Widgets Width"))
        {
            // Use SetNextItemWidth() to set the width of a single upcoming item.
            // Use PushItemWidth()/PopItemWidth() to set the width of a group of items.
            if(this.WW_f == undefined)
                this.WW_f = 0;
            imgui.Text("SetNextItemWidth/PushItemWidth(100)");
            imgui.SameLine();
            imgui.Tooltip("Fixed width.");
            imgui.SetNextItemWidth(100);
            imgui.DragFloat("float##1",
                this.WW_f, 1, 0, 0, null, 1, (newval) => this.WW_f = newval);

            imgui.Text("SetNextItemWidth/PushItemWidth(GetWindowWidth() * 0.5f)");
            imgui.SameLine();
            imgui.Tooltip("Half of window width.");
            imgui.SetNextItemWidth(imgui.GetWindowWidth() * 0.5);
            imgui.DragFloat("float##2",
                this.WW_f, 1, 0, 0, null, 1, (newval) => this.WW_f = newval);

            imgui.Text("SetNextItemWidth/PushItemWidth(GetContentRegionAvailWidth() * 0.5f)");
            imgui.SameLine();
            imgui.Tooltip("Half of available width.\n(~ right-cursor_pos)\n(works within a column set)");
            imgui.SetNextItemWidth(imgui.GetContentRegionAvailWidth() * 0.5);
            imgui.DragFloat("float##3",
                this.WW_f, 1, 0, 0, null, 1, (newval) => this.WW_f = newval);

            imgui.Text("SetNextItemWidth/PushItemWidth(-100)");
            imgui.SameLine();
            imgui.Tooltip("Align to right edge minus 100");
            imgui.SetNextItemWidth(-100);
            imgui.DragFloat("float##4",
                this.WW_f, 1, 0, 0, null, 1, (newval) => this.WW_f = newval);

            // Demonstrate using PushItemWidth to surround three items.
            // Calling SetNextItemWidth() before each of them would have
            // the same effect.
            imgui.Text("SetNextItemWidth/PushItemWidth(-1)");
            imgui.SameLine();
            imgui.Tooltip("Align to right edge");
            imgui.PushItemWidth(-1);
            imgui.DragFloat("float##5a",
                this.WW_f, 1, 0, 0, null, 1, (newval) => this.WW_f = newval);
            imgui.DragFloat("float##5b",
                this.WW_f, 1, 0, 0, null, 1, (newval) => this.WW_f = newval);
            imgui.DragFloat("float##5c",
                this.WW_f, 1, 0, 0, null, 1, (newval) => this.WW_f = newval);
            imgui.PopItemWidth();

            imgui.TreePop();
        }

        if (imgui.TreeNode("Basic Horizontal Layout"))
        {
            imgui.TextWrapped("(Use imgui.SameLine() to keep adding items to the right of the preceding item)");

            // Text
            imgui.Text("Two items: Hello");
            imgui.SameLine();
            imgui.TextColored(Color.rgba(1,1,0,1), "Sailor");

            // Adjust spacing
            imgui.Text("More spacing: Hello");
            imgui.SameLine(0, 20);
            imgui.TextColored(Color.rgba(1,1,0,1), "Sailor");

            // Button
            imgui.AlignTextToFramePadding();
            imgui.Text("Normal buttons");
            imgui.SameLine();
            imgui.Button("Banana");
            imgui.SameLine();
            imgui.Button("Apple");
            imgui.SameLine();
            imgui.Button("Corniflower");

            // Button
            imgui.Text("Small buttons");
            imgui.SameLine();
            imgui.SmallButton("Like this one");
            imgui.SameLine();
            imgui.Text("can fit within a text block.");

            // Aligned to arbitrary position. Easy/cheap column.
            imgui.Text("Aligned");
            imgui.SameLine(150);
            imgui.Text("x=150");
            imgui.SameLine(300);
            imgui.Text("x=300");
            imgui.Text("Aligned");
            imgui.SameLine(150);
            imgui.SmallButton("x=150");
            imgui.SameLine(300);
            imgui.SmallButton("x=300");

            // Checkbox
            if(this.HL_c1 == undefined)
            {
                this.HL_c1 = false;
                this.HL_c2 = false;
                this.HL_c3 = false;
                this.HL_c4 = false;
            }
            if(imgui.Checkbox("My", this.HL_c1))
                this.HL_c1 ^= 1;
            imgui.SameLine();
            if(imgui.Checkbox("Tailor", this.HL_c2))
                this.HL_c2 ^= 1;
            imgui.SameLine();
            if(imgui.Checkbox("Is", this.HL_c3))
                this.HL_c3 ^= 1;
            imgui.SameLine();
            if(imgui.Checkbox("Rich", this.HL_c4))
                this.HL_c4 ^= 1;

            // Various
            if(this.HL_f0 == undefined)
            {
                this.HL_f0 = 1.;
                this.HL_f1 = 2;
                this.HL_f2 = 3.;
                this.HL_items = [ "AAAA", "BBBB", "CCCC", "DDDD" ];
                this.HL_item = -1;
                this.HL_selection = [0, 1, 2, 3];
            }
            imgui.PushItemWidth(80);
            imgui.Combo("Combo", this.HL_item, this.HL_items,
                        (newval) => this.HL_item = newval);
            imgui.SameLine();
            imgui.SliderFloat("X", this.HL_f0,
                        0.0, 5.0, null, 1, (newval) => this.HL_f0 = newval);
            imgui.SameLine();
            imgui.SliderFloat("Y", this.HL_f1,
                        0.0, 5.0, null, 1, (newval) => this.HL_f1 = newval);
            imgui.SameLine();
            imgui.SliderFloat("Z", this.HL_f2,
                        0.0, 5.0, null, 1, (newval) => this.HL_f2 = newval);
            imgui.PopItemWidth();

            imgui.PushItemWidth(80);
            imgui.Text("Lists:");
            for (let i = 0; i < 4; i++)
            {
                if (i > 0) imgui.SameLine();
                imgui.PushID(i);
                imgui.ListBox("", this.HL_selection[i], this.HL_items);
                imgui.PopID();
                //if (imgui.IsItemHovered())
                    //imgui.SetTooltip("ListBox %d hovered", i);
            }
            imgui.PopItemWidth();

            // Dummy
            let button_sz = new Vec2(40, 40);
            imgui.Button("A", button_sz);
            imgui.SameLine();
            imgui.Dummy(button_sz);
            imgui.SameLine();
            imgui.Button("B", button_sz);

            // Manually wrapping (we should eventually provide this as an automatic layout feature, but for now you can do it manually)
            imgui.Text("Manually wrapping:");
            let style = imgui.GetStyle();
            let buttons_count = 20;
            let window_visible_x2 = imgui.GetWindowPos().x +
                                    imgui.GetWindowContentRegionMax().x;
            for (let n = 0; n < buttons_count; n++)
            {
                imgui.PushID(n);
                imgui.Button("Box", button_sz);
                let last_button_x2 = imgui.GetItemRectMax().x;
                let next_button_x2 = last_button_x2 + style.ItemSpacing.x + button_sz.x; // Expected position if next button was on same line
                if (n + 1 < buttons_count && next_button_x2 < window_visible_x2)
                    imgui.SameLine();
                imgui.PopID();
            }

            imgui.TreePop();
        }

        if (imgui.TreeNode("Tabs"))
        {
            if (imgui.TreeNode("Basic"))
            {
                let tab_bar_flags = TabBarFlags.None;
                if (imgui.BeginTabBar("MyTabBar", tab_bar_flags))
                {
                    if (imgui.BeginTabItem("Avocado"))
                    {
                        imgui.Text("This is the Avocado tab!\nblah blah blah blah blah");
                        imgui.EndTabItem();
                    }
                    if (imgui.BeginTabItem("Broccoli"))
                    {
                        imgui.Text("This is the Broccoli tab!\nblah blah blah blah blah");
                        imgui.EndTabItem();
                    }
                    if (imgui.BeginTabItem("Cucumber"))
                    {
                        imgui.Text("This is the Cucumber tab!\nblah blah blah blah blah");
                        imgui.EndTabItem();
                    }
                    imgui.EndTabBar();
                }
                imgui.Separator();
                imgui.TreePop();
            }

            if (imgui.TreeNode("Advanced & Close Button"))
            {
                // Expose a couple of the available flags. In most cases you
                // may just call BeginTabBar() with no flags (0).
                if(this.T_tab_bar_flags == undefined)
                    this.T_tab_bar_flags = TabBarFlags.Reorderable;
                imgui.CheckboxFlags("TabBarFlags.Reorderable",
                        this.T_tab_bar_flags, TabBarFlags.Reorderable,
                        (newval)=>this.T_tab_bar_flags = newval);
                imgui.CheckboxFlags("TabBarFlags.AutoSelectNewTabs",
                        this.T_tab_bar_flags, TabBarFlags.AutoSelectNewTabs,
                        (newval)=>this.T_tab_bar_flags = newval);
                imgui.CheckboxFlags("TabBarFlags.TabListPopupButton",
                        this.T_tab_bar_flags, TabBarFlags.TabListPopupButton,
                        (newval)=>this.T_tab_bar_flags = newval);
                imgui.CheckboxFlags("TabBarFlags.NoCloseWithMiddleMouseButton",
                        this.T_tab_bar_flags, TabBarFlags.NoCloseWithMiddleMouseButton,
                        (newval)=>this.T_tab_bar_flags = newval);

                // make sure we have a fitting policy (Scroll vs Resize)
                if ((this.T_tab_bar_flags & TabBarFlags.FittingPolicyMask_) == 0)
                    this.T_tab_bar_flags |= TabBarFlags.FittingPolicyDefault_;

                if(imgui.CheckboxFlags("TabBarFlags.FittingPolicyResizeDown",
                    this.T_tab_bar_flags, TabBarFlags.FittingPolicyResizeDown,
                    (newval) => this.T_tab_bar_flags = newval))
                {
                    // make sure scroll is not enabled
                    this.T_tab_bar_flags &=
                        ~(TabBarFlags.FittingPolicyMask_ ^ TabBarFlags.FittingPolicyResizeDown);
                }
                if(imgui.CheckboxFlags("TabBarFlags.FittingPolicyScroll",
                    this.T_tab_bar_flags, TabBarFlags.FittingPolicyScroll,
                    (newval) => this.T_tab_bar_flags = newval))
                {
                    // make sure resize down is not enabled
                    this.T_tab_bar_flags &=
                        ~(TabBarFlags.FittingPolicyMask_ ^ TabBarFlags.FittingPolicyScroll);
                }

                // Tab Bar
                if(this.T_names == undefined)
                {
                    // Persistent user state
                    this.T_names = [ "Artichoke", "Beetroot", "Celery", "Daikon" ];
                    this.T_opened = [ new ValRef(true), new ValRef(true),
                                      new ValRef(true), new ValRef(true) ];
                }
                for (let n = 0; n < this.T_opened.length; n++)
                {
                    if (n > 0) { imgui.SameLine(); }
                    imgui.Checkbox(this.T_names[n], this.T_opened[n]);
                }

                // Passing a bool* to BeginTabItem() is similar to passing one
                // to Begin(): the underlying bool will be set to false when
                // the tab is closed.
                if (imgui.BeginTabBar("MyTabBar", this.T_tab_bar_flags))
                {
                    for (let n = 0; n < this.T_opened.length; n++)
                    {
                        if (this.T_opened[n].get() &&
                            imgui.BeginTabItem(this.T_names[n], this.T_opened[n]))
                        {
                            imgui.Text("This is the %s tab!", this.T_names[n]);
                            if (n & 1)
                                imgui.Text("I am an odd tab.");
                            imgui.EndTabItem();
                        }
                    }
                    imgui.EndTabBar();
                }
                imgui.Separator();
                imgui.TreePop();
            }
            imgui.TreePop();
        }

        if (imgui.TreeNode("Groups"))
        {
            imgui.Tooltip("Using imgui.BeginGroup()/EndGroup() to layout items. BeginGroup() basically locks the horizontal position. EndGroup() bundles the whole group so that you can use functions such as IsItemHovered() on it.");
            imgui.BeginGroup();
            {
                imgui.BeginGroup();
                imgui.Button("AAA");
                imgui.SameLine();
                imgui.Button("BBB");
                imgui.SameLine();
                imgui.BeginGroup();
                imgui.Button("CCC");
                imgui.Button("DDD");
                imgui.EndGroup();
                imgui.SameLine();
                imgui.Button("EEE");
                imgui.EndGroup();
                if (imgui.IsItemHovered())
                    imgui.SetTooltip("First group hovered");
            }
            // Capture the group size and create widgets using the same size
            if(this.G_values == undefined)
            {
                this.G_values = [ 0.5, 0.20, 0.80, 0.60, 0.25];
            }
            let size = imgui.GetItemRectSize();
            let bwidth = (size.x - imgui.GetStyle().ItemSpacing.x)*0.5;
            imgui.PlotHistogram("##values", this.G_values, 0, null, 0., 1., size);

            imgui.Button("ACTION", new Vec2(bwidth, size.y));
            imgui.SameLine();
            imgui.Button("REACTION", new Vec2(bwidth, size.y));
            imgui.EndGroup();
            imgui.SameLine();

            imgui.Button("LEVERAGE\nBUZZWORD", size);
            imgui.SameLine();

            if (imgui.ListBoxHeader("List", size))
            {
                imgui.Selectable("Selected", true);
                imgui.Selectable("Not Selected", false);
                imgui.ListBoxFooter();
            }

            imgui.TreePop();
        }

        if (imgui.TreeNode("Text Baseline Alignment"))
        {
            imgui.Tooltip("This is testing the vertical alignment that gets applied on text to keep it aligned with widgets. Lines only composed of text or \"small\" widgets fit in less vertical spaces than lines with normal widgets.");

            imgui.Text("One\nTwo\nThree"); imgui.SameLine();
            imgui.Text("Hello\nWorld"); imgui.SameLine();
            imgui.Text("Banana");

            imgui.Text("Banana"); imgui.SameLine();
            imgui.Text("Hello\nWorld"); imgui.SameLine();
            imgui.Text("One\nTwo\nThree");

            imgui.Button("HOP##1"); imgui.SameLine();
            imgui.Text("Banana"); imgui.SameLine();
            imgui.Text("Hello\nWorld"); imgui.SameLine();
            imgui.Text("Banana");

            imgui.Button("HOP##2"); imgui.SameLine();
            imgui.Text("Hello\nWorld"); imgui.SameLine();
            imgui.Text("Banana");

            imgui.Button("TEST##1"); imgui.SameLine();
            imgui.Text("TEST"); imgui.SameLine();
            imgui.SmallButton("TEST##2");

            imgui.AlignTextToFramePadding(); // If your line starts with text, call this to align it to upcoming widgets.
            imgui.Text("Text aligned to Widget"); imgui.SameLine();
            imgui.Button("Widget##1"); imgui.SameLine();
            imgui.Text("Widget"); imgui.SameLine();
            imgui.SmallButton("Widget##2"); imgui.SameLine();
            imgui.Button("Widget##3");

            // Tree
            const spacing = imgui.GetStyle().ItemInnerSpacing.x;
            imgui.Button("Button##1");
            imgui.SameLine(0, spacing);
            if (imgui.TreeNode("Node##1"))
            {
                // Dummy tree data
                for (let i = 0; i < 6; i++)
                    imgui.BulletText("Item %d..", i);
                imgui.TreePop();
            }

            imgui.AlignTextToFramePadding();
                // Vertically align text node a bit lower so it'll be
                // vertically centered with upcoming widget. Otherwise you
                // can use SmallButton (smaller fit).
            let node_open = imgui.TreeNode("Node##2");
                // Common mistake to avoid: if we want to SameLine after
                // TreeNode we need to do it before we add child content.
            imgui.SameLine(0, spacing);
            imgui.Button("Button##2");
            if (node_open)
            {
               // Dummy tree data
                for (let i = 0; i < 6; i++)
                    imgui.BulletText("Item %d..", i);
                imgui.TreePop();
            }

            // Bullet
            imgui.Button("Button##3");
            imgui.SameLine(0, spacing);
            imgui.BulletText("Bullet text");

            imgui.AlignTextToFramePadding();
            imgui.BulletText("Node");
            imgui.SameLine(0, spacing);
            imgui.Button("Button##4");

            imgui.TreePop();
        }

        if (imgui.TreeNode("Scrolling"))
        {
            imgui.Tooltip("Use SetScrollHereY() or SetScrollFromPosY() to scroll to a given position.");

            if(this.S_track == undefined)
            {
                this.S_track = true;
                this.S_track_line = 50;
                this.S_scroll_to_px = 200;
            }

            if(imgui.Checkbox("Track", this.S_track))
                this.S_track ^= 1;
            imgui.PushItemWidth(100);
            imgui.SameLine(130);
            this.S_track |= imgui.DragInt("##line", this.S_track_line, 0.25, 0, 99,
                                "Line = %d", (newval)=>this.S_track_line = newval);
            let scroll_to = imgui.Button("Scroll To Pos");
            imgui.SameLine(130);
            scroll_to |= imgui.DragInt("##pos_y", this.S_scroll_to_px, 1., 0, 9999,
                                "Y = %d px", (newval)=>this.S_scroll_to_px=newval);
            imgui.PopItemWidth();
            if (scroll_to)
                this.S_track = false;

            for (let i = 0; i < 5; i++)
            {
                if (i > 0)
                    imgui.SameLine();
                imgui.BeginGroup();
                imgui.Text("%s", ["Top", "25%", "Center", "75%", "Bottom"][i]);
                imgui.BeginChild(`chd${i}`,
                        new Vec2(imgui.GetWindowWidth() * 0.17, 200),
                        true);
                if (scroll_to)
                {
                    imgui.SetScrollFromPosY(
                            imgui.GetCursorStartPos().y + this.S_scroll_to_px,
                            i * 0.25);
                }
                for (let line = 0; line < 100; line++)
                {
                    if (this.S_track && line == this.S_track_line)
                    {
                        imgui.TextColored(Colors.yellow, "Line %d", line);
                        imgui.SetScrollHereY(i * 0.25);
                        // 0.0f:top, 0.5f:center, 1.0f:bottom
                    }
                    else
                    {
                        imgui.Text("Line %d", line);
                    }
                }
                let scroll_y = imgui.GetScrollY(), scroll_max_y = imgui.GetScrollMaxY();
                imgui.EndChild();
                imgui.Text("%d/%d", scroll_y, scroll_max_y);
                imgui.EndGroup();
            }
            imgui.TreePop();
        }

        if (imgui.TreeNode("Horizontal Scrolling"))
        {
            imgui.Tooltip("Horizontal scrolling for a window has to be enabled explicitly via the WindowFlags.HorizontalScrollbar flag.\n\nYou may want to explicitly specify content width by calling SetNextWindowContentWidth() before Begin().");
            if(this.H_lines == undefined)
                this.H_lines = 7;
            imgui.SliderInt("Lines", this.H_lines, 1, 15, null,
                            (newval)=>this.H_lines=newval);
            imgui.PushStyleVar("FrameRounding", 3);
            imgui.PushStyleVar("FramePadding", new Vec2(2, 1));
            imgui.BeginChild("scrolling",
                new Vec2(0, imgui.GetFrameHeightWithSpacing() * 7 + 30),
                true, WindowFlags.HorizontalScrollbar);
            for (let line = 0; line < this.H_lines; line++)
            {
                // Display random stuff (for the sake of this trivial demo we are using basic Button+SameLine. If you want to create your own time line for a real application you may be better off
                // manipulating the cursor position yourself, aka using SetCursorPos/SetCursorScreenPos to position the widgets yourself. You may also want to use the lower-level ImDrawList API)
                let num_buttons = 10 + ((line & 1) ? line * 9 : line * 3);
                for (let n = 0; n < num_buttons; n++)
                {
                    if (n > 0) imgui.SameLine();
                    imgui.PushID("b"+(n + line * 1000));
                    let label = (!(n%15)) ? "FizzBuzz" :
                                (!(n%3)) ? "Fizz" :
                                (!(n%5)) ? "Buzz" :
                                n.toString();
                    let hue = n*0.05;
                    imgui.PushStyleColor("Button", Color.hsv(hue, 0.6, 0.6));
                    imgui.PushStyleColor("ButtonHovered", Color.hsv(hue, 0.7, 0.7));
                    imgui.PushStyleColor("ButtonActive", Color.hsv(hue, 0.8, 0.8));
                    // each button has a different width
                    let w = 40 + 20*Math.sin(line + n);
                    imgui.Button(label, new Vec2(w, 0));
                    imgui.PopStyleColor(3);
                    imgui.PopID();
                }
            }
            let scroll_x = imgui.GetScrollX();
            let scroll_max_x = imgui.GetScrollMaxX();
            imgui.EndChild();
            imgui.PopStyleVar(2);
            let scroll_x_delta = 0.;
            imgui.SmallButton("<<");
            if (imgui.IsItemActive())
            {
                scroll_x_delta = -imgui.GetIO().DeltaTime * 1000;
            }
            imgui.SameLine();
            imgui.Text("Scroll from code");
            imgui.SameLine();
            imgui.SmallButton(">>");
            if (imgui.IsItemActive())
            {
                scroll_x_delta = +imgui.GetIO().DeltaTime * 1000;
            }
            imgui.SameLine();
            imgui.Text("%d/%d", scroll_x, scroll_max_x);
            if (scroll_x_delta != 0)
            {
                // Demonstrate a trick: you can use Begin to set yourself in
                // the context of another window (here we are already out of
                // your child window)
                imgui.BeginChild("scrolling");
                imgui.SetScrollX(imgui.GetScrollX() + scroll_x_delta);
                imgui.EndChild();
            }
            imgui.TreePop();
        }
        if (imgui.TreeNode("Clipping"))
        {
            let dl = imgui.GetWindowDrawList();
            let bg = Colors.gray;
            let fg = Colors.white;
            let txt = "Line 1 hello\nLine 2 clip me!";
            let fontScale = 2;
            let bigfont = imgui.GetFont(null, fontScale);
            if(this.C_size == null)
            {
                this.C_size = new Vec2(100, 100);
                this.C_offset = new Vec2(50, 20);
            }
            imgui.TextWrapped("On a per-widget basis we are occasionally clipping text CPU-side if it won't fit in its frame. Otherwise we are doing coarser clipping + passing a scissor rectangle to the renderer. The system is designed to try minimizing both execution and CPU/GPU rendering cost.");
            imgui.DragVec2("size", this.C_size, 0.5, 1., 200., "%d");
            imgui.TextWrapped("(Click and drag)");
            const pos = imgui.GetCursorScreenPos();
            let clip_rect = new Rect(pos.x, pos.y,
                                    pos.x + this.C_size.x,
                                    pos.y + this.C_size.y);
            imgui.InvisibleButton("##dummy", this.C_size);
            if (imgui.IsItemActive() && imgui.IsMouseDragging())
            {
                this.C_offset.x += imgui.GetIO().MouseDelta.x;
                this.C_offset.y += imgui.GetIO().MouseDelta.y;
            }
            dl.AddRectFilled(pos,
                            new Vec2(pos.x + this.C_size.x,
                                     pos.y + this.C_size.y),
                            bg);
            dl.AddText(txt, new Vec2(pos.x + this.C_offset.x,
                                    pos.y + this.C_offset.y),
                        bigfont, imgui.GetLineHeight()*fontScale,
                        fg, 0.0, clip_rect);
            imgui.TreePop();
        }
    } // end Show()
}

// =====================================================================================================================
// panels/demoLayout.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/demoWidgets.js BEGIN
// =====================================================================================================================


class DemoWidgets
{
    constructor(imgui)
    {
        this.imgui = imgui;
        this.clicked = 0;
        this.check = true;
        this.e =  0;
        this.counter = 0;
        this.arr = [ 0.6, 0.1, 1.0, 0.5, 0.92, 0.1, 0.2 ];
        this.items = [ "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG",
                    "HHHH", "IIII", "JJJJ", "KKKK", "LLLLLLL", "MMMM", "OOOOOOO" ];
        this.item_current = 0;
        this.str0 = new MutableString("Hello, world!");
        this.str1 = new MutableString("");
        this.i0 = 123;
        this.i1 = 50;
        this.i2 = 42;
        this.i3 = 0; // slider int

        this.f0 = 0.001;
        this.f1 = 1.e10;
        this.f2 = 1;
        this.f3 = .0067;
        this.f4 = .123; // slider float
        this.f5 = .0; // slider float (curve)

        this.d0 = 999999.00000001;
        this.vec4a = [ 0.10, 0.20, 0.30, 0.44 ];

        this.angle = 0;

        this.col1 = Color.rgb(1.0,0.0,0.2);
        this.col2 = Color.rgb(0.4,0.7,0.0,0.5);

        this.listbox_items = [ "Apple", "Banana", "Cherry", "Kiwi", "Mango",
                            "Orange", "Pineapple", "Strawberry", "Watermelon" ];
        this.listbox_item_current = 1;

        this.align_label_with_current_x_position = false;
        this.selection_mask = (1 << 2); // Dumb representation of what may be user-side selection state. You may carry selection state inside or outside your objects in whatever format you see fit.
        this.node_clicked = -1;                // Temporary storage of what node we have clicked to process selection at the end of the loop. May be a pointer to your own node type, etc.

        this.plot_animate = false;
        this.plot_arr = [ 0.6, 0.1, 1.0, 0.5, 0.92, 0.1, 0.2 ];


    }

    Show()
    {
        let imgui = this.imgui;
        if (!imgui.CollapsingHeader("Widgets"))
            return;

        if (imgui.TreeNode("Basic"))
        {
            if (imgui.Button("Button"))
                this.clicked++;
            if (this.clicked & 1)
            {
                imgui.SameLine();
                imgui.Text("Thanks for clicking me!");
            }

            if(imgui.Checkbox("checkbox", this.check))
                this.check = !this.check;

            if(imgui.RadioButton("radio a", this.e==0))
                this.e = 0;
            imgui.SameLine();
            if(imgui.RadioButton("radio b", this.e==1))
                this.e = 1;
            imgui.SameLine();
            if(imgui.RadioButton("radio c", this.e==2))
                this.e = 2;

            // Color buttons, demonstrate using PushID() to add unique
            // identifier in the ID stack, and changing style.
            for (let i = 0; i < 7; i++)
            {
                if (i > 0)
                    imgui.SameLine();
                imgui.PushID(i);
                imgui.PushStyleColor("Button", Color.hsv(i/7.0, 0.6, 0.6));
                imgui.PushStyleColor("ButtonHovered", Color.hsv(i/7.0, 0.7, 0.7));
                imgui.PushStyleColor("ButtonActive", Color.hsv(i/7.0, 0.8, 0.8));
                imgui.Button("Click");
                imgui.PopStyleColor(3);
                imgui.PopID();
            }

            // Use AlignTextToFramePadding() to align text baseline to the
            // baseline of framed elements (otherwise a Text+SameLine+Button
            // sequence will have the text a little too high by default)
            imgui.AlignTextToFramePadding();
            imgui.Text("Hold to repeat:");
            imgui.SameLine();

            // Arrow buttons with Repeater
            let spacing = imgui.GetStyle().ItemInnerSpacing.x;
            imgui.PushButtonRepeat(true);
            if (imgui.ArrowButton("##left", Dir.Left)) { this.counter--; }
            imgui.SameLine(0.0, spacing);
            if (imgui.ArrowButton("##right", Dir.Right)) { this.counter++; }
            imgui.PopButtonRepeat();
            imgui.SameLine();
            imgui.Text("%d", this.counter);

            imgui.Text("Hover over me");
            if (imgui.IsItemHovered())
                imgui.SetTooltip("I am a tooltip");

            imgui.SameLine();
            imgui.Text("- or me");
            if (imgui.IsItemHovered())
            {
                imgui.BeginTooltip();
                imgui.Text("I am a fancy tooltip");
                imgui.PlotLines("Curve", this.arr);
                imgui.EndTooltip();
            }

            imgui.Separator();

            imgui.LabelText("label", "Value");

            // Using the _simplified_ one-liner Combo() api here
            // See "Combo" section for examples of how to use the more
            // complete BeginCombo()/EndCombo() api.
            imgui.Combo("combo", this.item_current, this.items, -1,
                (newval) => this.item_current = newval);
            imgui.SameLine();
            imgui.Tooltip("Refer to the \"Combo\" section below for an explanation of the full BeginCombo/EndCombo API, and demonstration of various flags.\n");

            imgui.InputText("input text", this.str0);
            imgui.SameLine(); imgui.Tooltip("USER:\nHold SHIFT or use mouse to select text.\n" +
                    "CTRL+Left/Right to word jump.\n" +
                    "CTRL+A or double-click to select all.\n" +
                    "CTRL+X,CTRL+C,CTRL+V clipboard.\n" +
                    "CTRL+Z,CTRL+Y undo/redo.\n" +
                    "ESCAPE to revert.\n\nPROGRAMMER:\nYou can use the InputTextFlags.CallbackResize facility if you need to wire InputText() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example (this is not demonstrated in imgui_demo.cpp).");

            imgui.InputTextWithHint("input text (w/ hint)", "enter text here", this.str1);

            imgui.InputInt("input int", this.i0, 1, 100, 0,
                            (newval)=>this.i0=newval);
            imgui.SameLine(); imgui.Tooltip("You can apply arithmetic operators +,*,/ on numerical values.\n  e.g. [ 100 ], input '*2', result becomes [ 200 ]\nUse +- to subtract.\n");

            imgui.InputFloat("input float", this.f0, 0.01, 1.0, "%.3f", 0,
                             (newval) => this.f0 = newval);

            imgui.InputDouble("input double", this.d0, 0.01, 1.0, "%.8f", 0,
                             (newval) => this.d0 = newval);

            imgui.InputFloat("input scientific", this.f1, 0.0, 0.0, "%e", 0,
                             (newval) => this.f1 = newval);
            imgui.SameLine(); imgui.Tooltip("You can input value using the scientific notation,\n  e.g. \"1e+8\" becomes \"100000000\".\n");

            imgui.InputFloat3("input float3", this.vec4a);

            imgui.DragInt("drag int", this.i1, 1, 0, 0, "%d",
                            (newval) => this.i1 = newval);
            imgui.SameLine(); imgui.Tooltip("Click and drag to edit value.\nHold SHIFT/ALT for faster/slower edit.\nDouble-click or CTRL+click to input value.");

            imgui.DragInt("drag int 0..100", this.i2, 1, 0, 100, "%d%",
                            (newval) => this.i2 = newval);

            imgui.DragFloat("drag float", this.f2, 0.005, 0, 0, "%.3f", 1,
                            (newval) => this.f2 = newval);

            imgui.DragFloat("drag small float", this.f3, 0.0001, 0.0, 0.0,
                            "%.6f ns", 1,
                            (newval) => this.f3 = newval);

            imgui.SliderInt("slider int", this.i3, -1, 3, null,
                            (newval)=>this.i3=newval);

            imgui.SameLine(); imgui.Tooltip("CTRL+click to input value.");

            imgui.SliderFloat("slider float", this.f4, 0.0, 1.0, "ratio = %.3f", 1.0,
                                (newval)=>this.f4=newval);
            imgui.SliderFloat("slider float (curve)", this.f5, -10.0, 10.0, "%.4f", 2.0,
                                (newval)=>this.f5=newval);
            imgui.SliderAngle("slider angle", this.angle, -360, 360, "%d deg",
                                (newval)=>this.angle=newval);

            imgui.ColorEdit3("color 1", this.col1);
            imgui.SameLine(); imgui.Tooltip("Click on the colored square to open a color picker.\nClick and hold to use drag and drop.\nRight-click on the colored square to show options.\nCTRL+click on individual component to input value.\n");

            imgui.ColorEdit4("color 2", this.col2);

            // List box
            imgui.ListBox("listbox\n(single select)", this.listbox_item_current,
                          this.listbox_items, 4,
                          (newsel) => this.listbox_item_current = newsel);
            //static int listbox_item_current2 = 2;
            //imgui.SetNextItemWidth(-1);
            //imgui.ListBox("##listbox2", &listbox_item_current2, listbox_items, IM_ARRAYSIZE(listbox_items), 4);

            imgui.TreePop();
        } // end Basic

        // Testing ImGuiOnceUponAFrame helper.
        //static ImGuiOnceUponAFrame once;
        //for (int i = 0; i < 5; i++)
        //    if (once)
        //        imgui.Text("This will be displayed only once.");

        if (imgui.TreeNode("Trees"))
        {
            if (imgui.TreeNode("Basic trees"))
            {
                for (let i = 0; i < 5; i++)
                {
                    if (imgui.TreeNode("Child " + i))
                    {
                        imgui.Text("blah blah");
                        imgui.SameLine();
                        imgui.SmallButton("button");
                        imgui.TreePop();
                    }
                }
                imgui.TreePop();
            }

            if (imgui.TreeNode("Advanced, with Selectable nodes"))
            {
                imgui.Tooltip("This is a more typical looking tree with selectable nodes.\nClick to select, CTRL+Click to toggle, click on arrows or double-click to open.");
                if(imgui.Checkbox("Align label with current X position)",
                                this.align_label_with_current_x_position))
                    this.align_label_with_current_x_position = !this.align_label_with_current_x_position;
                imgui.Text("Hello!");
                if (this.align_label_with_current_x_position)
                    imgui.Unindent(imgui.GetTreeNodeToLabelSpacing());

                imgui.PushStyleVar("IndentSpacing", imgui.GetFontSize()*3); // Increase spacing to differentiate leaves from expanded contents.
                for (let i = 0; i < 6; i++)
                {
                    // Disable the default open on single-click behavior and pass
                    // in Selected flag according to our selection state.
                    let node_flags = TreeNodeFlags.OpenOnArrow | TreeNodeFlags.OpenOnDoubleClick;
                    if (this.selection_mask & (1 << i))
                        node_flags |= TreeNodeFlags.Selected;
                    if (i < 3)
                    {
                        // Items 0..2 are Tree Node
                        let node_open = imgui.TreeNodeEx("Selectable Node "+i, node_flags);
                        if (imgui.IsItemClicked())
                            this.node_clicked = i;
                        if (node_open)
                        {
                            imgui.Text("Blah blah\nBlah Blah");
                            imgui.TreePop();
                        }
                    }
                    else
                    {
                        // Items 3..5 are Tree Leaves
                        // The only reason we use TreeNode at all is to allow selection of the leaf.
                        // Otherwise we can use BulletText() or TreeAdvanceToLabelPos()+Text().
                        node_flags |= TreeNodeFlags.Leaf | TreeNodeFlags.NoTreePushOnOpen; // iTreeNodeFlags.Bullet
                        imgui.TreeNodeEx("Selectable Leaf " + i, node_flags);
                        if (imgui.IsItemClicked())
                            this.node_clicked = i;
                    }
                }
                if (this.node_clicked != -1)
                {
                    // Update selection state. Process outside of tree loop to avoid visual inconsistencies during the clicking-frame.
                    if (imgui.GetIO().KeyCtrl)
                        this.selection_mask ^= (1 << this.node_clicked);          // CTRL+click to toggle
                    else //if (!(selection_mask & (1 << node_clicked))) // Depending on selection behavior you want, this commented bit preserve selection when clicking on item that is part of the selection
                        this.selection_mask = (1 << this.node_clicked);           // Click to single-select
                }
                imgui.PopStyleVar();
                if (this.align_label_with_current_x_position)
                    imgui.Indent(imgui.GetTreeNodeToLabelSpacing());
                imgui.TreePop();
            }
            imgui.TreePop(); // Trees
        }

        if (imgui.TreeNode("Collapsing Headers"))
        {
            if(this.closable_group == undefined)
                this.closable_group = new ValRef(true);
            if(imgui.Checkbox("Show 2nd header", this.closable_group.get()))
                this.closable_group.toggle();
            if (imgui.CollapsingHeader("Header"))
            {
                imgui.Text("IsItemHovered: %s", imgui.IsItemHovered());
                for (let i = 0; i < 5; i++)
                    imgui.Text("Some content %d", i);
            }
            if (imgui.CollapsingHeaderO("Header with a close button", this.closable_group))
            {
                imgui.Text("IsItemHovered: %s", imgui.IsItemHovered());
                for (let i = 0; i < 5; i++)
                    imgui.Text("More content %d", i);
            }
            imgui.TreePop();
        }

        if (imgui.TreeNode("Bullets"))
        {
            imgui.BulletText("Bullet point 1");
            imgui.BulletText("Bullet point 2\nOn multiple lines");
            imgui.Bullet(); imgui.Text("Bullet point 3 (two calls)");
            imgui.Bullet(); imgui.SmallButton("Button");
            imgui.TreePop();
        }

        if (imgui.TreeNode("Text"))
        {
            if (imgui.TreeNode("Colored Text"))
            {
                // Using shortcut. You can use PushStyleColor()/PopStyleColor() for more flexibility.
                imgui.TextColored(Color.rgba(1.0,0.0,1.0,1.0), "Pink");
                imgui.TextColored(Color.rgba(1.0,1.0,0.0,1.0), "Yellow");
                imgui.TextDisabled("Disabled");
                imgui.SameLine(); imgui.Tooltip("The TextDisabled color is stored in ImGuiStyle.");
                imgui.TreePop();
            }

            if (imgui.TreeNode("Word Wrapping"))
            {
                // Using shortcut. You can use PushTextWrapPos()/PopTextWrapPos() for more flexibility.
                imgui.TextWrapped("This text should automatically wrap on the edge of the window. The current implementation for text wrapping follows simple rules suitable for English and possibly other languages.");
                imgui.Spacing();

                if(this.wrap_width == undefined)
                    this.wrap_width = 200.0;
                imgui.SliderFloat("Wrap width", this.wrap_width, -20, 600, "%d", 1,
                                (newval) => this.wrap_width = newval);

                imgui.Text("Test paragraph 1:");
                let pos = imgui.GetCursorScreenPos();
                imgui.GetWindowDrawList().AddRectFilled(
                                            new Vec2(pos.x + this.wrap_width, pos.y),
                                            new Vec2(pos.x + this.wrap_width + 10,
                                                    pos.y + imgui.GetTextLineHeight()),
                                            Color.rgba(1,0,1,1));
                imgui.PushTextWrapPos(imgui.GetCursorPos().x + this.wrap_width);
                imgui.Text("The lazy dog is a good dog. This paragraph is made to fit within %d pixels. Testing a 1 character word. The quick brown fox jumps over the lazy dog.",
                            this.wrap_width);
                imgui.GetWindowDrawList().AddRect(imgui.GetItemRectMin(),
                                                  imgui.GetItemRectMax(),
                                                  Color.rgba(1,1,0,1));
                imgui.PopTextWrapPos();

                imgui.Text("Test paragraph 2:");
                pos = imgui.GetCursorScreenPos();
                imgui.GetWindowDrawList().AddRectFilled(
                                            new Vec2(pos.x + this.wrap_width, pos.y),
                                            new Vec2(pos.x + this.wrap_width + 10, pos.y + imgui.GetTextLineHeight()),
                                            Color.rgba(1,0,1,1));
                imgui.PushTextWrapPos(imgui.GetCursorPos().x + this.wrap_width);
                imgui.Text("aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   ffffffff. gggggggg!hhhhhhhh");
                imgui.GetWindowDrawList().AddRect(imgui.GetItemRectMin(),
                                                  imgui.GetItemRectMax(),
                                                  Color.rgba(1,1,0,1));
                imgui.PopTextWrapPos();
                imgui.TreePop();
            }

            if (imgui.TreeNode("Unicode Text"))
            {
                // Unicode test with Japanese characters
                // (Needs a suitable font, try Noto, or Arial Unicode, or M+ fonts. Read misc/fonts/README.txt for details.)
                //  https://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html
                // https://www.unicode.org/charts/PDF/U3040.pdf
                imgui.Tooltip("Japanese characters must be present in selected font");
                imgui.Text("Hiragana: " + String.fromCharCode.apply(null,
                        [0x304b, 0x304d, 0x304f, 0x3051, 0x3053]) + " (kakikukeko)");
                imgui.Text("Kanjis: " + String.fromCharCode.apply(null,
                        [0x4f0f, 0x50b0, 0x5300, 0x56e0]) + " (random)");

                // Note that characters values are preserved even by InputText() if the font cannot be displayed, so you can safely copy & paste garbled characters into another application.
                // imgui.InputText("UTF-8 input", buf, IM_ARRAYSIZE(buf));
                imgui.TreePop();
            }
            imgui.TreePop();
        }

        if (imgui.TreeNode("Images"))
        {
            let io = imgui.GetIO();
            let url = "/img/imgui-njs/logo.png";
            let imgSz = new Vec2(200, 100); // real image is larger, aspect ratio matches
            imgui.Text("Display Size: %d,%d", imgSz.x, imgSz.y);
            let pos = imgui.GetCursorScreenPos();
            imgui.Image(url, imgSz,
                        null, null, // subrect within larger one [0,1]
                        null,  // tint
                        Color.rgba(.3,.8,1.0,0.5) // border
                        );
            if (imgui.IsItemHovered())
            {
                imgui.BeginTooltip();
                let region_sz = 32.0;
                let region_x = io.MousePos.x - pos.x - region_sz * 0.5;
                region_x = Vec1.Clamp(region_x, 0, imgSz.x - region_sz);
                let region_y = io.MousePos.y - pos.y - region_sz * 0.5;
                region_y = Vec1.Clamp(region_y, 0, imgSz.y - region_sz);
                let zoom = 4.0;
                imgui.Text("Min: (%3d, %3d)", region_x, region_y);
                imgui.Text("Max: (%3d, %3d)", region_x + region_sz, region_y + region_sz);
                let uv0 = new Vec2(region_x/imgSz.x, region_y/imgSz.y);
                let uv1 = new Vec2((region_x + region_sz) / imgSz.x,
                                   (region_y + region_sz) / imgSz.y);
                imgui.Image(url,
                            new Vec2(region_sz * zoom, region_sz * zoom),
                            uv0, uv1,
                            null, Color.rgba(1.0, 1.0, 1.0, 0.5)
                            );
                imgui.EndTooltip();
            }

            imgui.TextWrapped("And now some textured buttons..");
            if(this.imgPressCount == undefined)
                this.imgPressCount = 0;
            let bsize = new Vec2(64,32);
            for (let i = 0; i < 8; i++)
            {
                imgui.PushID(i);
                let frame_padding = -1 + i;     // -1 = uses default padding
                if (imgui.ImageButton(url, bsize, null, null,
                                    frame_padding, Color.rgba(0.0,0.0,0.0,1.0)))
                    this.imgPressCount++;
                imgui.PopID();
                imgui.SameLine();
            }
            imgui.NewLine();
            imgui.Text("Pressed %d times.", this.imgPressCount);
            imgui.TreePop();
        }

        if (imgui.TreeNode("Combo"))
        {
            // Expose flags as checkbox for the demo
            if(this.comboflags == undefined)
                this.comboflags = 0;
            imgui.CheckboxFlags("ComboFlags.PopupAlignLeft",
                    this.comboflags, ComboFlags.PopupAlignLeft,
                    (newval)=>this.comboflags=newval);
            imgui.SameLine();
            imgui.Tooltip("Only makes a difference if the popup is larger than the combo");
            imgui.CheckboxFlags("ComboFlags.NoArrowButton",
                    this.comboflags, ComboFlags.NoArrowButton,
                    (newval) =>
                    {
                        // Clear the NoPreview flag, as we cannot combine both
                        this.comboflags = newval & ~ComboFlags.NoPreview;
                    });
            imgui.CheckboxFlags("ComboFlags.NoPreview",
                    this.comboflags, ComboFlags.NoPreview,
                    (newval) =>
                    {
                        // Clear the NoArrow flag, as we cannot combine both
                        this.comboflags = newval &= ~ComboFlags.NoArrowButton;
                    });

            // General BeginCombo() API, you have full control over your
            // selection data and display type. (your selection data could
            // be an index, a pointer to the object, an id for the object,
            // a flag stored in the object itself, etc.)

            // The second parameter is the label previewed before opening the combo.
            if(this.item_current_1 == undefined)
                this.item_current_1 = "";
            if (imgui.BeginCombo("combo 1", this.item_current_1, this.comboflags))
            {
                for (let n = 0; n < this.items.length; n++)
                {
                    let is_selected = (this.item_current_1 == this.items[n]);
                    if (imgui.Selectable(this.items[n], is_selected))
                        this.item_current_1 = this.items[n];
                    if (is_selected)
                        imgui.SetItemDefaultFocus();   // Set the initial focus when opening the combo (scrolling + for keyboard navigation support in the upcoming navigation branch)
                }
                imgui.EndCombo();
            }

            // Simplified one-liner Combo() API, using values packed in a
            // single constant string
            if(this.item_current_2 == undefined)
                this.item_current_2 = 0;
            imgui.Combo("combo 2 (one-liner)", this.item_current_2,
                ["aaaa", "bbbb", "cccc", "dddd", "eeee"], -1,
                (newval) => this.item_current_2 = newval);

            // Simplified one-liner Combo() using an array of const char*
            if(this.item_current_3 == undefined)
            {
                // If the selection isn't within 0..count, Combo won't display a preview
                this.item_current_3 = -1;
            }
            imgui.Combo("combo 3 (array)", this.item_current_3, this.items, -1,
                (newval) => this.item_current_3 = newval);

            // Simplified one-liner Combo() using an accessor function
            if(this.item_current_4 == undefined)
                this.item_current_4 = 0;
            let getter = function(i) { return this.items[i]; }.bind(this);
            imgui.ComboCB("combo 4 (function)", this.item_current_4, getter,
                        this.items.length, -1,
                        (newval) => this.item_current_4 = newval);
            imgui.TreePop();
        }

        if (imgui.TreeNode("Selectables"))
        {
            if(this.S_selection == undefined)
            {
                this.S_selection = [false, true, false, false, false];
                this.S_selected = -1;
                this.S_mselection = [false, false, false, false, false];
                this.S_selected2 = [ false, false, false ];
                this.S_selected3 = [];
                this.S_selected3.length = 16;
                this.S_selected3.fill(0);
                this.S_selected4 = [ true, false, false, false,
                                    false, true, false, false,
                                    false, false, true, false,
                                    false, false, false, true ];
                this.S_selected5 = [ true, false, true,
                                    false, true, false,
                                    true, false, true ];
            }
            if (imgui.TreeNode("Basic"))
            {
                if(imgui.Selectable("1. I am selectable", this.S_selection[0]))
                    this.S_selection[0] = !this.S_selection[0];
                if(imgui.Selectable("2. I am selectable", this.S_selection[1]))
                    this.S_selection[1] = !this.S_selection[1];
                imgui.Text("3. I am not selectable");
                if(imgui.Selectable("4. I am selectable", this.S_selection[3]))
                    this.S_selection[3] = !this.S_selection[3];
                if (imgui.Selectable("5. I am double clickable", this.S_selection[4],
                    SelectableFlags.AllowDoubleClick))
                {
                    if (imgui.IsMouseDoubleClicked(0))
                        this.S_selection[4] = !this.S_selection[4];
                }
                imgui.TreePop();
            }
            if (imgui.TreeNode("Selection State: Single Selection"))
            {
                for (let n = 0; n < 5; n++)
                {
                    if (imgui.Selectable("Object "+n, this.S_selected == n))
                        this.S_selected = n;
                }
                imgui.TreePop();
            }
            if (imgui.TreeNode("Selection State: Multiple Selection"))
            {
                imgui.Tooltip("Hold CTRL and click to select multiple items.");
                for (let n = 0; n < 5; n++)
                {
                    if (imgui.Selectable("Object "+n, this.S_mselection[n]))
                    {
                        // Clear selection when CTRL is not held
                        if (!imgui.GetIO().KeyCtrl)
                            this.S_mselection.fill(false);
                        this.S_mselection[n] ^= 1;
                    }
                }
                imgui.TreePop();
            }
            if (imgui.TreeNode("Rendering more text into the same line"))
            {
                if(imgui.Selectable("main.c", this.S_selected2[0]))
                    this.S_selected2[0] ^= 1;
                imgui.SameLine(300);
                imgui.Text(" 2,345 bytes");
                if(imgui.Selectable("Hello.cpp", this.S_selected2[1]))
                    this.S_selected2[1] ^= 1;
                imgui.SameLine(300);
                imgui.Text("12,345 bytes");
                if(imgui.Selectable("Hello.h", this.S_selected2[2]))
                    this.S_selected2[2] ^= 1;
                imgui.SameLine(300); imgui.Text(" 2,345 bytes");
                imgui.TreePop();
            }
            if (imgui.TreeNode("In columns"))
            {
                imgui.Columns(3, null, false);
                for (let i = 0; i < this.S_selected3.length; i++)
                {
                    if (imgui.Selectable("Item "+i, this.S_selected3[i]))
                    {
                        this.S_selected3[i] ^= 1;
                    }
                    imgui.NextColumn();
                }
                imgui.Columns(1);
                imgui.TreePop();
            }
            if (imgui.TreeNode("Grid"))
            {
                for (let i = 0; i < this.S_selected4.length; i++)
                {
                    imgui.PushID(i);
                    if (imgui.Selectable("Sailor", this.S_selected4[i], 0, new Vec2(50,50)))
                    {
                        let x = i % 4;
                        let y = i / 4;
                        if (x > 0)           { this.S_selected4[i - 1] ^= 1; }
                        if (x < 3 && i < 15) { this.S_selected4[i + 1] ^= 1; }
                        if (y > 0 && i > 3)  { this.S_selected4[i - 4] ^= 1; }
                        if (y < 3 && i < 12) { this.S_selected4[i + 4] ^= 1; }
                    }
                    if ((i % 4) < 3) imgui.SameLine();
                    imgui.PopID();
                }
                imgui.TreePop();
            }
            if (imgui.TreeNode("Alignment"))
            {
                let sz = new Vec2(80,80);
                imgui.Tooltip("Alignment applies when a selectable is larger than its text content.\nBy default, Selectables uses style.SelectableTextAlign but it can be overriden on a per-item basis using PushStyleVar().");
                for (let y = 0; y < 3; y++)
                {
                    for (let x = 0; x < 3; x++)
                    {
                        if (x > 0) imgui.SameLine();
                        let alignment = new Vec2(x/2.0, y/2.0);
                        let name = `(${alignment.x.toFixed(1)},${alignment.y.toFixed(1)})`;
                        imgui.PushStyleVar("SelectableTextAlign", alignment);
                        let j = 3*y + x;
                        if(imgui.Selectable(name, this.S_selected5[j],
                                    SelectableFlags.None, sz))
                        {
                            this.S_selected5[j] ^= 1;
                        }
                        imgui.PopStyleVar();
                    }
                }
                imgui.TreePop();
            }
            imgui.TreePop();
        }

        if (imgui.TreeNode("Text Input"))
        {
            if (imgui.TreeNode("Multi-line Text Input"))
            {
                // Note: we are using a fixed-sized buffer for simplicity here. See InputTextFlags.CallbackResize
                // and the code in misc/cpp/imgui_stdlib.h for how to setup InputText() for dynamically resizing strings.
                if(this.T_text == undefined)
                {
                    this.T_text = new MutableString(
                    "**\n"+
                    "The Pentium F00F bug, shorthand for F0 0F C7 C8,\n"+
                    "the hexadecimal encoding of one offending instruction,\n"+
                    "more formally, the invalid operand with locked CMPXCHG8B\n"+
                    "instruction bug, is a design flaw in the majority of\n"+
                    "Intel Pentium, Pentium MMX, and Pentium OverDrive\n"+
                    "processors (all in the P5 microarchitecture).\n"+
                    "**\n\n"+
                    "label:\n"+
                    "\tlock cmpxchg8b eax\n");
                    this.T_flags = InputTextFlags.AllowTabInput;
                }

                imgui.Tooltip("You can use the InputTextFlags.CallbackResize facility if you need to wire InputTextMultiline() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example. (This is not demonstrated in imgui_demo.cpp)");
                imgui.CheckboxFlags("InputTextFlags.ReadOnly",
                                this.T_flags, InputTextFlags.ReadOnly,
                                (newval) => this.T_flags = newval);
                imgui.CheckboxFlags("InputTextFlags.AllowTabInput",
                                this.T_flags, InputTextFlags.AllowTabInput,
                                (newval) => this.T_flags = newval);
                imgui.CheckboxFlags("InputTextFlags.CtrlEnterForNewLine",
                                this.T_flags, InputTextFlags.CtrlEnterForNewLine,
                                (newval) => this.T_flags = newval);
                imgui.InputTextMultiline("##source", this.T_text,
                                new Vec2(-1.0, imgui.GetTextLineHeight() * 16),
                                this.T_flags);
                imgui.TreePop();
            }

            if (imgui.TreeNode("Filtered Text Input"))
            {
                if(!this.FT_buf1)
                {
                    this.FT_buf1 = new MutableString("");
                    this.FT_buf2 = new MutableString("");
                    this.FT_buf3 = new MutableString("");
                    this.FT_buf4 = new MutableString("");
                    this.FT_buf5 = new MutableString("");
                    this.FT_buf6 = new MutableString("");
                    this.FT_customFilter = function(filterCtx)
                    {
                        return /[imgui]/.test(filterCtx.EventChar) ? 0 : 1;
                    };
                }
                imgui.InputText("default", this.FT_buf1);
                imgui.InputText("decimal", this.FT_buf2, InputTextFlags.CharsDecimal);
                imgui.InputText("hexadecimal", this.FT_buf3, InputTextFlags.CharsHexadecimal |
                                                             InputTextFlags.CharsUppercase);
                imgui.InputText("uppercase", this.FT_buf4, InputTextFlags.CharsUppercase);
                imgui.InputText("no blank", this.FT_buf5, InputTextFlags.CharsNoBlank);

                imgui.InputText("\"imgui\" letters", this.FT_buf6,
                                InputTextFlags.CallbackCharFilter,
                                this.FT_customFilter);

                /*
                imgui.Text("Password input");
                static char bufpass[64] = "password123";
                imgui.InputText("password", bufpass, 64, InputTextFlags.Password | InputTextFlags.CharsNoBlank);
                imgui.SameLine(); imgui.Tooltip("Display all characters as '*'.\nDisable clipboard cut and copy.\nDisable logging.\n");
                imgui.InputTextWithHint("password (w/ hint)", "<password>", bufpass, 64, InputTextFlags.Password | InputTextFlags.CharsNoBlank);
                imgui.InputText("password (clear)", bufpass, 64, InputTextFlags.CharsNoBlank);
                */
                imgui.TreePop();
            }

            if (imgui.TreeNode("Resize Callback"))
            {
                imgui.Text("resizable strings probably not useful in javascript?");
                // If you have a custom string type you would typically create a imgui.InputText() wrapper than takes your type as input.
                // See misc/cpp/imgui_stdlib.h and .cpp for an implementation of this using std::string.
                /*
                imgui.Tooltip("Demonstrate using InputTextFlags.CallbackResize to wire your resizable string type to InputText().\n\nSee misc/cpp/imgui_stdlib.h for an implementation of this for std::string.");
                struct Funcs
                {
                    static int MyResizeCallback(ImGuiInputTextCallbackData* data)
                    {
                        if (data->EventFlag == InputTextFlags.CallbackResize)
                        {
                            ImVector<char>* my_str = (ImVector<char>*)data->UserData;
                            IM_ASSERT(my_str->begin() == data->Buf);
                            my_str->resize(data->BufSize);  // NB: On resizing calls, generally data->BufSize == data->BufTextLen + 1
                            data->Buf = my_str->begin();
                        }
                        return 0;
                    }

                    // Tip: Because imgui. is a namespace you would typicall add your own function into the namespace in your own source files.
                    // For example, you may add a function called imgui.InputText(const char* label, MyString* my_str).
                    static bool MyInputTextMultiline(const char* label, ImVector<char>* my_str, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0)
                    {
                        IM_ASSERT((flags & InputTextFlags.CallbackResize) == 0);
                        return imgui.InputTextMultiline(label, my_str->begin(), (size_t)my_str->size(), size, flags | InputTextFlags.CallbackResize, Funcs::MyResizeCallback, (void*)my_str);
                    }
                };

                // For this demo we are using ImVector as a string container.
                // Note that because we need to store a terminating zero character, our size/capacity are 1 more than usually reported by a typical string class.
                static ImVector<char> my_str;
                if (my_str.empty())
                    my_str.push_back(0);
                Funcs::MyInputTextMultiline("##MyStr", &my_str, ImVec2(-1.0, imgui.GetTextLineHeight() * 16));
                imgui.Text("Data: %p\nSize: %d\nCapacity: %d", (void*)my_str.begin(), my_str.size(), my_str.capacity());
                */
                imgui.TreePop();
            }
            imgui.TreePop(); // TextInput
        }

        if (imgui.TreeNode("Plots Widgets"))
        {
            if(imgui.Checkbox("Animate", this.plot_animate))
                this.plot_animate = !this.plot_animate;
            imgui.PlotLines("Frame Times", this.plot_arr);

            // Create a dummy array of contiguous float values to plot
            // Tip: If your float aren't contiguous but part of a structure,
            // you can pass a pointer to your first float and the sizeof() of
            // your structure in the Stride parameter.
            if(this.plot_values == undefined || this.plot_refresh_time < imgui.GetTime())
            {
                if(this.plot_values == undefined)
                {
                    this.plot_values = [];
                    this.plot_values.length = 90;
                    this.plot_values.fill(0);
                    this.plot_values_offset = 0;
                    this.plot_refresh_time = 0;
                    this.plot_phase = 0;
                }
                if (!this.plot_animate || this.plot_refresh_time == 0.0)
                    this.plot_refresh_time = imgui.GetTime();
                // Create dummy data at fixed 60 hz rate for the demo
                while (this.plot_refresh_time < imgui.GetTime())
                {
                    this.plot_values[this.plot_values_offset] = Math.cos(this.plot_phase);
                    this.plot_values_offset = (this.plot_values_offset+1) % this.plot_values.length;
                    this.plot_phase += 0.10*this.plot_values_offset;
                    this.plot_refresh_time += 1.0/60.0;
                }
            }
            let sz = new Vec2(0, 80);
            imgui.PlotLines("Lines", this.plot_values, this.plot_values_offset,
                            "avg 0.0", -1.0, 1.0, sz);
            imgui.PlotHistogram("Histogram", this.plot_arr, 0,
                            null, 0.0, 1.0, sz);
            // Use functions to generate output
            // FIXME: This is rather awkward because current plot API only
            // pass in indices. We probably want an API passing floats and
            // user provide sample rate/count.
            if(this.plot_func_type == undefined)
            {
                this.plot_func_type = 0;
                this.plot_display_count = 70;
                this.plot_funcs = [
                    function(i) { return Math.sin(i*.1); },
                    function(i) { return i&1 ? 1 : -1;},
                ];
            }
            imgui.Separator();
            imgui.SetNextItemWidth(100);
            imgui.Combo("func", this.plot_func_type, ["Sin", "Saw"], -1,
                        (newval) => this.plot_func_type = newval);
            imgui.SameLine();
            imgui.SliderInt("Sample count", this.plot_display_count, 1, 400,null,
                        (newval) => this.plot_display_count = newval);
            let func = this.plot_funcs[this.plot_func_type];
            imgui.PlotLinesCB("Lines", func, this.plot_display_count, 0,
                            null, -1.0, 1.0, sz);
            imgui.PlotHistogramCB("Histogram", func, this.plot_display_count, 0,
                            null, -1.0, 1.0, sz);
            imgui.Separator();

            // Animate a simple progress bar
            if(this.plot_progress == undefined)
            {
                this.plot_progress = 0.0;
                this.plot_progress_dir = 1.0;
            }
            if (this.plot_animate)
            {
                this.plot_progress += this.plot_progress_dir * 0.4 * imgui.GetIO().DeltaTime;
                if (this.plot_progress >= +1.1)
                {
                    this.plot_progress = +1.1;
                    this.plot_progress_dir *= -1.0;
                }
                if (this.plot_progress <= -0.1)
                {
                    this.plot_progress = -0.1;
                    this.plot_progress_dir *= -1.0;
                }
            }

            // Typically we would use Vec2(-1.0,0.0) to use all available width,
            // or Vec2(width,0.0) for a specified width. ImVec2(0.0,0.0) uses ItemWidth.
            imgui.ProgressBar(this.plot_progress, Vec2.Zero());
            imgui.SameLine(0.0, imgui.GetStyle().ItemInnerSpacing.x);
            imgui.Text("Progress Bar");

            let sat = Vec1.Saturate(this.plot_progress);
            let txt = `${Math.floor(1753*sat)}/1753`;
            imgui.ProgressBar(this.plot_progress, Vec2.Zero(), txt);
            imgui.TreePop();
        }

        if (imgui.TreeNode("Color/Picker Widgets"))
        {
            if(this.CP_color == undefined)
            {
                this.CP_color = Color.rgba(114.0/255.0, 144.0/255.0, 154.0/255.0, 200.0/255.0);
                this.CP_alpha_preview = true;
                this.CP_alpha_half_preview = false;
                this.CP_drag_and_drop = true;
                this.CP_options_menu = true;
                this.CP_hdr = false;
            }
            if(imgui.Checkbox("With Alpha Preview", this.CP_alpha_preview))
                this.CP_alpha_preview ^= 1;
            if(imgui.Checkbox("With Half Alpha Preview", this.CP_alpha_half_preview))
                this.CP_alpha_half_preview ^= 1;
            if(imgui.Checkbox("With Drag and Drop", this.CP_drag_and_drop))
                this.CP_drag_and_drop ^= 1;
            if(imgui.Checkbox("With Options Menu", this.CP_options_menu))
                this.CP_options_menu ^= 1;
            imgui.SameLine();
            imgui.Tooltip("Right-click on the individual color widget to show options.");
            if(imgui.Checkbox("With HDR", this.CP_hdr))
                this.CP_hdr ^= 1;
            imgui.SameLine();
            imgui.Tooltip("Currently all this does is to lift the 0..1 limits on dragging widgets.");

            let misc_flags = (this.CP_hdr ? ColorEditFlags.HDR : 0) |
                             (this.CP_drag_and_drop ? 0 : ColorEditFlags.NoDragDrop) |
                             (this.CP_alpha_half_preview ? ColorEditFlags.AlphaPreviewHalf :
                                (this.CP_alpha_preview ? ColorEditFlags.AlphaPreview : 0)) |
                             (this.CP_options_menu ? 0 : ColorEditFlags.NoOptions);

            imgui.Text("Color widget:");
            imgui.SameLine();
            imgui.Tooltip("Click on the colored square to open a color picker.\nCTRL+click on individual component to input value.\n");
            imgui.ColorEdit3("MyColor##1", this.CP_color, misc_flags);

            imgui.Text("Color widget HSV with Alpha:");
            imgui.ColorEdit4("MyColor##2", this.CP_color, ColorEditFlags.DisplayHSV | misc_flags);

            imgui.Text("Color widget with Float Display:");
            imgui.ColorEdit4("MyColor##2", this.CP_color, ColorEditFlags.Float | misc_flags);

            imgui.Text("Color button with Picker:");
            imgui.SameLine();
            imgui.Tooltip("With the ColorEditFlags.NoInputs flag you can hide all the slider/text inputs.\nWith the ColorEditFlags.NoLabel flag you can pass a non-empty label which will only be used for the tooltip and picker popup.");
            imgui.ColorEdit4("MyColor##3", this.CP_color,
                ColorEditFlags.NoInputs | ColorEditFlags.NoLabel | misc_flags);

            imgui.Text("Color button with Custom Picker Popup:");

            // Generate a dummy default palette. The palette will persist and can be edited.
            if(this.CP_saved_palette == undefined)
            {
                this.CP_saved_palette = [];
                this.CP_saved_palette.length = 32;
                for (let n = 0; n < this.CP_saved_palette.length; n++)
                {
                    this.CP_saved_palette[n] = Color.hsv(n/31, .8, .8);
                }
                this.CP_backup_color = Color.rgb(0,0,0);
            }
            let open_popup = imgui.ColorButton("MyColor##3b", this.CP_color, misc_flags);
            imgui.SameLine();
            open_popup |= imgui.Button("Palette");
            if (open_popup)
            {
                imgui.OpenPopup("mypicker");
                this.CP_backup_color.Copy(this.CP_color);
            }
            if (imgui.BeginPopup("mypicker"))
            {
                imgui.Text("MY CUSTOM COLOR PICKER WITH AN AMAZING PALETTE!");
                imgui.Separator();
                imgui.ColorPicker4("##picker", this.CP_color, misc_flags |
                        ColorEditFlags.NoSidePreview | ColorEditFlags.NoSmallPreview);
                imgui.SameLine();

                imgui.BeginGroup(); // Lock X position
                imgui.Text("Current");
                imgui.ColorButton("##current", this.CP_color,
                        ColorEditFlags.NoPicker | ColorEditFlags.AlphaPreviewHalf,
                        new Vec2(60,40));
                imgui.Text("Previous");
                if (imgui.ColorButton("##previous", this.CP_backup_color,
                        ColorEditFlags.NoPicker | ColorEditFlags.AlphaPreviewHalf,
                        new Vec2(60,40)))
                {
                    this.CP_color.Copy(this.CP_backup_color);
                }
                imgui.Separator();
                imgui.Text("Palette");
                for (let n = 0; n < this.CP_saved_palette.length; n++)
                {
                    imgui.PushID(n);
                    if ((n % 8) != 0)
                        imgui.SameLine(0.0, imgui.GetStyle().ItemSpacing.y);
                    if (imgui.ColorButton("##palette", this.CP_saved_palette[n],
                            ColorEditFlags.NoAlpha | ColorEditFlags.NoPicker | ColorEditFlags.NoTooltip,
                            new Vec2(20,20)))
                    {
                        let a = this.CP_color.a; // Preserve alpha
                        this.CP_color.Copy(this.CP_saved_palette[n]);
                        this.CP_color.a = a;
                    }

                    // Allow user to drop colors into each palette entry
                    // (Note that ColorButton is already a drag source by default,
                    // unless using ColorEditFlags.NoDragDrop)
                    if (imgui.BeginDragDropTarget())
                    {
                        console.log("begin dragdrop target");
                        /*
                        if (const ImGuiPayload* payload = imgui.AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
                            memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 3);
                        if (const ImGuiPayload* payload = imgui.AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
                            memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 4);
                        */
                        imgui.EndDragDropTarget();
                    }

                    imgui.PopID();
                }
                imgui.EndGroup();
                imgui.EndPopup();
            }

            imgui.Text("Color button only:");
            imgui.ColorButton("MyColor##3c", this.CP_color, misc_flags,
                              new Vec2(80,80));

            imgui.Text("Color picker:");
            if(this.CP_alpha == undefined)
            {
                this.CP_alpha = true;
                this.CP_alpha_bar = true;
                this.CP_side_preview = true;
                this.CP_ref_color = false;
                this.CP_ref_color_v = Color.rgba(1.0,0.0,1.0,0.5);
                this.CP_display_mode = 0;
                this.CP_picker_mode = 0;
            }
            if(imgui.Checkbox("With Alpha", this.CP_alpha))
                this.CP_alpha ^= 1;
            if(imgui.Checkbox("With Alpha Bar", this.CP_alpha_bar))
                this.CP_alpha_bar ^= 1;
            if(imgui.Checkbox("With Side Preview", this.CP_side_preview))
                this.CP_side_preview ^= 1;
            if (this.CP_side_preview)
            {
                imgui.SameLine();
                if(imgui.Checkbox("With Ref Color", this.CP_ref_color))
                    this.CP_ref_color ^= 1;
                if (this.CP_ref_color)
                {
                    imgui.SameLine();
                    imgui.ColorEdit4("##RefColor", this.CP_ref_color_v,
                            ColorEditFlags.NoInputs | misc_flags);
                }
            }
            imgui.Combo("Display Mode", this.CP_display_mode,
                    ["Auto/Current","None", "RGB Only", "HSV Only", "Hex Only"],
                    (newval=>this.CP_display_mode=newval));
            imgui.SameLine();
            imgui.Tooltip("ColorEdit defaults to displaying RGB inputs if you don't specify a display mode, but the user can change it with a right-click.\n\nColorPicker defaults to displaying RGB+HSV+Hex if you don't specify a display mode.\n\nYou can change the defaults using SetColorEditOptions().");
            imgui.Combo("Picker Mode", this.CP_picker_mode,
                    ["Auto/Current", "Hue bar + SV rect", "Hue wheel + SV triangle"],
                    (newval) => this.CP_picker_mode = newval);
            imgui.SameLine();
            imgui.Tooltip("User can right-click the picker to change mode.");
            let flags = misc_flags;
            // This is by default if you call ColorPicker3() instead of ColorPicker4()
            if (!this.CP_alpha)            flags |= ColorEditFlags.NoAlpha;
            if (this.CP_alpha_bar)         flags |= ColorEditFlags.AlphaBar;
            if (!this.CP_side_preview)     flags |= ColorEditFlags.NoSidePreview;
            if (this.CP_picker_mode == 1)  flags |= ColorEditFlags.PickerHueBar;
            if (this.CP_picker_mode == 2)  flags |= ColorEditFlags.PickerHueWheel;
            if (this.CP_display_mode == 1) flags |= ColorEditFlags.NoInputs;       // Disable all RGB/HSV/Hex displays
            if (this.CP_display_mode == 2) flags |= ColorEditFlags.DisplayRGB;     // Override display mode
            if (this.CP_display_mode == 3) flags |= ColorEditFlags.DisplayHSV;
            if (this.CP_display_mode == 4) flags |= ColorEditFlags.DisplayHex;
            imgui.ColorPicker4("MyColor##4", this.CP_color, flags,
                        this.CP_ref_color ? this.CP_ref_color_v : null);

            imgui.Text("Programmatically set defaults:");
            imgui.SameLine();
            imgui.Tooltip("SetColorEditOptions() is designed to allow you to set boot-time default.\nWe don't have Push/Pop functions because you can force options on a per-widget basis if needed, and the user can change non-forced ones with the options menu.\nWe don't have a getter to avoid encouraging you to persistently save values that aren't forward-compatible.");
            if (imgui.Button("Default: Uint8 + HSV + Hue Bar"))
                imgui.SetColorEditOptions(ColorEditFlags.Uint8 | ColorEditFlags.DisplayHSV | ColorEditFlags.PickerHueBar);
            if (imgui.Button("Default: Float + HDR + Hue Wheel"))
                imgui.SetColorEditOptions(ColorEditFlags.Float | ColorEditFlags.HDR | ColorEditFlags.PickerHueWheel);

            // HSV encoded support (to avoid RGB<>HSV round trips and singularities when S==0 or V==0)
            if(this.CP_color_stored_as_hsv == undefined)
            {
                this.CP_color_stored_as_hsv = Color.rgba(0.23, 1.0, 1.0, 1.0);
            }
            imgui.Spacing();
            imgui.Text("HSV encoded colors");
            imgui.SameLine();
            imgui.Tooltip("By default, colors are given to ColorEdit and ColorPicker in RGB, but ColorEditFlags.InputHSV allows you to store colors as HSV and pass them to ColorEdit and ColorPicker as HSV. This comes with the added benefit that you can manipulate hue values with the picker even when saturation or value are zero.");
            imgui.Text("Color widget with InputHSV:");
            imgui.ColorEdit4("HSV shown as HSV##1", this.CP_color_stored_as_hsv,
                ColorEditFlags.DisplayRGB | ColorEditFlags.InputHSV | ColorEditFlags.Float);
            imgui.ColorEdit4("HSV shown as RGB##1", this.CP_color_stored_as_hsv,
                ColorEditFlags.DisplayHSV | ColorEditFlags.InputHSV | ColorEditFlags.Float);
            imgui.DragFloat4("Raw HSV values", this.CP_color_stored_as_hsv, 0.01, 0.0, 1.0);
            imgui.TreePop();
        }

        if (imgui.TreeNode("Range Widgets"))
        {
            if(this.RW_begin == undefined)
            {
                this.RW_begin = 10;
                this.RW_end = 90;
                this.RW_begin_i = 100;
                this.RW_end_i = 1000;
            }
            imgui.DragFloatRange2("range", this.RW_begin, this.RW_end,
                            0.25, 0.0, 100.0, "Min: %.1f %", "Max: %.1f %", 1,
                            (min, max) => {this.RW_begin=min; this.RW_end=max;}
                            );
            imgui.DragIntRange2("range int (no bounds)",
                            this.RW_begin_i, this.RW_end_i, 5, 0, 0,
                            "Min: %d units", "Max: %d units",
                            (min, max) => {this.RW_begin_i=min; this.RW_end_i=max;}
                            );
            imgui.TreePop();
        }

        if (imgui.TreeNode("Data Types"))
        {
            imgui.Text("javascript only has one number type");
            imgui.TreePop();
        }

        if (imgui.TreeNode("Multi-component Widgets"))
        {
            if(this.MC_vec4 == undefined)
            {
                this.MC_vec4 = [ 0.10, 0.20, 0.30, 0.44 ];
                this.MC_vec4i = [ 1, 5, 100, 255 ];
            }
            imgui.Text("warning: more work needed here");
            imgui.InputFloat2("input float2", this.MC_vec4);
            imgui.DragFloat2("drag float2", this.MC_vec4, 0.01, 0.0, 1.0);
            imgui.SliderFloat2("slider float2", this.MC_vec4, 0.0, 1.0);
            imgui.InputInt2("input int2", this.MC_vec4i);
            imgui.DragInt2("drag int2", this.MC_vec4i, 1, 0, 255);
            imgui.SliderInt2("slider int2", this.MC_vec4i, 0, 255);
            imgui.Spacing();

            imgui.InputFloat3("input float3", this.MC_vec4);
            imgui.DragFloat3("drag float3", this.MC_vec4, 0.01, 0.0, 1.0);
            imgui.SliderFloat3("slider float3", this.MC_vec4, 0.0, 1.0);
            imgui.InputInt3("input int3", this.MC_vec4i);
            imgui.DragInt3("drag int3", this.MC_vec4i, 1, 0, 255);
            imgui.SliderInt3("slider int3", this.MC_vec4i, 0, 255);
            imgui.Spacing();

            imgui.InputFloat4("input float4", this.MC_vec4);
            imgui.DragFloat4("drag float4", this.MC_vec4, 0.01, 0.0, 1.0);
            imgui.SliderFloat4("slider float4", this.MC_vec4, 0.0, 1.0);
            imgui.InputInt4("input int4", this.MC_vec4i);
            imgui.DragInt4("drag int4", this.MC_vec4i, 1, 0, 255);
            imgui.SliderInt4("slider int4", this.MC_vec4i, 0, 255);
            imgui.TreePop();
        }

        if (imgui.TreeNode("Vertical Sliders"))
        {
            if(this.VS_spacing == undefined)
            {
                this.VS_spacing = 4;
                this.VS_int_value = 0;
                this.VS_values = [ 0.0, 0.60, 0.35, 0.9, 0.70, 0.20, 0.5 ];
                this.VS_values2 = [ 0.20, 0.80, 0.40, 0.25 ];
                this.VS_rows = 3;
            }
            imgui.PushStyleVar("ItemSpacing", new Vec2(this.VS_spacing, this.VS_spacing));

            imgui.VSliderInt("##int", new Vec2(18,160), this.VS_int_value, 0, 5,
                    null,  (newval) => this.VS_int_value = newval);
            imgui.SameLine();

            for (let i = 0; i < 7; i++)
            {
                if (i > 0) imgui.SameLine();
                imgui.PushID("set1" + i);
                imgui.PushStyleColor("FrameBg", Color.hsv(i/7.0, 0.5, 0.5));
                imgui.PushStyleColor("FrameBgHovered", Color.hsv(i/7.0, 0.6, 0.5));
                imgui.PushStyleColor("FrameBgActive", Color.hsv(i/7.0, 0.7, 0.5));
                imgui.PushStyleColor("SliderGrab", Color.hsv(i/7.0, 0.9, 0.9));
                imgui.VSliderFloat("##v", new Vec2(18,160), this.VS_values[i],
                            0.0, 1.0, "", 1,
                            (newval) => this.VS_values[i]=newval);
                if (imgui.IsItemActive() || imgui.IsItemHovered())
                    imgui.SetTooltip("%.3f", this.VS_values[i]);
                imgui.PopStyleColor(4);
                imgui.PopID();
            }

            imgui.SameLine();
            const small_slider_size = new Vec2(18,
                        (160.0-(this.VS_rows-1)*this.VS_spacing)/this.VS_rows);
            for (let nx = 0; nx < 4; nx++)
            {
                if (nx > 0) imgui.SameLine();
                imgui.BeginGroup();
                for (let ny = 0; ny < this.VS_rows; ny++)
                {
                    imgui.PushID("set2_" + nx*this.VS_rows+ny);
                    imgui.VSliderFloat("##v", small_slider_size, this.VS_values2[nx],
                                0.0, 1.0, "", 1,
                                (newval) => this.VS_values2[nx]=newval);
                    if (imgui.IsItemActive() || imgui.IsItemHovered())
                        imgui.SetTooltip("%.3f", this.VS_values2[nx]);
                    imgui.PopID();
                }
                imgui.EndGroup();
            }

            imgui.SameLine();
            for (let i = 0; i < 4; i++)
            {
                if (i > 0) imgui.SameLine();
                imgui.PushID("set3_"+i);
                imgui.PushStyleVar("GrabMinSize", 40);
                imgui.VSliderFloat("##v", new Vec2(40,160), this.VS_values[i],
                                    0.0, 1.0, "%.2f\nsec", 1,
                                    (newval) => this.VS_values[i] = newval);
                imgui.PopStyleVar();
                imgui.PopID();
            }
            imgui.PopStyleVar();
            imgui.TreePop();
        }

        if (imgui.TreeNode("Drag and Drop"))
        {
            if(this.DD_col1 == undefined)
            {
                this.DD_col1 = Color.rgb(1.0,0.0,0.2);
                this.DD_col2 = Color.rgba(0.4,0.7,0.0,0.5);
                this.DD_mode = "copy"; // or "move" or "swap"
                this.DD_names = ["Bobby", "Beatrice", "Betty", "Brianna",
                                "Barry", "Bernard", "Bibi", "Blaine", "Bryn"];
            }
            // ColorEdit widgets automatically act as drag source and drag target.
            // They are using standardized payload strings IMGUI_PAYLOAD_TYPE_COLOR_3F
            // and IMGUI_PAYLOAD_TYPE_COLOR_4F to allow your own widgets
            // to use colors in their drag and drop interaction. Also see
            // the demo in Color Picker -> Palette demo.
            imgui.BulletText("Drag and drop in standard widgets");
            imgui.Indent();
            imgui.ColorEdit3("color 1", this.DD_col1);
            imgui.ColorEdit4("color 2", this.DD_col2);
            imgui.Unindent();

            imgui.BulletText("Drag and drop to copy/swap items");
            imgui.Indent();
            if (imgui.RadioButton("Copy", this.DD_mode == "copy"))
            {
                this.DD_mode = "copy";
            }
            imgui.SameLine();
            if (imgui.RadioButton("Move", this.DD_mode == "move"))
            {
                this.DD_mode = "move";
            }
            imgui.SameLine();
            if (imgui.RadioButton("Swap", this.DD_mode == "swap"))
            {
                this.DD_mode = "swap";
            }
            for (let n = 0; n < this.DD_names.length; n++)
            {
                imgui.PushID(n);
                if ((n % 3) != 0)
                    imgui.SameLine();
                imgui.Button(this.DD_names[n], new Vec2(60,60));

                // Our buttons are both drag sources and drag targets here!
                if (imgui.BeginDragDropSource(DragDropFlags.None))
                {
                    // Set payload to carry the index of our item (could be anything)
                    imgui.SetDragDropPayload("DND_DEMO_CELL", n);
                    // Display preview (could be anything, e.g. when dragging
                    // an image we could decide to display the filename and a
                    // small preview of the image, etc.)
                    imgui.Text(`${this.DD_mode} ${this.DD_names[n]}`);
                    imgui.EndDragDropSource();
                }
                if (imgui.BeginDragDropTarget())
                {
                    let payload = imgui.AcceptDragDropPayload("DND_DEMO_CELL");
                    if (payload != null)
                    {
                        let payload_n = payload.Data;
                        switch(this.DD_mode)
                        {
                        case "copy":
                            this.DD_names[n] = this.DD_names[payload_n];
                            break;
                        case "move":
                            this.DD_names[n] = this.DD_names[payload_n];
                            this.DD_names[payload_n] = "";
                            break;
                        case "swap":
                            {
                                let tmp = this.DD_names[n];
                                this.DD_names[n] = this.DD_names[payload_n];
                                this.DD_names[payload_n] = tmp;
                            }
                            break;
                        }
                    }
                    imgui.EndDragDropTarget();
                }
                imgui.PopID();
            }
            imgui.Unindent();
            imgui.TreePop();
        }

        if (imgui.TreeNode("Querying Status (Active/Focused/Hovered etc.)"))
        {
            // Display the value of IsItemHovered() and other common item state functions. Note that the flags can be combined.
            // (because BulletText is an item itself and that would affect the output of IsItemHovered() we pass all state in a single call to simplify the code).
            if(this.Q_item_type == undefined)
            {
                this.Q_item_type = 1;
                this.Q_b = false;
                this.Q_col = Color.rgba(1,.2, .4, 1);
                this.Q_mstr = new MutableString();
                this.Q_sel = 0;
                this.Q_embed = false;
                this.Q_testwin = new ValRef(false);
            }
            if(imgui.RadioButton("Text ", this.Q_item_type==0))
                this.Q_item_type = 0;
            if(imgui.RadioButton("Button", this.Q_item_type==1))
                this.Q_item_type = 1;
            if(imgui.RadioButton("Checkbox", this.Q_item_type==2))
                this.Q_item_type = 2;
            if(imgui.RadioButton("SliderFloat", this.Q_item_type==3))
                this.Q_item_type = 3;
            if(imgui.RadioButton("InputText", this.Q_item_type==4))
                this.Q_item_type = 4;
            if(imgui.RadioButton("ColorEdit4", this.Q_item_type==5))
                this.Q_item_type = 5;
            if(imgui.RadioButton("MenuItem", this.Q_item_type==6))
                this.Q_item_type = 6;
            if(imgui.RadioButton("TreeNode (w/ double-click)", this.Q_item_type==7))
                this.Q_item_type = 7;
            if(imgui.RadioButton("ListBox", this.Q_item_type==8))
                this.Q_item_type = 8;
            imgui.Separator();
            let ret = false;
            switch(this.Q_item_type)
            {
            case 0: // Testing text items with no identifier/interaction
                imgui.Text("ITEM: Text");
                break;
            case 1:
                ret = imgui.Button("ITEM: Button");
                break;
            case 2:
                ret = imgui.Checkbox("ITEM: Checkbox", this.Q_b);
                break;
            case 3:
                ret = imgui.SliderFloat("ITEM: SliderFloat", this.Q_col.x,
                        0.0, 1.0, "%.3f", 1, (newval) => this.Q_col.x = newval);
                break;
            case 4:
                // Testing input text (which handles tabbing)
                ret = imgui.InputText("ITEM: InputText", this.Q_mstr);
                break;
            case 5:
                // Testing multi-component items (IsItemXXX flags are reported merged)
                ret = imgui.ColorEdit4("ITEM: ColorEdit4", this.Q_col);
                break;
            case 6:
                // Testing menu item (they use ButtonFlags.PressedOnRelease button policy)
                ret = imgui.MenuItem("ITEM: MenuItem");
                break;
            case 7:
                // Testing tree node with ButtonFlags.PressedOnDoubleClick button policy.
                ret = imgui.TreeNodeEx("ITEM: TreeNode w/ TreeNodeFlags.OpenOnDoubleClick",
                                     TreeNodeFlags.OpenOnDoubleClick |
                                     TreeNodeFlags.NoTreePushOnOpen);
                break;
            case 8:
                ret = imgui.ListBox("ITEM: ListBox", this.Q_sel,
                            [ "Apple", "Banana", "Cherry", "Kiwi"], -1,
                            (newval) => this.Q_sel = newval);
                break;
            }

            const ll = "Return value = %d\n" +
                "IsItemFocused() = %d\n" +
                "IsItemHovered() = %d\n" +
                "IsItemHovered(_AllowWhenBlockedByPopup) = %d\n" +
                "IsItemHovered(_AllowWhenBlockedByActiveItem) = %d\n" +
                "IsItemHovered(_AllowWhenOverlapped) = %d\n" +
                "IsItemHovered(_RectOnly) = %d\n" +
                "IsItemActive() = %d\n" +
                "IsItemEdited() = %d\n" +
                "IsItemActivated() = %d\n" +
                "IsItemDeactivated() = %d\n" +
                "IsItemDeactivatedAfterEdit() = %d\n" +
                "IsItemVisible() = %d\n" +
                "IsItemClicked() = %d\n" +
                "GetItemRectMin() = (%.1f, %.1f)\n" +
                "GetItemRectMax() = (%.1f, %.1f)\n" +
                "GetItemRectSize() = (%.1f, %.1f)";
            imgui.BulletText(ll, ret,
                imgui.IsItemFocused(),
                imgui.IsItemHovered(),
                imgui.IsItemHovered(HoveredFlags.AllowWhenBlockedByPopup),
                imgui.IsItemHovered(HoveredFlags.AllowWhenBlockedByActiveItem),
                imgui.IsItemHovered(HoveredFlags.AllowWhenOverlapped),
                imgui.IsItemHovered(HoveredFlags.RectOnly),
                imgui.IsItemActive(),
                imgui.IsItemEdited(),
                imgui.IsItemActivated(),
                imgui.IsItemDeactivated(),
                imgui.IsItemDeactivatedAfterEdit(),
                imgui.IsItemVisible(),
                imgui.IsItemClicked(),
                imgui.GetItemRectMin().x, imgui.GetItemRectMin().y,
                imgui.GetItemRectMax().x, imgui.GetItemRectMax().y,
                imgui.GetItemRectSize().x, imgui.GetItemRectSize().y
            );

            if(imgui.Checkbox("Embed everything inside a child window (for additional testing)", this.Q_embed))
                this.Q_embed = !this.Q_embed;
            if (this.Q_embed)
                imgui.BeginChild("outer_child", new Vec2(0, imgui.GetFontSize() * 20), true);

            // Testing IsWindowFocused() function with its various flags.
            // Note that the flags can be combined.
            imgui.BulletText(
                "IsWindowFocused() = %d\n"+
                "IsWindowFocused(ChildWindows) = %d\n"+
                "IsWindowFocused(ChildWindows|_RootWindow) = %d\n"+
                "IsWindowFocused(RootWindow) = %d\n"+
                "IsWindowFocused(AnyWindow) = %d\n",
                imgui.IsWindowFocused(),
                imgui.IsWindowFocused(FocusedFlags.ChildWindows),
                imgui.IsWindowFocused(FocusedFlags.ChildWindows | FocusedFlags.RootWindow),
                imgui.IsWindowFocused(FocusedFlags.RootWindow),
                imgui.IsWindowFocused(FocusedFlags.AnyWindow));

            // Testing IsWindowHovered() function with its various flags.
            // Note that the flags can be combined.
            imgui.BulletText(
                "IsWindowHovered() = %d\n"+
                "IsWindowHovered(AllowWhenBlockedByPopup) = %d\n"+
                "IsWindowHovered(AllowWhenBlockedByActiveItem) = %d\n"+
                "IsWindowHovered(ChildWindows) = %d\n"+
                "IsWindowHovered(ChildWindows|RootWindow) = %d\n"+
                "IsWindowHovered(ChildWindows|AllowWhenBlockedByPopup) = %d\n"+
                "IsWindowHovered(RootWindow) = %d\n"+
                "IsWindowHovered(AnyWindow) = %d\n",
                imgui.IsWindowHovered(),
                imgui.IsWindowHovered(HoveredFlags.AllowWhenBlockedByPopup),
                imgui.IsWindowHovered(HoveredFlags.AllowWhenBlockedByActiveItem),
                imgui.IsWindowHovered(HoveredFlags.ChildWindows),
                imgui.IsWindowHovered(HoveredFlags.ChildWindows | HoveredFlags.RootWindow),
                imgui.IsWindowHovered(HoveredFlags.ChildWindows | HoveredFlags.AllowWhenBlockedByPopup),
                imgui.IsWindowHovered(HoveredFlags.RootWindow),
                imgui.IsWindowHovered(HoveredFlags.AnyWindow));

            imgui.BeginChild("child", new Vec2(0, 50), true);
            imgui.Text("This is another child window for testing the ChildWindows flag.");
            imgui.EndChild();
            if (this.Q_embed)
                imgui.EndChild();

            // Calling IsItemHovered() after begin returns the hovered status of the title bar.
            // This is useful in particular if you want to create a context menu (with BeginPopupContextItem) associated to the title bar of a window.
            if(imgui.Checkbox("Hovered/Active tests after Begin() for title bar testing",
                            this.Q_testwin.get()))
                this.Q_testwin.toggle();
            if (this.Q_testwin.get())
            {
                imgui.Begin("Title bar Hovered/Active tests", this.Q_testwin);
                if (imgui.BeginPopupContextItem()) // <-- This is using IsItemHovered()
                {
                    if (imgui.MenuItem("Close"))
                        this.Q_testwin.set(false);
                    imgui.EndPopup();
                }
                imgui.Text(
                    "IsItemHovered() after begin = %d (== is title bar hovered)\n"+
                    "IsItemActive() after begin = %d (== is window being clicked/moved)\n",
                    imgui.IsItemHovered(), imgui.IsItemActive());
                imgui.End();
            }
            imgui.TreePop();
        }
    }
}

// =====================================================================================================================
// panels/demoWidgets.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/styleeditor.js BEGIN
// =====================================================================================================================


class StyleEditorWindow
{
    constructor(imgui)
    {
        this.styleEditor = null;
    }

    Show(imgui, winname, isOpen)
    {
        if(!isOpen.get()) return;
        imgui.SetNextWindowPos(new Vec2(40, 40), CondFlags.FirstUseEver);
        imgui.SetNextWindowSize(new Vec2(500, 700), CondFlags.FirstUseEver);
        let winflags = 0;
        if(imgui.Begin(winname, isOpen, winflags))
        {
            if(!this.styleEditor)
                this.styleEditor = new StyleEditor(imgui);
            this.styleEditor.Show();
        }
        imgui.End();
    }
}

class StyleEditor
{
    constructor(imgui)
    {
        this.imgui = imgui;
        this.colorTextFilter = new TextFilter(imgui);
        this.outputTarget = 0;
        this.outputModifiedOnly = false;
        this.colorAlphaFlags = 0;
        this.refStyle = imgui.guictx.Style.Clone();
    }

    // You can pass in a reference style to compare to, revert
    // to and save to (else it compares to an internally stored
    // reference)
    Show()
    {
        let imgui = this.imgui;
        let style = imgui.GetStyle();
        let dirty = false;

        imgui.PushItemWidth(imgui.GetWindowWidth() * 0.5);

        if (this.showStyleSelector("Colors##Selector"))
        {
            this.refStyle = style.Clone();
            // new: style embodies colors scheme, plus font and other params
        }
        let ref = this.refStyle;

        // Simplified Settings
        if (imgui.SliderFloat("FrameRounding", style.FrameRounding, 0.0, 12.0,
            "%.0f", 1, (v) => style.FrameRounding = v))
        {
            style.GrabRounding = style.FrameRounding; // Make GrabRounding always the same value as FrameRounding
            dirty = true;
        }
        let window_border = (style.WindowBorderSize > 0);
        if (imgui.Checkbox("WindowBorder", window_border))
        {
            style.WindowBorderSize = window_border ? 0 : 1; // toggle
            dirty = true;
        }
        imgui.SameLine();
        let frame_border = (style.FrameBorderSize > 0);
        if (imgui.Checkbox("FrameBorder", frame_border))
        {
            style.FrameBorderSize = frame_border ? 0 : 1; // toggle
            dirty = true;
        }
        imgui.SameLine();
        let popup_border = style.PopupBorderSize > 0;
        if (imgui.Checkbox("PopupBorder", popup_border))
        {
            style.PopupBorderSize = popup_border ? 0 : 1; // toggle
            dirty = true;
        }

        // Save/Revert button
        if (imgui.Button("Save Ref"))
        {
            this.refStyle = style.Clone();
            ref = this.refStyle;
        }
        imgui.SameLine();
        if (imgui.Button("Revert Ref"))
        {
            this.guictx.Style = this.refStyle.Clone();
            dirty = true;
        }

        imgui.Separator(); // -------------------------------------
        if (imgui.BeginTabBar("##tabs", TabBarFlags.None))
        {
            if (imgui.BeginTabItem("Sizes"))
            {
                imgui.Text("Fonts");

                for(let fs in style.FontSizes)
                {
                    imgui.SliderInt(fs, style.FontSizes[fs], 8, 32, null, (newval) => 
                    {
                        style.FontSizes[fs] = newval;
                        dirty = true;
                    });
                }

                imgui.Text("Main");
                imgui.SliderFloat("TextLineHeightPct", style.TextLineHeightPct,
                                .4, 2, "%.2f", 1,
                                (newval)=>style.TextLineHeightPct=newval);
                imgui.SliderInt2("WindowPadding", style.WindowPadding, 0, 20);
                imgui.SliderInt2("FramePadding", style.FramePadding, 0, 20);
                imgui.SliderInt2("ItemSpacing", style.ItemSpacing, 0, 20);
                imgui.SliderInt2("ItemInnerSpacing", style.ItemInnerSpacing, 0, 20);
                imgui.SliderInt2("TouchExtraPadding", style.TouchExtraPadding, 0, 10);
                imgui.SliderInt("IndentSpacing", style.IndentSpacing, 0, 30, null,
                                        (newval)=> style.IndentSpacing = newval);
                imgui.SliderInt("ScrollbarSize", style.ScrollbarSize, 1., 20., null,
                                        (newval)=> style.ScrollbarSize = newval);
                imgui.SliderInt("GrabMinSize", style.GrabMinSize, 1, 20, null,
                                        (newval)=> style.GrabMinSize = newval);
                imgui.Text("Borders");
                imgui.SliderFloat("WindowBorderSize", style.WindowBorderSize, 0., 1., "%.0f", 1,
                                        (newval) => style.WindowBorderSize = newval);
                imgui.SliderFloat("ChildBorderSize", style.ChildBorderSize, 0., 1., "%.0f", 1,
                                        (newval) => style.ChildBorderSize = newval);
                imgui.SliderFloat("PopupBorderSize", style.PopupBorderSize, 0., 1., "%.0f", 1,
                                        (newval) => style.PopupBorderSize = newval);
                imgui.SliderFloat("FrameBorderSize", style.FrameBorderSize, 0., 1., "%.0f", 1,
                                        (newval) => style.FrameBorderSize = newval);
                imgui.SliderFloat("TabBorderSize", style.TabBorderSize, 0., 1., "%.0f", 1,
                                        (newval) => style.TabBorderSize = newval);
                imgui.Text("Rounding");
                imgui.SliderFloat("WindowRounding", style.WindowRounding, 0., 12., "%.0f", 1,
                                        (newval) => style.WindowRounding = newval);
                imgui.SliderFloat("ChildRounding", style.ChildRounding, 0., 12., "%.0f", 1,
                                        (newval) => style.ChildRounding = newval);
                imgui.SliderFloat("FrameRounding", style.FrameRounding, 0., 12., "%.0f", 1,
                                        (newval) => style.FrameRounding = newval);
                imgui.SliderFloat("PopupRounding", style.PopupRounding, 0., 12., "%.0f", 1,
                                        (newval) => style.PopupRounding = newval);
                imgui.SliderFloat("ScrollbarRounding", style.ScrollbarRounding, 0., 12., "%.0f", 1,
                                        (newval) => style.ScrollbarRounding = newval);
                imgui.SliderFloat("GrabRounding", style.GrabRounding, 0., 12., "%.0f", 1,
                                        (newval) => style.GrabRounding = newval);
                imgui.SliderFloat("TabRounding", style.TabRounding, 0., 12., "%.0f", 1,
                                        (newval) => style.TabRounding = newval);
                imgui.Text("Alignment");
                imgui.SliderFloat2("WindowTitleAlign", style.WindowTitleAlign, 0., 1., "%.2f");
                imgui.SliderFloat2("ButtonTextAlign", style.ButtonTextAlign, 0., 1., "%.2f");
                imgui.Tooltip("Alignment applies when a button is larger than its text content.");
                imgui.SliderFloat2("SelectableTextAlign", style.SelectableTextAlign, 0, 1, "%.2f");
                imgui.Tooltip("Alignment applies when a selectable is larger than its text content.");
                imgui.Text("Safe Area Padding");
                imgui.Tooltip("Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).");
                imgui.SliderFloat2("DisplaySafeAreaPadding", style.DisplaySafeAreaPadding, 0., 30., "%.0f");
                imgui.EndTabItem();
            }
            if (imgui.BeginTabItem("Colors"))
            {
                // static int output_dest = 0;
                // static bool output_only_modified = true;
                if (imgui.Button("Export Unsaved"))
                {
                    if (this.outputTarget == 0)
                        imgui.LogToClipboard();
                    else
                        imgui.LogToTTY();
                    imgui.LogText("{\nstyle.Colors: {");
                    for (let key in style.Colors)
                    {
                        let c = ref.Colors[key];
                        if(!this.outputModifiedOnly || style.Colors[key] != c)
                        {
                            let value = c.AsStr();
                            imgui.LogText(`${key}: ${value}\n`);
                        }
                    }
                    imgui.LogText("\n}\n}");
                    imgui.LogFinish();
                }
                imgui.SameLine();
                imgui.PushItemWidth(120);
                imgui.Combo("##output_type", this.outputTarget, ["To Clipboard", "To TTY"]);
                imgui.PopItemWidth();
                imgui.SameLine();
                if(imgui.Checkbox("Only Modified Colors", this.outputModifiedOnly))
                    this.outputModifiedOnly = !this.outputModifiedOnly;

                this.colorTextFilter.Draw("Filter colors", imgui.GetFontSize() * 16);

                if(imgui.RadioButton("Opaque", this.colorAlphaFlags==0))
                    this.colorAlphaFlags = 0;
                imgui.SameLine();
                if(imgui.RadioButton("Alpha", this.colorAlphaFlags==ColorEditFlags.AlphaPreview))
                    this.colorAlphaFlags = ColorEditFlags.AlphaPreview;
                imgui.SameLine();
                if(imgui.RadioButton("Both", this.colorAlphaFlags==ColorEditFlags.AlphaPreviewHalf))
                    this.colorAlphaFlags = ColorEditFlags.AlphaPreviewHalf;

                imgui.Tooltip("In the color list:\n\nLeft-click on colored square to open color picker,\n\nRight-click to open edit options menu.");

                imgui.BeginChild("##colors", Vec2.Zero(), true,
                                WindowFlags.AlwaysVerticalScrollbar|
                                WindowFlags.AlwaysHorizontalScrollbar|
                                WindowFlags.NavFlattened);
                imgui.PushItemWidth(-160);
                for (let key of style.GetSchemeColorNames())
                {
                    if (!this.colorTextFilter.PassFilter(key))
                        continue;
                    imgui.PushID(key);
                    imgui.ColorEdit4("##color", style.Colors[key],
                                    ColorEditFlags.AlphaBar|this.colorAlphaFlags);
                    if (!style.Colors[key].Equals(ref.Colors[key]))
                    {
                        // Tips: in a real user application, you may want to merge
                        // and use an icon font into the main font, so instead of
                        // "Save"/"Revert" you'd use icons. Read the FAQ and
                        // misc/fonts/README.txt about using icon fonts. It's
                        // really easy and super convenient!
                        imgui.SameLine(0., style.ItemInnerSpacing.x);
                        if (imgui.Button("Save"))
                            ref.Colors[key].Copy(style.Colors[key]);
                        imgui.SameLine(0., style.ItemInnerSpacing.x);
                        if (imgui.Button("Revert"))
                            style.Colors[key].Copy(ref.Colors[key]);
                    }
                    imgui.SameLine(0., style.ItemInnerSpacing.x);
                    imgui.TextUnformatted(key);
                    imgui.PopID();
                }
                imgui.PopItemWidth();
                imgui.EndChild();
                imgui.EndTabItem();
            } // end colors tab

            if (imgui.BeginTabItem("Fonts"))
            {
                let io = imgui.GetIO();
                let fontlist = io.Fonts.EnumerateFonts();
                imgui.PushItemWidth(120);
                for (let i=0; i<fontlist.length; i++)
                {
                    let fontname = fontlist[i];
                    imgui.PushID(fontname);
                    let fontDetailsOpen = imgui.TreeNode(fontname);
                    imgui.SameLine();
                    
                    let fsz = style.GetFontSize("Std");
                    let font = io.Fonts.GetFont(fontname, fsz);
                    if (imgui.SmallButton("Set as default"))
                        style.SetFont("Default", font);

                    if (fontDetailsOpen)
                    {
                        if(this._fontvscale == undefined)
                            this._fontvscale = 1;
                        imgui.SliderFloat("Scale", this._fontvscale, 0.2, 5,
                            "%.1f", 1, (v) => this._fontvscale = v);
                        let bigfont = io.Fonts.GetFont(fontname, 56);
                        let visfont = io.Fonts.GetFont(fontname, fsz*this._fontvscale);
                        imgui.PushFont(visfont);
                        imgui.Text("The quick brown fox jumps over the lazy dog");
                        imgui.PopFont();
                        // imgui.InputFloat("Font offset", font.DisplayOffset.y, 1, 1, "%.0f");
                        imgui.Text(`Ascent: ${visfont.Ascent.toFixed(1)}, ` +
                                 `Descent: ${visfont.Descent.toFixed(1)}, ` +
                                `Baseline: ${visfont.Baseline.toFixed(1)}, ` +
                                `Height: ${(visfont.Descent-font.Ascent).toFixed(1)}`);
                        // Display all glyphs of the fonts in separate pages of 256 characters
                        // TODO: determine fallback character.
                        let cell_p1 = new Vec2();
                        let cell_p2 = new Vec2();
                        let txtcol = imgui.GetStyleColor("Text");
                        let rcol = imgui.GetStyleColor("TextDisabled");
                        let codes = font.GetKnownCodes();
                        const glyphsPerBlock = 256;
                        const cell_size = visfont.Size; // tight packing, no LineHeightPct
                        const cell_spacing = style.ItemSpacing.y;
                        const dl = imgui.GetWindowDrawList();
                        for (let g=0; g<codes.length; g+=glyphsPerBlock)
                        {
                            if (imgui.TreeNode(`Glyphs${Math.floor(g/glyphsPerBlock)}`))
                            {
                                const base_pos = imgui.GetCursorScreenPos();
                                for (let n=0; n<glyphsPerBlock; n++)
                                {
                                    cell_p1.x = base_pos.x + (n % 16) * (cell_size + cell_spacing);
                                    cell_p1.y = base_pos.y + Math.floor(n / 16) * (cell_size + cell_spacing);
                                    cell_p2.x = cell_p1.x + cell_size;
                                    cell_p2.y = cell_p1.y + cell_size;
                                    dl.AddRect(cell_p1, cell_p2, rcol,
                                            0., CornerFlags.All, .5);
                                    let code = codes[g+n];
                                    if(code != undefined)
                                    {
                                        let char = String.fromCharCode(code);
                                        dl.AddText(char, cell_p1, visfont, font.Size, txtcol);
                                        if (imgui.IsMouseHoveringRect(cell_p1, cell_p2))
                                        {
                                            imgui.BeginTooltip();
                                            imgui.Text("code: " + code.toString(16));
                                            let nm = visfont.GetCodeName(code);
                                            if(nm) imgui.Text("name: " + nm);
                                            imgui.Separator();
                                            imgui.PushFont(bigfont);
                                            imgui.Text(char);
                                            imgui.PopFont();
                                            imgui.EndTooltip();
                                        }
                                    }
                                }
                                imgui.Dummy(new Vec2((cell_size + cell_spacing) * 16,
                                                    (cell_size + cell_spacing) * 16));
                                imgui.TreePop();
                            }
                        }
                        imgui.TreePop();
                    } // end fontdetails node open
                    imgui.PopID();
                } // end font tree node iterator
                // no atlas texture

                let window_scale = 1.;
                if (imgui.DragFloat("this window scale", window_scale, 0.005, 0.3, 2., "%.2f"))   // scale only this window
                    imgui.SetWindowFontScale(window_scale);
                if(imgui.DragFloat("global scale", io.FontGlobalScale, 0.005, 0.3, 2., "%.2f"))      // scale everything
                    imgui.SetWindowFontScale(io.FontGlobalScale);
                imgui.PopItemWidth();

                imgui.EndTabItem();
            } // end fonts tab
            if (imgui.BeginTabItem("Rendering"))
            {
                // Not exposing zero here so user doesn't "lose" the UI (zero alpha clips all widgets).
                // But application code could have a toggle to switch between zero and non-zero.
                imgui.DragFloat("Global Alpha", style.Alpha, 0.005, 0.2, 1., "%.2f");
                imgui.PopItemWidth();
                imgui.EndTabItem();
            }
            imgui.EndTabBar();
        } // end tab bar
        imgui.PopItemWidth();
    }

    showStyleSelector(label)
    {
    }

    showFontSelector(label)
    {
    }

}
// =====================================================================================================================
// panels/styleeditor.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/demoPopups.js BEGIN
// =====================================================================================================================


class DemoPopups
{
    constructor(imgui)
    {
        this.imgui = imgui;
    }

    Show()
    {
        let imgui = this.imgui;
        if(!imgui.CollapsingHeader("Popups & Modal windows"))
            return;
        // The properties of popups windows are:
        // - They block normal mouse hovering detection outside them. (*)
        // - Unless modal, they can be closed by clicking anywhere outside them,
        //   or by pressing ESCAPE.
        // - Their visibility state (~bool) is held internally by imgui instead
        //   of being held by the programmer as we are used to with regular
        //   Begin() calls. User can manipulate the visibility state by calling
        //   OpenPopup().
        // (*) One can use IsItemHovered(HoveredFlags.AllowWhenBlockedByPopup)
        //   to bypass it and detect hovering even when normally blocked by a
        //   popup. Those three properties are connected. The library needs to
        //  hold their visibility state because it can close popups at any time.

        // Typical use for regular windows:
        //
        //   bool my_tool_is_active = false;
        //   if (imgui.Button("Open"))
        //      my_tool_is_active = true;
        //      [...]
        //      if (my_tool_is_active)
        //          Begin("My Tool", &my_tool_is_active)
        //              { [...] }
        //          End();
        //
        // Typical use for popups:
        //
        //   if (imgui.Button("Open"))
        //      imgui.OpenPopup("MyPopup");
        //   if (imgui.BeginPopup("MyPopup")
        //   {
        //      [...]
        //      EndPopup();
        //   }

        // With popups we have to go through a library call (here OpenPopup) to
        // manipulate the visibility state. This may be a bit confusing at first
        // but it should quickly make sense. Follow on the examples below.

        if(imgui.TreeNode("Popups"))
        {
            if(this._P == undefined)
            {
                this._P = {};
                this._P.selected_fish = -1;
                this._P.names = ["Bream", "Haddock", "Mackerel", "Pollock", "Tilefish" ];
                this._P.toggles = [ true, false, false, false, false ];
            }
            imgui.TextWrapped("When a popup is active, it inhibits interacting with windows that are behind the popup. Clicking outside the popup closes it.");

            // Simple selection popup
            // (If you want to show the current selection inside the Button
            // itself, you may want to build a string using the "###" operator
            // to preserve a constant ID with a variable label)
            if (imgui.Button("Select.."))
                imgui.OpenPopup("my_select_popup");
            imgui.SameLine();
            imgui.TextUnformatted(this._P.selected_fish == -1 ? "<None>" :
                                 this._P.names[this._P.selected_fish]);
            if (imgui.BeginPopup("my_select_popup"))
            {
                imgui.Text("Aquarium");
                imgui.Separator();
                for (let i = 0; i < this._P.names.length; i++)
                {
                    if (imgui.Selectable(this._P.names[i]))
                        this._P.selected_fish = i;
                }
                imgui.EndPopup();
            }

            // Showing a menu with toggles
            if (imgui.Button("Toggle.."))
                imgui.OpenPopup("my_toggle_popup");
            if (imgui.BeginPopup("my_toggle_popup"))
            {
                for (let i = 0; i < this._P.names.length; i++)
                {
                    if(imgui.MenuItem(this._P.names[i], "", this._P.toggles[i]))
                        this._P.toggles[i] = !this._P.toggles[i];
                }
                if (imgui.BeginMenu("Sub-menu"))
                {
                    imgui.MenuItem("Click me");
                    imgui.EndMenu();
                }

                imgui.Separator();
                imgui.Text("Tooltip here");
                if (imgui.IsItemHovered())
                    imgui.SetTooltip("I am a tooltip over a popup");

                if (imgui.Button("Stacked Popup"))
                    imgui.OpenPopup("another popup");
                if (imgui.BeginPopup("another popup"))
                {
                    for (let i = 0; i < this._P.names.length; i++)
                        imgui.MenuItem(this._P.names[i], "", this._P.toggles[i]);
                    if (imgui.BeginMenu("Sub-menu"))
                    {
                        imgui.MenuItem("Click me");
                        imgui.EndMenu();
                    }
                    imgui.EndPopup();
                }
                imgui.EndPopup();
            }

            // Call the more complete ExampleFileMenu which we use in
            // various places of this demo
            if (imgui.Button("File Menu.."))
                imgui.OpenPopup("my_file_popup");
            if (imgui.BeginPopup("my_file_popup"))
            {
                ExampleFileMenu(imgui);
                imgui.EndPopup();
            }

            imgui.TreePop();
        }
        if(imgui.TreeNode("Context Menus"))
        {
            // BeginPopupContextItem() is a helper to provide common/simple
            // popup behavior of essentially doing:
            //    if (IsItemHovered() && IsMouseReleased(0))
            //       OpenPopup(id);
            //    return BeginPopup(id);
            // For more advanced uses you may want to replicate and customize
            // this code. This the comments inside BeginPopupContextItem()
            // implementation.
            if(this._C == undefined)
            {
                this._C = {};
                this._C.value = .5;
                this._C.name = new MutableString("Label1");
            }
            imgui.Text("Value = %.3f (<-- right-click here)", this._C.value);
            if (imgui.BeginPopupContextItem("item context menu"))
            {
                if (imgui.Selectable("Set to zero"))
                    this._C.value = 0.;
                if (imgui.Selectable("Set to PI"))
                    this._C.value = 3.1415;
                imgui.SetNextItemWidth(-1);
                imgui.DragFloat("##Value", this._C.value, 0.1, 0.0, 0.0, null, 1,
                        (newval) => this.C_value = newval);
                imgui.EndPopup();
            }

            // We can also use OpenPopupOnItemClick() which is the same as
            // BeginPopupContextItem() but without the Begin call. So here we
            // will make it that clicking on the text field with the right
            // mouse button (1) will toggle the visibility of the popup above.
            imgui.Text("(You can also right-click me to open the same popup as above.)");
            imgui.OpenPopupOnItemClick("item context menu", 1);

            // When used after an item that has an ID (here the Button), we can skip providing an ID to BeginPopupContextItem().
            // BeginPopupContextItem() will use the last item ID as the popup ID.
            // In addition here, we want to include your editable label inside the button label. We use the ### operator to override the ID (read FAQ about ID for details)
            imgui.Button(this._C.name+"###Button");
            if (imgui.BeginPopupContextItem())
            {
                imgui.Text("Edit name:");
                imgui.InputText("##edit", this._C.name);
                if (imgui.Button("Close"))
                    imgui.CloseCurrentPopup();
                imgui.EndPopup();
            }
            imgui.SameLine(); imgui.Text("(<-- right-click here)");

            imgui.TreePop();
        }
        if(imgui.TreeNode("Modals"))
        {
            if(this._M == undefined)
            {
                this._M = {};
                this._M.dont_ask_me_next_time = new ValRef(false);
                this._M.item = 1;
                this._M.color = Color.rgba(0.4,0.7,0.0,0.5);
                this._M.dummy_open = new ValRef(true);
            }
            imgui.TextWrapped("Modal windows are like popups but the user cannot close them by clicking outside the window.");

            if (imgui.Button("Delete.."))
                imgui.OpenPopup("Delete?");

            if (imgui.BeginPopupModal("Delete?", null, WindowFlags.AlwaysAutoResize))
            {
                imgui.Text("All those beautiful files will be deleted.\nThis operation cannot be undone!\n\n");
                imgui.Separator();

                //static int dummy_i = 0;
                //imgui.Combo("Combo", &dummy_i, "Delete\0Delete harder\0");

                imgui.PushStyleVar("FramePadding", Vec2.Zero(false));
                imgui.Checkbox("Don't ask me next time", this._M.dont_ask_me_next_time);
                imgui.PopStyleVar();

                if (imgui.Button("OK", new Vec2(120, 0))) { imgui.CloseCurrentPopup(); }
                imgui.SetItemDefaultFocus();
                imgui.SameLine();
                if (imgui.Button("Cancel", new Vec2(120, 0))) { imgui.CloseCurrentPopup(); }
                imgui.EndPopup();
            }

            if (imgui.Button("Stacked modals.."))
                imgui.OpenPopup("Stacked 1");
            if (imgui.BeginPopupModal("Stacked 1", null, WindowFlags.MenuBar))
            {
                if (imgui.BeginMenuBar())
                {
                    if (imgui.BeginMenu("File"))
                    {
                        if (imgui.MenuItem("Dummy menu item")) {/*empty*/}
                        imgui.EndMenu();
                    }
                    imgui.EndMenuBar();
                }
                imgui.Text("Hello from Stacked The First\nUsing style.Colors.ModalWindowDimBg behind it.");

                // Testing behavior of widgets stacking their own regular popups over the modal.
                imgui.Combo("Combo", this._M.item,
                        ["aaaa", "bbbb", "cccc", "dddd", "eeee"],
                        (newval) => this._M.item = newval);
                imgui.ColorEdit4("color", this._M.color);

                if (imgui.Button("Add another modal.."))
                    imgui.OpenPopup("Stacked 2");

                // Also demonstrate passing a bool* to BeginPopupModal(), this will create a regular close button which will close the popup.
                // Note that the visibility state of popups is owned by imgui, so the input value of the bool actually doesn't matter here.
                if (imgui.BeginPopupModal("Stacked 2", this._M.dummy_open))
                {
                    imgui.Text("Hello from Stacked The Second!");
                    if (imgui.Button("Close"))
                        imgui.CloseCurrentPopup();
                    imgui.EndPopup();
                }

                if (imgui.Button("Close"))
                    imgui.CloseCurrentPopup();
                imgui.EndPopup();
            }
            imgui.TreePop();
        }
        if(imgui.TreeNode("Menus inside a regular window"))
        {
            imgui.TextWrapped("Below we are testing adding menu items to a regular window. It's rather unusual but should work!");
            imgui.Separator();
            // NB: As a quirk in this very specific example, we want to
            // differentiate the parent of this menu from the parent of the
            // various popup menus above. To do so we are encloding the items
            // in a PushID()/PopID() block to make them two different menusets.
            // If we don't, opening any popup above and hovering our menu here
            // would open it. This is because once a menu is active, we allow
            // to switch to a sibling menu by just hovering on it, which is the
            // desired behavior for regular menus.
            imgui.PushID("foo");
            imgui.MenuItem("Menu item", "CTRL+M");
            if (imgui.BeginMenu("Menu inside a regular window"))
            {
                ExampleFileMenu(imgui);
                imgui.EndMenu();
            }
            imgui.PopID();
            imgui.Separator();
            imgui.TreePop();
        }
    } // end Show
}
// =====================================================================================================================
// panels/demoPopups.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/demoMenus.js BEGIN
// =====================================================================================================================


function ExampleFileMenu(imgui)
{
    let done = false;
    imgui.MenuItem("(dummy menu)", null, false, false);
    if (imgui.MenuItem("New"))
    {
        // pass
    }
    if (imgui.MenuItem("Open", "Ctrl+O"))
    {
        // pass
    }
    if (imgui.BeginMenu("Open Recent"))
    {
        imgui.MenuItem("fish_hat.c");
        imgui.MenuItem("fish_hat.inl");
        imgui.MenuItem("fish_hat.h");
        if (imgui.BeginMenu("More.."))
        {
            imgui.MenuItem("Hello");
            imgui.MenuItem("Sailor");
            if (imgui.BeginMenu("Recurse.."))
            {
                ExampleFileMenu(imgui);
                imgui.EndMenu();
            }
            imgui.EndMenu();
        }
        imgui.EndMenu();
    }
    if (imgui.MenuItem("Save", "Ctrl+S"))
    {
        // pass
    }
    if (imgui.MenuItem("Save As.."))
    {
        // pass
    }
    imgui.Separator();
    if (imgui.BeginMenu("Disabled", false)) // Disabled
        console.assert(0);
    if (imgui.MenuItem("Checked", null, true))
    {
        // pass
    }
    if (imgui.MenuItem("Quit", "Alt+F4"))
    {
        done = true;
    }
    return done;
}
// =====================================================================================================================
// panels/demoMenus.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/demoSimpleLayout.js BEGIN
// =====================================================================================================================


// Demonstrate create a window with multiple child windows.
let selected = 0;
function DemoSimpleLayout(imgui, p_open)
{
    imgui.SetNextWindowSize(new Vec2(500, 440), CondFlags.FirstUseEver);
    if (imgui.Begin("Example: Simple layout", p_open, WindowFlags.MenuBar))
    {
        if (imgui.BeginMenuBar())
        {
            if (imgui.BeginMenu("File"))
            {
                if (imgui.MenuItem("Close"))
                    p_open.set(false);
                imgui.EndMenu();
            }
            imgui.EndMenuBar();
        }

        // left
        imgui.BeginChild("left pane", new Vec2(150, 0), true);
        for (let i = 0; i < 100; i++)
        {
            if (imgui.Selectable("MyObject " + i, selected == i))
                selected = i;
        }
        imgui.EndChild();
        imgui.SameLine();

        // right
        imgui.BeginGroup();
            // Leave room for 1 line below us
            imgui.BeginChild("item view", new Vec2(0,
                            -imgui.GetFrameHeightWithSpacing()));
                imgui.Text("MyObject: %d", selected);
                imgui.Separator();
                if (imgui.BeginTabBar("##Tabs", TabBarFlags.None))
                {
                    if (imgui.BeginTabItem("Description"))
                    {
                        imgui.TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ");
                        imgui.EndTabItem();
                    }
                    if (imgui.BeginTabItem("Details"))
                    {
                        imgui.Text("ID: 0123456789");
                        imgui.EndTabItem();
                    }
                    imgui.EndTabBar();
                }
            imgui.EndChild();
            if (imgui.Button("Revert"))
            {
                // pass
            }
            imgui.SameLine();
            if (imgui.Button("Save"))
            {
                // pass
            }
        imgui.EndGroup();
    }
    imgui.End();
}
// =====================================================================================================================
// panels/demoSimpleLayout.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/log.js BEGIN
// =====================================================================================================================


var Singleton = null;

function GetLog()
{
    return Singleton;
}

const MaxEntries = 2000;
const EntryCullSize = 100;

// Our log should work with either fixed or variable-width fonts.
// we select short lower-case since color is emphasis
const sLevelShorten = 
{
    "ERROR": "err",
    "WARNING": "warn",
    "NOTICE": "note",
    "INFO": "info",
    "DEBUG": "dbg",
};

class LogWindow
{
    constructor(app)
    {
        this.app = app;
        this.IsShowing = new ValRef(false);

        this.entries = [];
        this.scrollToBottom = true;
        this.filter = null;
        this.lastError = "";
        this.lastErrorLevel = null;
        this.lastMsg = "";
        this.lastMsgLevel = "";
        this.console = {
            debug: console.debug,
            log: console.log,
            info: console.info,
            warn: console.warn,
            error: console.error,
            alert: window.alert
        };
        if(!Singleton)
        {
            Singleton = this;
            this.bindConsole(true);
        }
        console.debug("Starting Log");
    }

    bindConsole(override)
    {
        if(override)
        {
            console.debug = this.Debug.bind(this);
            console.info = this.Info.bind(this);
            console.log = this.Notice.bind(this);
            console.warn = this.Warning.bind(this);
            console.error = this.Error.bind(this);
            window.alert = this.Alert.bind(this);
        }
        else
        {
            console.debug = this.console.debug;
            console.info = this.console.info;
            console.log = this.console.log;
            console.warn = this.console.warn;
            console.error = this.console.error;
            window.alert = this.console.alert;
        }
    }

    Debug(msg, ...args)
    {
        // send debug message to real console
        let d = new Date();
        let h = ("0" + d.getHours()).slice(-2);
        let m = ("0" + d.getMinutes()).slice(-2);
        this.console.log(`${h}:${m} DEBUG ` + msg + args.join(" "));
        // was: this.log(msg, "DEBUG", args);
    }

    Info(msg, ...args)
    {
        this.log(msg, "INFO", args); // nb: levels are styles, see sLevelShorten
    }

    Notice(msg, ...args)
    {
        this.log(msg, "NOTICE", args);// nb: levels are styles, see sLevelShorten
    }

    Warning(msg, ...args)
    {
        this.log(msg, "WARNING", args);
    }

    Error(msg, ...args)
    {
        this.log(msg, "ERROR", args);
    }

    Alert(msg, ...args)
    {
        var x = document.getElementById("Alert");
        if(x)
        {
            x.className = "show";
            x.innerHTML = `<span>${msg}${args}</span>`;
            setTimeout(() => 
            { 
                x.className = ""; 
                x.innerHTML = "";
            }, 3000);
        }
        else
            this.log(msg, "ALERT", args);
    }

    GetLastMsg(maxLength=0)
    {
        if(maxLength == 0)
            return this.lastMsg;
        else
            return this.lastMsg.slice(0, maxLength);
    }

    GetLastMsgColor(imgui)
    {
        let lev = this.lastMsgLevel;
        if(lev)
            return imgui.guictx.Style.GetColor(lev);
        else
            return imgui.guictx.Style.GetColor("TextDisabled");
    }

    GetLastMsgLevel()
    {
        return this.lastMsgLevel;
    }

    GetLastError(maxLength=24)
    {
        if(maxLength == 0)
            return this.lastError;
        else
            return this.lastError.slice(0, maxLength);
    }

    GetLastErrorLevel()
    {
        return this.lastErrorLevel;
    }

    GetLastErrorColor(imgui)
    {
        let lev = this.lastErrorLevel;
        if(!lev) lev = "DEBUG";
        return imgui.guictx.Style.GetColor(lev);
    }

    log(msg, level="INFO", args)
    {
        if(msg.message)
            msg = msg.message;
        if(typeof(msg) == "object")
            msg = JSON.stringify(msg);
        if(args && args.length > 0)
        {
            msg += ", ";
            msg += args.join(", ");
        }
        this.lastMsg = msg;
        this.lastMsgLevel = level;
        if(level == "WARNING" || level == "ERROR" || level == "ALERT")
        {
            this.lastErrorLevel = level;
            this.lastError = msg; 
        }
        let now = Date.now();
        this.entries.push({m: msg, l: level, ts: now});
        if(this.entries.length > MaxEntries)
        {
            this.entries = this.entries.slice(EntryCullSize);
            this.entries.push({m: "log culled", l: "INFO",  ts: now});
        }
        this.dirty = true;
        this.app.OnLogActivity(this.lastMsg, this.lastMsgLevel);
    }

    Clear(doClose=true)
    {
        this.entries = [];
        this.lastMsg = "";
        this.lastError = "";
        this.lastMsgLevel = "";
        if(doClose)
            this.IsShowing.set(false);
        this.app.OnLogActivity(this.lastMsg, this.lastMsgLevel);
    }

    FilterEntries(filter)
    {
        this.entries = this.entries.filter(filter); 
    }

    Raise()
    {
        this.IsShowing.set(true);
        this.raiseRequested = true;
        this.lastMsg = "";
        this.lastMsgLevel = "";
    }

    Begin(imgui)
    {}

    Show(imgui, winname="Log")
    {
        if(!this.IsShowing.get()) return;

        if(!this.filter)
            this.filter = new TextFilter(imgui);
        if(this.app.IsMobileDevice())
        {
            imgui.SetNextWindowPos(new Vec2(0,0));
            imgui.SetNextWindowSize(imgui.guictx.IO.DisplaySize);
        }
        else
        {
            imgui.SetNextWindowPos(new Vec2(10, 10), CondFlags.FirstUseEver);
            imgui.SetNextWindowSize(new Vec2(580, 200), CondFlags.FirstUseEver);
        }
        if(this.raiseRequested)
        {
            imgui.SetNextWindowCollapsed(false, CondFlags.Always);
            imgui.SetNextWindowFocus();
            this.raiseRequested = false;
        }
        let title = `Log ${this.lastError}##${winname}`;
        let open = imgui.Begin(title, this.IsShowing);
        if(!imgui.IsWindowCollapsed())
        {
            this.lastError = "";
            this.lastErrorLevel = null;
        }
        if(open)
        {
            let toClipboard = null;
            this.lastError = "";
            if (imgui.Button("Clear"))
                this.Clear();
            imgui.SameLine();
            if (imgui.Button("Copy"))
                toClipboard = [];
            imgui.SameLine();
            this.filter.Draw("Filter", 100);
            imgui.Separator();
            imgui.BeginChild("scrolling", new Vec2(0,0), false,
                                WindowFlags.HorizontalScrollbar);
            if(this.entries.length)
            {
                let font = imgui.PushFont("Small");
                let offset = font.MeasureWidth("MMMMMMM");
                for(let i = 0; i < this.entries.length; i++)
                {
                    let entry = this.entries[i];
                    let msg = entry.m != undefined ? entry.m : entry;
                    let lev = entry.l != undefined ? entry.l : "INFO";
                    if(!(this.filter.PassFilter(msg) ||
                         this.filter.PassFilter(lev)))
                    {
                        continue;
                    }

                    let c = imgui.guictx.Style.GetColor(entry.l);
                    if(c)
                        imgui.PushStyleColor("Text",  c);
                    let head = this.formatEntryHead(entry);
                    imgui.Text(head);
                    if(c)
                        imgui.PopStyleColor();
                    imgui.SameLine(offset);
                    imgui.Text(msg);
                    if(toClipboard)
                        toClipboard.push(`${head} . ${msg}`);
                }
                imgui.PopFont();
                if(toClipboard)
                    imgui.SetClipboardText(toClipboard.join("\n"));
            }
            if (this.dirty)
            {
                imgui.SetScrollHereY(1.);
                this.dirty = false;
            }
            imgui.EndChild();
        }
        imgui.End();
    }

    GetLevelColor(imgui, lev)
    {
        let c;
        if(imgui)
        {
            if(lev == "")
                c = "#222";
            else
            {
                let imc = imgui.guictx.Style.GetColor(lev);
                c = imc.AsStr();
            }
        }
        else
        {
            c = {
                "": "#222",
                "INFO": "#448",
                "NOTICE": "#24a",
                "WARNING": "#942",
                "ERROR": "#a42",
            }[lev];
        }
        return c;
    }

    formatEntryHead(entry)
    {
        let d = new Date(entry.ts);
        let h = ("0" + d.getHours()).slice(-2);
        let m = ("0" + d.getMinutes()).slice(-2);
        let l = sLevelShorten[entry.l];
        return `${h}:${m} ${l}`;
    }
}


// =====================================================================================================================
// panels/log.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/demoColumns.js BEGIN
// =====================================================================================================================


class DemoColumns
{
    constructor(imgui)
    {
        this.imgui = imgui;
        this.names = [ "One", "Two", "Three" ];
        this.paths = [ "/path/one", "/path/two", "/path/three" ];
        this.selected = -1;
        this.foo = -1;
        this.bar = 1;
        this.h_borders = true;
        this.v_borders = true;
    }

    Show()
    {
        let imgui = this.imgui;

        if (!imgui.CollapsingHeader("Columns"))
            return;

        imgui.PushID("Columns");

        // Basic columns
        if (imgui.TreeNode("Basic"))
        {
            imgui.Text("Without border:");
            imgui.Columns(3, "mycolumns3", false);  // 3-ways, no border
            imgui.Separator();
            for (let n = 0; n < 14; n++)
            {
                let label = "Item " + n;
                if (imgui.Selectable(label)) {/*empty*/}
                //if (imgui.Button(label, ImVec2(-1,0))) {}
                imgui.NextColumn();
            }
            imgui.Columns(1);
            imgui.Separator();

            imgui.Text("With border:");
            imgui.Columns(4, "mycolumns"); // 4-ways, with border
            imgui.Separator();
            imgui.Text("ID"); imgui.NextColumn();
            imgui.Text("Name"); imgui.NextColumn();
            imgui.Text("Path"); imgui.NextColumn();
            imgui.Text("Hovered"); imgui.NextColumn();
            imgui.Separator();
            for (let i = 0; i < 3; i++)
            {
                let label = "000" + i;
                if (imgui.Selectable(label, this.selected == i, SelectableFlags.SpanAllColumns))
                    this.selected = i;
                let hovered = imgui.IsItemHovered();
                imgui.NextColumn();
                imgui.Text(this.names[i]); imgui.NextColumn();
                imgui.Text(this.paths[i]); imgui.NextColumn();
                imgui.Text("%d", hovered); imgui.NextColumn();
            }
            imgui.Columns(1);
            imgui.Separator();
            imgui.TreePop();
        }

        // Create multiple items in a same cell before switching to next column
        if (imgui.TreeNode("Mixed items"))
        {
            imgui.Columns(3, "mixed");
            imgui.Separator();

            imgui.Text("Hello");
            imgui.Button("Banana");
            imgui.NextColumn();

            imgui.Text("ImGui");
            imgui.Button("Apple");
            imgui.InputFloat("red", this.foo, 0.05, 0, "%.3f", 1,
                            (newval) => this.foo = newval);
            imgui.Text("An extra line here.");
            imgui.NextColumn();

            imgui.Text("Sailor");
            imgui.Button("Corniflower");
            imgui.InputFloat("blue", this.bar, 0.05, 0, "%.3f", 1,
                            (newval) => this.bar = newval);
            imgui.NextColumn();

            if (imgui.CollapsingHeader("Category A"))
                imgui.Text("Blah blah blah");
            imgui.NextColumn();
            if (imgui.CollapsingHeader("Category B"))
                imgui.Text("Blah blah blah");
            imgui.NextColumn();
            if (imgui.CollapsingHeader("Category C"))
                imgui.Text("Blah blah blah");
            imgui.NextColumn();
            imgui.Columns(1);
            imgui.Separator();
            imgui.TreePop();
        }

        // Word wrapping
        if (imgui.TreeNode("Word-wrapping"))
        {
            imgui.Columns(2, "word-wrapping");
            imgui.Separator();
            imgui.TextWrapped("The quick brown fox jumps over the lazy dog.");
            imgui.TextWrapped("Hello Left");
            imgui.NextColumn();
            imgui.TextWrapped("The quick brown fox jumps over the lazy dog.");
            imgui.TextWrapped("Hello Right");
            imgui.Columns(1);
            imgui.Separator();
            imgui.TreePop();
        }

        if (imgui.TreeNode("Borders"))
        {
            // NB: Future columns API should allow automatic horizontal borders.
            if(imgui.Checkbox("horizontal", this.h_borders))
                this.h_borders = !this.h_borders;
            imgui.SameLine();
            if(imgui.Checkbox("vertical", this.v_borders))
                this.v_borders = !this.v_borders;
            imgui.Columns(4, null, this.v_borders);
            for (let i = 0; i < 4*3; i++)
            {
                if (this.h_borders && imgui.GetColumnIndex() == 0)
                    imgui.Separator();
                let t = String.fromCharCode("a".charCodeAt(0)+i);
                imgui.Text(t, t, t);
                imgui.Text("Width %.2f\nOffset %.2f",
                        imgui.GetColumnWidth(), imgui.GetColumnOffset());
                imgui.NextColumn();
            }
            imgui.Columns(1);
            if (this.h_borders)
                imgui.Separator();
            imgui.TreePop();
        }

        // Scrolling columns
        /*
        if (imgui.TreeNode("Vertical Scrolling"))
        {
            imgui.BeginChild("##header", ImVec2(0, imgui.GetTextLineHeightWithSpacing()+imgui.GetStyle().ItemSpacing.y));
            imgui.Columns(3);
            imgui.Text("ID"); imgui.NextColumn();
            imgui.Text("Name"); imgui.NextColumn();
            imgui.Text("Path"); imgui.NextColumn();
            imgui.Columns(1);
            imgui.Separator();
            imgui.EndChild();
            imgui.BeginChild("##scrollingregion", ImVec2(0, 60));
            imgui.Columns(3);
            for (int i = 0; i < 10; i++)
            {
                imgui.Text("%04d", i); imgui.NextColumn();
                imgui.Text("Foobar"); imgui.NextColumn();
                imgui.Text("/path/foobar/%04d/", i); imgui.NextColumn();
            }
            imgui.Columns(1);
            imgui.EndChild();
            imgui.TreePop();
        }
        */

        if (imgui.TreeNode("Horizontal Scrolling"))
        {
            imgui.SetNextWindowContentSize(new Vec2(1500, 0.));
            imgui.BeginChild("##ScrollingRegion", new Vec2(0, imgui.GetFontSize() * 20),
                        false, WindowFlags.HorizontalScrollbar);
            imgui.Columns(10);
            let ITEMS_COUNT = 2000;
            let clipper = new ListClipper(imgui, ITEMS_COUNT);
            // Also demonstrate using the clipper for large list
            while (clipper.Step())
            {
                for (let i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
                {
                    for (let j = 0; j < 10; j++)
                    {
                        imgui.Text("Line %d Column %d...", i, j);
                        imgui.NextColumn();
                    }
                }
            }
            imgui.Columns(1);
            imgui.EndChild();
            imgui.TreePop();
        }

        let node_open = imgui.TreeNode("Tree within single cell");
        imgui.SameLine();
        imgui.Tooltip("NB: Tree node must be poped before ending the cell. There's no storage of state per-cell.");
        if (node_open)
        {
            imgui.Columns(2, "tree items");
            imgui.Separator();
            if (imgui.TreeNode("Hello"))
            {
                imgui.BulletText("Sailor");
                imgui.TreePop();
            }
            imgui.NextColumn();
            if (imgui.TreeNode("Bonjour"))
            {
                imgui.BulletText("Marin");
                imgui.TreePop();
            }
            imgui.NextColumn();
            imgui.Columns(1);
            imgui.Separator();
            imgui.TreePop();
        }
        imgui.PopID();
    }
}
// =====================================================================================================================
// panels/demoColumns.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/demo.js BEGIN
// =====================================================================================================================

/* global App */


class DemoWindow
{
    constructor()
    {
        // Examples App
        this.showAppDocuments = new ValRef(false);
        this.showAppMainMenuBar = new ValRef(false);
        this.showAppConsole = new ValRef(false);
        this.showAppLayout = new ValRef(false);
        this.showAppPropertyEditor = new ValRef(false);
        this.showAppLongText = new ValRef(false);
        this.showAppAutoResize = new ValRef(false);
        this.showAppConstrainedResize = new ValRef(false);
        this.showAppSimpleOverlay = new ValRef(false);
        this.showAppWindowTitles = new ValRef(false);
        this.showAppCustomRendering = new ValRef(false);
        this.showAppStyleEditor = new ValRef(false);
        this.showAppMetrics = new ValRef(false);
        this.showAppAbout = new ValRef(false);

        // Window Options
        this.noTitleBar = new ValRef(false);
        this.noScrollBar = new ValRef(false);
        this.noMenu = new ValRef(false);
        this.noMove = new ValRef(false);
        this.noResize = new ValRef(false);
        this.noCollapse = new ValRef(false);
        this.noNav = new ValRef(false);
        this.noBgd = new ValRef(false);
        this.noBringToFront = new ValRef(false);
        this.noClose = new ValRef(false);

        // misc
        this.counter = 0;

        // console.debug("imgui demo loaded");
    }

    Show(imgui, winname="imgui demo", isOpen=null)
    {
        if(isOpen != null && !isOpen.get()) return;
        let done = false;
        let winflags = this.getWinFlags();

        this.imgui = imgui;
        this.log = GetLog(imgui);
        if(!this.styleEditor)
        {
            this.styleEditor = new StyleEditor(imgui);
            this.demoWidgets = new DemoWidgets(imgui);
            this.demoLayout = new DemoLayout(imgui);
            this.demoPopups = new DemoPopups(imgui);
            this.demoColumns = new DemoColumns(imgui);
            this.customRendering = new DemoCustomRendering(imgui);
        }

        if(this.noClose.get())
            isOpen = null;

        this.showAppWindows(imgui);

        imgui.SetNextWindowPos(new Vec2(40, 40), CondFlags.FirstUseEver);
        imgui.SetNextWindowSize(new Vec2(500, 700), CondFlags.FirstUseEver);

        if(!imgui.Begin(winname, isOpen, winflags))
        {
            imgui.End();
            return done;
        }

        // Use fixed width for labels (by passing a negative value),
        // the rest goes to widgets. We choose a width proportional
        // to our font size.
        imgui.PushItemWidth(imgui.GetFontSize() * -12);
        if (imgui.Button("Button")) // Buttons return true when clicked
            this.counter++;
        imgui.SameLine();
        imgui.PushFont("monospace");
        imgui.Text(`counter=${this.counter}`);
        imgui.SameLine();
        let fps = imgui.GetIO().Framerate;
        let ms = (1000.0 / fps).toFixed(1);
        imgui.Text(`${fps.toFixed(0)} fps, ${ms} mspf`);
        let mouse = imgui.GetIO().MousePos;
        if(mouse.x != -Number.MAX_VALUE)
        {
            imgui.SameLine();
            imgui.Text(`mouse: ${mouse.x}, ${mouse.y}`);
        }
        imgui.PopFont();

        if(imgui.BeginMenuBar())
        {
            if(imgui.BeginMenu("File"))
            {
                done = ExampleFileMenu(imgui); // only done if quit
                imgui.EndMenu();
            }
            if (imgui.BeginMenu("Examples"))
            {
                imgui.MenuItem("Main menu bar", null, this.showAppMainMenuBar);
                imgui.MenuItem("Console", null, this.showAppConsole);
                imgui.MenuItem("Simple layout", null, this.showAppLayout);
                imgui.MenuItem("Property editor", null, this.showAppPropertyEditor);
                imgui.MenuItem("Long text display", null, this.showAppLongText);
                imgui.MenuItem("Auto-resizing window", null, this.showAppAutoResize);
                imgui.MenuItem("Constrained-resizing window", null, this.showAppConstrainedResize);
                imgui.MenuItem("Simple overlay", null, this.showAppSimpleOverlay);
                imgui.MenuItem("Manipulating window titles", null, this.showAppWindowTitles);
                imgui.MenuItem("Custom rendering", null, this.showAppCustomRendering);
                imgui.MenuItem("Documents", null, this.showAppDocuments);
                imgui.EndMenu();
            }
            if (imgui.BeginMenu("Help"))
            {
                imgui.MenuItem("Metrics", null, this.showAppMetrics);
                imgui.MenuItem("Style Editor", null, this.showAppStyleEditor);
                imgui.MenuItem("About imgui-njs", null, this.showAppAbout);
                imgui.EndMenu();
            }
            imgui.EndMenuBar();
        }
        imgui.Spacing();
        if(imgui.CollapsingHeader("Help"))
        {
            imgui.Indent();
            imgui.Text("PROGRAMMER GUIDE:");
            imgui.BulletText("make sure this is the right approach for you");
            imgui.BulletText("make sure it scales well enough");
            imgui.Unindent();
        }
        if (imgui.CollapsingHeader("Configuration"))
        {
            const io = imgui.GetIO();
            if (imgui.TreeNode("Configuration##2"))
            {
                let setConfigFlags = function(flags) { io.ConfigFlags = flags; };
                imgui.CheckboxFlags("io.ConfigFlags: NavEnableKeyboard",
                            io.ConfigFlags, ConfigFlags.NavEnableKeyboard,
                            setConfigFlags);
                imgui.CheckboxFlags("io.ConfigFlags: NavEnableGamepad",
                            io.ConfigFlags, ConfigFlags.NavEnableGamepad,
                            setConfigFlags);
                imgui.Tooltip("Required back-end to feed in gamepad inputs in "+
                            "io.NavInputs[] and set io.BackendFlags |= BackendFlags.HasGamepad.\n\n"+
                            "Read instructions in imgui.cpp for details.");
                imgui.CheckboxFlags("io.ConfigFlags: NavEnableSetMousePos",
                            io.ConfigFlags,  ConfigFlags.NavEnableSetMousePos,
                            setConfigFlags);
                imgui.Tooltip("Instruct navigation to move the mouse cursor. "+
                            "See comment for ImGuiConfigFlags_NavEnableSetMousePos.");
                imgui.CheckboxFlags("io.ConfigFlags: NoMouse",
                            io.ConfigFlags, ConfigFlags.NoMouse,
                            setConfigFlags);
                if (io.ConfigFlags & ConfigFlags.NoMouse)
                {
                    // Create a way to restore this flag otherwise we could be
                    // stuck completely!
                    if ((imgui.GetTime() % 0.40) < 0.20)
                    {
                        imgui.SameLine();
                        imgui.Text("<<PRESS SPACE TO DISABLE>>");
                    }
                    if (imgui.IsKeyPressed(imgui.GetKeyIndex(Key.Space)))
                        io.ConfigFlags &= ~ConfigFlags.NoMouse;
                }
                imgui.CheckboxFlags("io.ConfigFlags: NoMouseCursorChange",
                        io.ConfigFlags, ConfigFlags.NoMouseCursorChange,
                        setConfigFlags);
                imgui.Tooltip("Instruct back-end to not alter mouse cursor shape and visibility.");
                imgui.Checkbox("io.ConfigInputTextCursorBlink",
                        io.ConfigInputTextCursorBlink,
                        (v) => io.ConfigInputTextCursorBlink = v);
                imgui.Tooltip("Set to false to disable blinking cursor, for users who consider it distracting");
                imgui.Checkbox("io.ConfigWindowsResizeFromEdges [beta]",
                        io.ConfigWindowsResizeFromEdges,
                        (v) => io.ConfigWindowsResizeFromEdges = v);
                imgui.Tooltip("Enable resizing of windows from their edges and from the lower-left corner.\nThis requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback.");
                imgui.Checkbox("io.ConfigWindowsMoveFromTitleBarOnly",
                        io.ConfigWindowsMoveFromTitleBarOnly,
                        (v) => io.ConfigWindowsMoveFromTitleBarOnly = v);
                imgui.Checkbox("io.MouseDrawCursor",
                        io.MouseDrawCursor,
                        (v) => io.MouseDrawCursor = v);
                imgui.Tooltip("Instruct Dear ImGui to render a mouse cursor for you. Note that a mouse cursor rendered via your application GPU rendering path will feel more laggy than hardware cursor, but will be more in sync with your other visuals.\n\nSome desktop applications may use both kinds of cursors (e.g. enable software cursor only when resizing/dragging something).");
                imgui.TreePop();
                imgui.Separator();
            }
            if (imgui.TreeNode("Backend Flags"))
            {
                let backend_flags = io.BackendFlags; // Make a local copy to avoid modifying the back-end flags.
                imgui.CheckboxFlags("io.BackendFlags: HasGamepad",
                                    backend_flags, BackendFlags.HasGamepad,
                                    (v) => io.BackendFlags = v);
                imgui.CheckboxFlags("io.BackendFlags: HasMouseCursors",
                                    backend_flags, BackendFlags.HasMouseCursors,
                                    (v) => io.BackendFlags = v);
                imgui.CheckboxFlags("io.BackendFlags: HasSetMousePos",
                                    backend_flags, BackendFlags.HasSetMousePos,
                                    (v) => io.BackendFlags = v);
                imgui.TreePop();
                imgui.Separator();
            }
            if (imgui.TreeNode("Style"))
            {
                this.styleEditor.Show();
                imgui.TreePop();
                imgui.Separator();
            }
            if (imgui.TreeNode("Capture/Logging"))
            {
                imgui.TextWrapped("The logging API redirects all text output so you can easily "+
                    "capture the content of a window or a block. Tree nodes can be automatically expanded.");
                imgui.Tooltip("Try opening any of the contents below in this window and then click one of the \"Log To\" button.");
                imgui.LogButtons();
                imgui.TextWrapped("You can also call ImGui.LogText() to output directly to the log without a visual output.");
                if (imgui.Button("Copy \"Hello, world!\" to clipboard")) {
                    imgui.LogToClipboard();
                    imgui.LogText("Hello, world!");
                    imgui.LogFinish();
                }
                imgui.TreePop();
            }
        }
        if(imgui.CollapsingHeader("Window options"))
        {
            imgui.Checkbox("No titlebar", this.noTitleBar);
            imgui.SameLine(150);
            imgui.Checkbox("No scrollbar", this.noScrollBar);
            imgui.SameLine(300);
            imgui.Checkbox("No menu", this.noMenu);
            imgui.Checkbox("No move", this.noMove);
            imgui.SameLine(150);
            imgui.Checkbox("No resize", this.noResize);
            imgui.SameLine(300);
            imgui.Checkbox("No collapse", this.noCollapse);
            imgui.Checkbox("No close", this.noClose);
            imgui.SameLine(150);
            imgui.Checkbox("No nav", this.noNav);
            imgui.SameLine(300);
            imgui.Checkbox("No background", this.noBgd);
            imgui.Checkbox("No bring to front", this.noBringToFront);
        }

        this.demoWidgets.Show();
        this.demoLayout.Show();
        this.demoPopups.Show();
        this.demoColumns.Show();

        imgui.End();
        return done;
    }

    showAppWindows(imgui)
    {
        if(this.showAppDocuments.get())
            ;
        if(this.showAppMainMenuBar.get())
            ;
        if(this.showAppConsole.get())
            ;

        // not our job to show the log, just toggle it

        if(this.showAppLayout.get())
            DemoSimpleLayout(imgui, this.showAppLayout);
        if(this.showAppPropertyEditor.get())
            DemoPropertyEditor(imgui, this.showAppPropertyEditor);
        if(this.showAppLongText.get())
            ;
        if(this.showAppAutoResize.get())
            ;
        if(this.showAppConstrainedResize.get())
            ;
        if(this.showAppSimpleOverlay.get())
            this.showSimpleOverlay(this.showAppSimpleOverlay);

        if(this.showAppWindowTitles.get())
            ;
        if(this.showAppCustomRendering.get())
        {
            this.customRendering.Show(this.showAppCustomRendering);
        }
        if(this.showAppStyleEditor.get())
            ;
        if(this.showAppMetrics.get())
            ;
        if(this.showAppAbout.get())
           this.showAboutWindow();
    }

    getWinFlags()
    {
        let winflags = 0;
        if(this.noTitleBar.get())
            winflags |= WindowFlags.NoTitleBar;
        if(this.noScrollBar.get())
            winflags |= WindowFlags.NoScrollbar;
        if(!this.noMenu.get())
            winflags |= WindowFlags.MenuBar;
        if(this.noResize.get())
            winflags |= WindowFlags.NoResize;
        if(this.noCollapse.get())
            winflags |= WindowFlags.NoCollapse;
        if(this.noNav.get())
            winflags |= WindowFlags.NoNav;
        if(this.noBgd.get())
            winflags |= WindowFlags.NoBackground;
        if(this.noBringToFront.get())
            winflags |= WindowFlags.NoBringToFrontOnFocus;
        return winflags;
    }

    showAboutWindow()
    {
        let imgui = this.imgui;
        if (!imgui.Begin("About imgui-njs", this.showAppAbout,
                WindowFlags.AlwaysAutoResize |
                WindowFlags.NoCollapse))
        {
            imgui.End();
            return;
        }
        imgui.Text(imgui.GetVersion());
        imgui.Separator();
        imgui.Text("imgui-njs by Dana Batali, built atop:");
        imgui.Text("dear-imgui by Omar Cornut and all dear imgui contributors.");
        imgui.Text("Both are licensed under the MIT License.");
        imgui.End();
    }

    showSimpleOverlay(p_open)
    {
        const DISTANCE = 10;
        if(!this._corner)
            this._corner = 0;
        const imgui = this.imgui;
        const io = imgui.GetIO();
        if (this._corner != -1)
        {
            let window_pos = new Vec2(
                    (this._corner & 1) ? io.DisplaySize.x - DISTANCE : DISTANCE,
                    (this._corner & 2) ? io.DisplaySize.y - DISTANCE : DISTANCE);
            let window_pos_pivot = new Vec2(
                    (this._corner & 1) ? 1 : 0,
                    (this._corner & 2) ? 1 : 0);
            imgui.SetNextWindowPos(window_pos, CondFlags.Always, window_pos_pivot);
        }
        imgui.SetNextWindowBgAlpha(0.35);
        if (imgui.Begin("Example: Simple overlay", p_open,
            (this._corner != -1 ? WindowFlags.NoMove : 0) |
                WindowFlags.NoDecoration |
                WindowFlags.AlwaysAutoResize |
                WindowFlags.NoSavedSettings |
                WindowFlags.NoFocusOnAppearing |
                WindowFlags.NoNav))
        {
            imgui.Text("Simple overlay\n" +
                    "in the corner of the screen.\n" +
                    "(right-click to change position)");
            imgui.Separator();
            if (imgui.IsMousePosValid())
                imgui.Text("Mouse Position: (%.1f,%.1f)", io.MousePos.x, io.MousePos.y);
            else
                imgui.Text("Mouse Position: <invalid>");
            if (imgui.BeginPopupContextWindow())
            {
                if (imgui.MenuItem("Custom", null, this._corner == -1))
                    this._corner = -1;
                if (imgui.MenuItem("Top-left", null, this._corner == 0))
                    this._corner = 0;
                if (imgui.MenuItem("Top-right", null, this._corner == 1))
                    this._corner = 1;
                if (imgui.MenuItem("Bottom-left",  null, this._corner == 2))
                    this._corner = 2;
                if (imgui.MenuItem("Bottom-right", null, this._corner == 3))
                    this._corner = 3;
                if (p_open.get() && imgui.MenuItem("Close"))
                    p_open.set(false);
                imgui.EndPopup();
            }
        }
        imgui.End();
    }
}


// =====================================================================================================================
// panels/demo.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/demoPropertyEditor.js BEGIN
// =====================================================================================================================


// Demonstrate create a simple property editor.
let dummy_members = [0, 0, 1, 3.1416, 100, 999, 0, 0];
function DemoPropertyEditor(imgui, p_open=null)
{
    imgui.SetNextWindowSize(new Vec2(430,450), CondFlags.FirstUseEver);
    if (!imgui.Begin("Example: Property editor", p_open))
    {
        imgui.End();
        return;
    }

    imgui.Tooltip("This example shows how you may implement a property editor "+
                "using two columns.\nAll objects/fields data are dummies here.\n"+
                "Remember that in many simple cases, you can use "+
                "imgui.SameLine(xxx) to position\nyour cursor horizontally "+
                "instead of using the Columns() API.");

    imgui.PushStyleVar("FramePadding", new Vec2(2,2));
    imgui.Columns(2);
    imgui.Separator();

    let ShowDummyObject = function(prefix, uid)
    {
        // Use object uid as identifier. Most commonly you could also use
        // the object pointer as a base ID.
        imgui.PushID(uid);

        // Text and Tree nodes are less high than regular widgets, here we
        // add vertical spacing to make the tree lines equal high.
        imgui.AlignTextToFramePadding();

        let node_open = imgui.TreeNode("Object", "%s_%u", prefix, uid);
        imgui.NextColumn();
        imgui.AlignTextToFramePadding();
        imgui.Text("my sailor is rich");
        imgui.NextColumn();
        if (node_open)
        {
            for (let i = 0; i < 8; i++)
            {
                imgui.PushID(i); // Use field index as identifier.
                if (i < 2)
                    ShowDummyObject("Child", 424242);
                else
                {
                    // Here we use a TreeNode to highlight on hover (we could
                    // use e.g. Selectable as well)
                    imgui.AlignTextToFramePadding();
                    imgui.TreeNodeEx("Field",
                                TreeNodeFlags.Leaf|
                                TreeNodeFlags.NoTreePushOnOpen|
                                TreeNodeFlags.Bullet,
                                "Field_%d", i);
                    imgui.NextColumn();
                    imgui.SetNextItemWidth(-1);
                    if (i >= 5)
                    {
                        imgui.InputFloat("##value", dummy_members[i], 1, 1, null, 0,
                             (newval) => dummy_members[i] = newval);
                    }
                    else
                    {
                        imgui.DragFloat("##value", dummy_members[i], .01, 0, 0, null, 1,
                                        (newval) => dummy_members[i] = newval);
                    }
                    imgui.NextColumn();
                }
                imgui.PopID();
            }
            imgui.TreePop();
        }
        imgui.PopID();
    };

    // Iterate dummy objects with dummy members (all the same data)
    for (let obj_i = 0; obj_i < 3; obj_i++)
        ShowDummyObject("Object", obj_i);

    imgui.Columns(1);
    imgui.Separator();
    imgui.PopStyleVar();
    imgui.End();
}
// =====================================================================================================================
// panels/demoPropertyEditor.js END
// =====================================================================================================================
// =====================================================================================================================
// panels/demoCustomRendering.js BEGIN
// =====================================================================================================================


class DemoCustomRendering
{
    constructor(imgui)
    {
        this.imgui = imgui;
    }

    Show(p_open=null)
    {
        let imgui = this.imgui;
        imgui.SetNextWindowSize(new Vec2(350, 560), CondFlags.FirstUseEver);
        if (!imgui.Begin("Example: Custom rendering", p_open))
        {
            imgui.End();
            return;
        }

        // Tip: If you do a lot of custom rendering, you probably want to use
        // your own geometrical types and benefit of overloaded operators, etc.
        // ImGui defines overloaded operators but they are internal to imgui.cpp
        // and not exposed outside (to avoid messing with your types)
        // In this example we are not using the maths operators!
        let drawlist = imgui.GetWindowDrawList();
        if (imgui.BeginTabBar("##TabBar"))
        {
            // Primitives
            if(this._sz == undefined)
            {
                this._sz = 36;
                this._thickness = 4;
                this._col = Color.rgba(1., 1., 0.4, 1.);
                this._points = new ArrayEx();
                this._addingLine = false;
            }
            if (imgui.BeginTabItem("Primitives"))
            {
                imgui.DragFloat("Size", this._sz, 0.2, 2., 100., "%f",1,
                                (newval)=>this._sz=newval);
                imgui.DragFloat("Thickness", this._thickness, 0.05, 1., 8, "%.2f", 1,
                                (newval)=>this._thickness=newval);
                imgui.ColorEdit4("Color", this._col);
                const p = imgui.GetCursorScreenPos();
                let x = p.x + 4;
                let y = p.y + 4;
                let spacing = 8;
                let sz = this._sz;
                for (let n = 0; n < 2; n++)
                {
                    // First line uses a thickness of 1.0, second line uses the
                    // configurable thickness
                    let th = (n == 0) ? 1 : this._thickness;
                    drawlist.AddCircle(new Vec2(x + sz*.5, y + sz*.5),
                                        sz*0.5, this._col, th);
                    x += sz + spacing;
                    drawlist.AddCircle(new Vec2(x + sz*.5, y + sz*.5),
                                        sz*0.5, this._col, th);
                    x += sz + spacing;  // Circle
                    drawlist.AddRect(new Vec2(x, y), new Vec2(x + sz, y + sz),
                                    this._col, 0,  CornerFlags.All, th);
                    x += sz + spacing;
                    drawlist.AddRect(new Vec2(x, y), new Vec2(x + sz, y + sz),
                                    this._col, 10, CornerFlags.All, th);
                    x += sz + spacing;
                    drawlist.AddRect(new Vec2(x, y), new Vec2(x + sz, y + sz),
                                    this._col, 10, CornerFlags.TopLeft |
                                                    CornerFlags.BotRight, th);
                    x += sz + spacing;
                    drawlist.AddTriangle(new Vec2(x + sz*.5, y),
                                         new Vec2(x + sz, y + sz - .5),
                                         new Vec2(x, y + sz - .5),
                                         this._col, th);
                    x += sz + spacing;
                    drawlist.AddLine(new Vec2(x, y), new Vec2(x + sz, y),
                                    this._col, th);
                    x += sz + spacing; // Horizontal line (note: drawing a filled rectangle will be faster!)
                    drawlist.AddLine(new Vec2(x, y), new Vec2(x, y + sz),
                                     this._col, th);
                    x += spacing; // Vertical line (note: drawing a filled rectangle will be faster!)
                    drawlist.AddLine(new Vec2(x, y), new Vec2(x + sz, y + sz),
                                    this._col, th);
                    x += sz + spacing;             // Diagonal line
                    drawlist.AddBezierCurve(new Vec2(x, y),
                                new Vec2(x + sz*1.3, y + sz*0.3),
                                new Vec2(x + sz - sz*1.3,
                                y + sz - sz*0.3),
                                new Vec2(x + sz, y + sz),
                                this._col, th);
                    x = p.x + 4;
                    y += sz + spacing;
                }
                drawlist.AddCircleFilled(new Vec2(x + sz*0.5, y + sz*0.5), sz*0.5,
                                        this._col, 6);
                x += sz + spacing;     // Hexagon
                drawlist.AddCircleFilled(new Vec2(x + sz*0.5, y + sz*0.5), sz*0.5,
                                        this._col, 32);
                x += sz + spacing;    // Circle
                drawlist.AddRectFilled(new Vec2(x, y), new Vec2(x + sz, y + sz),
                                        this._col);
                x += sz + spacing;
                drawlist.AddRectFilled(new Vec2(x, y), new Vec2(x + sz, y + sz),
                                        this._col, 10.);
                x += sz + spacing;
                drawlist.AddRectFilled(new Vec2(x, y), new Vec2(x + sz, y + sz),
                                        this._col, 10,
                                        CornerFlags.TopLeft | CornerFlags.BotRight);
                x += sz + spacing;
                drawlist.AddTriangleFilled(new Vec2(x + sz*.5, y),
                                           new Vec2(x + sz, y + sz - .5),
                                           new Vec2(x, y + sz - .5),
                                           this._col);
                x += sz + spacing;
                drawlist.AddRectFilled(new Vec2(x, y),
                                       new Vec2(x + sz, y + this._thickness),
                                       this._col);
                x += sz + spacing; // Horizontal line (faster than AddLine, but only handle integer thickness)
                drawlist.AddRectFilled(new Vec2(x, y),
                                        new Vec2(x + this._thickness, y + sz),
                                        this._col);
                x += spacing + spacing;   // Vertical line (faster than AddLine, but only handle integer thickness)
                drawlist.AddRectFilled(new Vec2(x, y), new Vec2(x + 1, y + 1),
                                        this._col);
                x += sz;                  // Pixel (faster than AddLine)
                drawlist.AddRectFilledMultiColor(new Vec2(x, y), new Vec2(x + sz, y + sz),
                            Color.rgbi(0, 0, 0),
                            Color.rgbi(255, 0, 0),
                            Color.rgbi(255, 0, 0),
                            Color.rgbi(0, 0, 0));
                imgui.Dummy(new Vec2((sz + spacing) * 9.5, (sz + spacing) * 3));
                imgui.EndTabItem();
            }

            if (imgui.BeginTabItem("Canvas"))
            {
                if (imgui.Button("Clear"))
                    this._points.clear();
                if (this._points.length >= 2)
                {
                    imgui.SameLine();
                    if (imgui.Button("Undo"))
                    {
                        this._points.pop_back();
                        this._points.pop_back();
                    }
                }
                imgui.Text("Left-click and drag to add lines,\nRight-click to undo");

                // Here we are using InvisibleButton() as a convenience to
                //  1) advance the cursor and
                //  2) allows us to use IsItemHovered()
                // But you can also draw directly and poll mouse/keyboard by
                // yourself. You can manipulate the cursor using GetCursorPos()
                // and SetCursorPos().
                // If you only use the ImDrawList API, you can notify the
                // owner window of its extends by using SetCursorPos(max).
                // ImDrawList API uses screen coordinates!
                const canvas_pos = imgui.GetCursorScreenPos();
                // Resize canvas to what's available
                let canvas_size = imgui.GetContentRegionAvail().Clone();
                if (canvas_size.x < 50) canvas_size.x = 50;
                if (canvas_size.y < 50) canvas_size.y = 50;
                drawlist.AddRectFilledMultiColor(canvas_pos,
                        new Vec2(canvas_pos.x + canvas_size.x,
                                 canvas_pos.y + canvas_size.y),
                        Color.rgbi(50, 50, 50),
                        Color.rgbi(50, 50, 50),
                        Color.rgbi(60, 60, 80),
                        Color.rgbi(60, 60, 80));
                drawlist.AddRect(canvas_pos,
                        new Vec2(canvas_pos.x + canvas_size.x,
                                 canvas_pos.y + canvas_size.y),
                                 Colors.gray);
                let adding_preview = false;
                imgui.InvisibleButton("canvas", canvas_size);
                let mouse_pos_in_canvas = new Vec2(imgui.GetIO().MousePos.x - canvas_pos.x,
                                                   imgui.GetIO().MousePos.y - canvas_pos.y);
                if (this._addingLine)
                {
                    adding_preview = true;
                    this._points.push_back(mouse_pos_in_canvas);
                    if (!imgui.IsMouseDown(0))
                        this._addingLine = adding_preview = false;
                }
                if (imgui.IsItemHovered())
                {
                    if (!this._addingLine && imgui.IsMouseClicked(0))
                    {
                        this._points.push_back(mouse_pos_in_canvas);
                        this._addingLine = true;
                    }
                    if (imgui.IsMouseClicked(1) && !this._points.empty())
                    {
                        this._addingLine = adding_preview = false;
                        this._points.pop_back();
                        this._points.pop_back();
                    }
                }
                // clip lines within the canvas (if we resize it, etc.)
                drawlist.PushClipRect(canvas_pos,
                            new Vec2(canvas_pos.x + canvas_size.x,
                                     canvas_pos.y + canvas_size.y),
                                     true);
                for (let i = 0; i < this._points.length - 1; i += 2)
                {
                    drawlist.AddLine(new Vec2(canvas_pos.x + this._points[i].x,
                                              canvas_pos.y + this._points[i].y),
                                    new Vec2(canvas_pos.x + this._points[i + 1].x,
                                             canvas_pos.y + this._points[i + 1].y),
                                    this._col, this._thickness);
                }
                drawlist.PopClipRect();
                if (adding_preview)
                    this._points.pop_back();
                imgui.EndTabItem();
            }

            if (imgui.BeginTabItem("BG/FG draw lists"))
            {
                imgui.Text("currently unimplemented");
                /*
                static bool draw_bg = true;
                static bool draw_fg = true;
                imgui.Checkbox("Draw in Background draw list", &draw_bg);
                imgui.Checkbox("Draw in Foreground draw list", &draw_fg);
                ImVec2 window_pos = imgui.GetWindowPos();
                ImVec2 window_size = imgui.GetWindowSize();
                ImVec2 window_center = ImVec2(window_pos.x + window_size.x * 0.5f, window_pos.y + window_size.y * 0.5f);
                if (draw_bg)
                    imgui.GetBackgroundDrawList()->AddCircle(window_center, window_size.x * 0.6f, IM_COL32(255, 0, 0, 200), 32, 10+4);
                if (draw_fg)
                    imgui.GetForegroundDrawList()->AddCircle(window_center, window_size.y * 0.6f, IM_COL32(0, 255, 0, 200), 32, 10);
                */
                imgui.EndTabItem();
            }

            imgui.EndTabBar();
        }

        imgui.End();
    } // end Show
}
// =====================================================================================================================
// panels/demoCustomRendering.js END
// =====================================================================================================================
// =====================================================================================================================
// mixins.js BEGIN
// =====================================================================================================================



// Our job is to compose extra files' worth of methods for the
// (gigantic) ImgGui class.
class ImguiMixins
{
    constructor()
    {
    }
}

let mixins = [
    // support for internal/provate methods
    ImguiDragDropMixin,
    ImguiLoggingMixin,
    ImguiMiscMixin,
    ImguiNavMixin,
    ImguiRenderMixin,
    ImguiSettingsMixin,
    ImguiWinMgrMixin,

    // external widget support
    ImguiButtonMixin,
    ImguiColorEditMixin,
    ImguiColorPickerMixin,
    ImguiColumnMixin,
    ImguiComboMixin,
    ImguiDragMixin,
    ImguiInputMixin,
    ImguiLayoutMixin,
    ImguiListboxMixin,
    ImguiMenuMixin,
    ImguiPopupMixin,
    ImguiPlotMixin,
    ImguiScrollbarMixin,
    ImguiSelectableMixin,
    ImguiSliderMixin,
    ImguiTabBarMixin,
    ImguiTextMixin,
    ImguiTooltipMixin,
    ImguiTreeMixin,
];

for(let m of mixins)
    Object.assign(ImguiMixins.prototype, m);

// =====================================================================================================================
// mixins.js END
// =====================================================================================================================
// =====================================================================================================================
// imgui.js BEGIN
// =====================================================================================================================


/**
 * immediate-mode gui for html5 canvas interface follows
 * dear-imgui.
 */
class Imgui extends ImguiMixins
{
    // we require a subset of 'navigator' interface: 
    //      platform, 
    //      clipboard.writeText, clipboard.readText
    constructor(canvas, appname="imgui-njs", appServices=navigator)
    {
        super();
        this.debug = true;
        if(!this.debug)
            console.assert = function() {};
        this.version = "0.1.0";
        this.version_imgui = "1.70 WIP";
        this.about = `imgui-njs: ${this.version}, dear-imgui: ${this.version_imgui}`;
        this.canvas = canvas;
        this.guictx = new GuiContext(this, canvas, appname);
        this.appServices = appServices; 
        this.Initialized = true;
    }

    // Main --------------
    /**
     * access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
     */
    GetIO()
    {
        return this.guictx.IO;
    }

    /** access the Style structure (colors, sizes). Always use PushStyleCol(),
     * PushStyleVar() to modify style mid-frame.
     */
    GetStyle()
    {
        return this.guictx.Style;
    }

    GetStyleFont(nm)
    {
        return this.guictx.Style.GetFont(nm);
    }

    /** 
     * Start a new ImGui frame, you can submit any command from this point
     * until Render()/EndFrame().  Returns an experimental value that can
     * be used to bypass redraw. 
     */
    NewFrame(time)
    {
        let g = this.guictx;

        // g.NewFrame must happen before we reset volatile state
        //  (like MouseCursor)
        g.NewFrame(time); // aka g.IO.Newframe

        // Check user data
        // (We pass an error message in the assert expression to make it
        // visible to programmers who are not using a debugger, as most
        // assert handlers display their argument)
        if(this.debug)
        {
            console.assert(g.Initialized);
            console.assert(g.IO.DeltaTime > 0 || g.FrameCount == 0); // Need a positive DeltaTime!
            console.assert(g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount);  // Forgot to call Render() or EndFrame() at the end of the previous frame?
            console.assert(g.IO.DisplaySize.x >= 0 && g.IO.DisplaySize.y >= 0);  // Invalid DisplaySize value!
            console.assert(g.IO.Fonts.Size() > 0); // Font Atlas not built.
            console.assert(g.Style.CurveTessellationTol > 0); // Invalid style setting!
            console.assert(g.Style.Alpha >= 0. && g.Style.Alpha <= 1);//  Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)
            console.assert(g.Style.WindowMinSize.x >= 1. && g.Style.WindowMinSize.y >= 1.); // Invalid style setting.
            for (let n = 0; n < g.IO.KeyMap.length; n++)
                console.assert(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < g.IO.KeysDown.length); // io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)

            // Perform simple check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)
            if (g.IO.ConfigFlags & ConfigFlags.NavEnableKeyboard)
                console.assert(g.IO.KeyMap[Key.Space]); // Key.Space is not mapped, required for keyboard navigation.
        }

        // Perform simple check: the beta io.ConfigWindowsResizeFromEdges option requires back-end to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
        if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & BackendFlags.HasMouseCursors))
            g.IO.ConfigWindowsResizeFromEdges = false;

        // Load settings on first frame (if not explicitly loaded manually before)
        if (!g.SettingsLoaded)
        {
            console.assert(g.SettingsWindows.length == 0);
            if (g.IO.IniFilename)
                this.LoadIniSettingsFromDisk(g.IO.IniFilename);
            g.SettingsLoaded = true;
        }

        // Save settings (with a delay after the last modification, so we don't
        // spam disk too much)
        if (g.SettingsDirtyTimer > 0.)
        {
            g.SettingsDirtyTimer -= g.IO.DeltaTime;
            if (g.SettingsDirtyTimer <= 0)
            {
                if (g.IO.IniFilename)
                    this.SaveIniSettingsToDisk(g.IO.IniFilename);
                else
                {
                    // Let user know they can call SaveIniSettingsToMemory().
                    // user will need to clear io.WantSaveIniSettings themselves.
                    g.IO.WantSaveIniSettings = true;
                }
                g.SettingsDirtyTimer = 0.;
            }
        }

        g.Time += g.IO.DeltaTime;
        g.FrameScopeActive = true;
        g.FrameCount += 1;
        g.TooltipOverrideCount = 0;
        g.WindowsActiveCount = 0;

        // Setup current font and draw list shared data
        g.IO.Fonts.Locked = true;
        this.SetFont(this.getDefaultFont());
        console.assert(g.Font.IsLoaded());

        // g.BackgroundDrawList.Clear();
        // g.BackgroundDrawList.PushTextureID(g.IO.Fonts.TexID);
        // g.BackgroundDrawList.PushClipRectFullScreen();
        // g.BackgroundDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

        // g.ForegroundDrawList.Clear();
        // g.ForegroundDrawList.PushTextureID(g.IO.Fonts.TexID);
        // g.ForegroundDrawList.PushClipRectFullScreen();
        // g.ForegroundDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

        // Drag and drop keep the source ID alive so even if the source disappear
        // our state is consistent
        if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
            this.keepAliveID(g.DragDropPayload.SourceId);

        // Clear reference to active widget if the widget isn't alive anymore
        if (!g.HoveredIdPreviousFrame)
            g.HoveredIdTimer = 0;
        if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
            g.HoveredIdNotActiveTimer = 0;
        if (g.HoveredId)
            g.HoveredIdTimer += g.IO.DeltaTime;
        if (g.HoveredId && g.ActiveId != g.HoveredId)
            g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
        g.HoveredIdPreviousFrame = g.HoveredId;
        g.HoveredId = 0;
        g.HoveredIdAllowOverlap = false;
        if (g.ActiveIdIsAlive != g.ActiveId &&
            g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)
        {
            this.clearActiveID();
        }
        if (g.ActiveId)
            g.ActiveIdTimer += g.IO.DeltaTime;
        g.LastActiveIdTimer += g.IO.DeltaTime;
        g.ActiveIdPreviousFrame = g.ActiveId;
        g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
        g.ActiveIdPreviousFrameHasBeenEdited = g.ActiveIdHasBeenEdited;
        g.ActiveIdIsAlive = 0;
        g.ActiveIdPreviousFrameIsAlive = false;
        g.ActiveIdIsJustActivated = false;
        if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)
            g.ScalarAsInputTextId = 0;

        // Drag and drop
        g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
        g.DragDropAcceptIdCurr = 0;
        g.DragDropAcceptIdCurrRectSurface = Number.MAX_VALUE;
        g.DragDropWithinSourceOrTarget = false;

        // Update keyboard input state
        g.IO.KeysDownDurationPrev = g.IO.KeysDownDuration.slice(); // copy
        for (let i = 0; i < g.IO.KeysDown.length; i++)
        {
            g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ?
                (g.IO.KeysDownDuration[i] < 0 ? 0 :
                    g.IO.KeysDownDuration[i] + g.IO.DeltaTime)
                : -1;
        }

        // Update gamepad/keyboard directional navigation
        this.navUpdate();

        // Calculate frame-rate for the user, as a purely luxurious feature
        g.FramerateSecPerFrameAccum += g.IO.DeltaTime -
                        g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
        g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
        g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % g.FramerateSecPerFrame.length;
        g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0) ?
                (1 / (g.FramerateSecPerFrameAccum / g.FramerateSecPerFrame.length))
                : Number.MAX_VALUE;

        // Handle user moving window with mouse (at the beginning of the frame
        // to avoid input lag or sheering)
        this.updateMouseMovingWindowNewFrame();
        this.updateHoveredWindowAndCaptureFlags();

        // Background darkening/whitening
        if (this.getFrontMostPopupModal() ||
            (g.NavWindowingTarget && g.NavWindowingHighlightAlpha > 0))
        {
            g.DimBgRatio = Math.min(g.DimBgRatio + g.IO.DeltaTime * 6.0, 1.0);
        }
        else
            g.DimBgRatio = Math.max(g.DimBgRatio - g.IO.DeltaTime * 10, 0.);

        g.MouseCursor = MouseCursor.Arrow; // NewFrame
        g.WantCaptureMouseNextFrame = -1;
        g.WantCaptureKeyboardNextFrame = -1;
        g.WantTextInputNextFrame = -1;
        // OS Input Method Editor showing on top-left of our window by default
        g.PlatformImePos = new Vec2(1.0, 1.);

        // Mouse wheel scrolling, scale
        this.updateMouseWheel();

        // Pressing TAB activate widget focus
        g.FocusTabPressed = (g.NavWindow && g.NavWindow.Active &&
                !(g.NavWindow.Flags & WindowFlags.NoNavInputs) &&
                !g.IO.KeyCtrl && this.isKeyPressedMap(Key.Tab));
        if (g.ActiveId == 0 && g.FocusTabPressed)
        {
            // Note that SetKeyboardFocusHere() sets the Next fields mid-frame.
            // To be consistent we also  manipulate the Next fields even, even
            // though they will be turned into Curr fields by the code below.
            g.FocusRequestNextWindow = g.NavWindow;
            g.FocusRequestNextCounterAll = Number.MAX_SAFE_INTEGER;
            if (g.NavId != 0 && g.NavIdTabCounter != Number.MAX_SAFE_INTEGER)
                g.FocusRequestNextCounterTab = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);
            else
                g.FocusRequestNextCounterTab = g.IO.KeyShift ? -1 : 0;
        }

        // Turn queued focus request into current one
        g.FocusRequestCurrWindow = null;
        g.FocusRequestCurrCounterAll = Number.MAX_SAFE_INTEGER;
        g.FocusRequestCurrCounterTab = Number.MAX_SAFE_INTEGER;
        if (g.FocusRequestNextWindow != null)
        {
            let win = g.FocusRequestNextWindow;
            g.FocusRequestCurrWindow = win;
            if (g.FocusRequestNextCounterAll != Number.MAX_SAFE_INTEGER &&
                win.DC.FocusCounterAll != -1)
            {
                g.FocusRequestCurrCounterAll = this.modPositive(g.FocusRequestNextCounterAll,
                                                    win.DC.FocusCounterAll+1);
            }
            if (g.FocusRequestNextCounterTab != Number.MAX_SAFE_INTEGER &&
                win.DC.FocusCounterTab != -1)
            {
                g.FocusRequestCurrCounterTab = this.modPositive(g.FocusRequestNextCounterTab,
                                                    win.DC.FocusCounterTab+1);
            }
            g.FocusRequestNextWindow = null;
            g.FocusRequestNextCounterAll = Number.MAX_SAFE_INTEGER;
            g.FocusRequestNextCounterTab = Number.MAX_SAFE_INTEGER;
        }

        g.NavIdTabCounter = Number.MAX_SAFE_INTEGER;

        // Mark all windows as not visible
        console.assert(g.WindowsFocusOrder.Size == g.Windows.Size);
        for (let i=0; i < g.Windows.length; i++)
        {
            let win = g.Windows[i];
            win.WasActive = win.Active;
            win.BeginCount = 0;
            win.Active = false;
            win.WriteAccessed = false;
        }

        // Closing the focused window restore focus to the first active root window in descending z-order
        if (g.NavWindow && !g.NavWindow.WasActive)
            this.focusPreviousWindowIgnoringOne(null);

        // No window should be open at the beginning of the frame.
        // But in order to allow the user to call NewFrame() multiple
        // times without calling Render(), we are doing an explicit clear.
        g.CurrentWindowStack.resize(0);
        g.BeginPopupStack.resize(0);
        this.closePopupsOverWindow(g.NavWindow);

        // Create implicit/fallback window - which we will only render it if
        // the user has added something to it.
        // We don't use "Debug" to avoid colliding with user trying to create
        // a "Debug" window with custom flags. This fallback is particularly
        // important as it avoid ImGui:: calls from crashing.
        this.SetNextWindowSize(new Vec2(400,400), CondFlags.FirstUseEver);
        this.Begin("Debug##Default", null, WindowFlags.NoSavedSettings);
        g.FrameScopePushedImplicitWindow = true;


        return this.GetIO().Dirty;
    }

    /** end the ImGui frame. automatically called by Render(), you likely
     * don't need to call that yourself directly. If you don't need to render
     * data (skipping rendering) you may call EndFrame() but you'll have wasted
     * CPU already! If you don't need to render, better to not create any imgui
     * windows and not call NewFrame() at all!
     */
    EndFrame()
    {
        let g = this.guictx;
        console.assert(g.Initialized);
        if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.
            return;
        console.assert(g.FrameScopeActive);  // Forgot to call ImGui::NewFrame()?

        // Notify OS when our Input Method Editor cursor has moved (e.g. CJK
        // inputs using Microsoft IME)
        if (g.IO.ImeSetInputScreenPosFn && (g.PlatformImeLastPos.x == Number.MAX_VALUE ||
            Vec2.Subtract(g.PlatformImeLastPos, g.PlatformImePos).LengthSq() > 0.0001))
        {
            g.IO.ImeSetInputScreenPosFn(Math.floor(g.PlatformImePos.x),
                                        Math.floor(g.PlatformImePos.y));
            g.PlatformImeLastPos = g.PlatformImePos;
        }

        // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls.
        // Important: Remember that the Begin/BeginChild API requires you
        // to always call End/EndChild even if Begin/BeginChild returns false!
        // (this is unfortunately inconsistent with most other Begin* API).
        if (g.CurrentWindowStack.length != 1)
        {
            if (g.CurrentWindowStack.length > 1)
            {
                console.assert(g.CurrentWindowStack.length == 1,
                    "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
                while (g.CurrentWindowStack.length > 1) // FIXME-ERRORHANDLING
                    this.End();
            }
            else
            {
                console.assert(g.CurrentWindowStack.length == 1,
                    "Mismatched Begin/BeginChild vs End/EndChild calls: did you overcall End/EndChild?");
            }
        }

        // Hide implicit/fallback "Debug" window if it hasn't been used
        g.FrameScopePushedImplicitWindow = false;
        if (g.CurrentWindow && !g.CurrentWindow.WriteAccessed)
            g.CurrentWindow.Active = false;
        this.End();

        // Show CTRL+TAB list window
        if (g.NavWindowingTarget)
            this.NavUpdateWindowingList();

        // Drag and Drop: Elapse payload (if delivered, or if source stops
        // being submitted)
        if (g.DragDropActive)
        {
            let is_delivered = g.DragDropPayload.Delivery;
            let is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) &&
                        ((g.DragDropSourceFlags & DragDropFlags.SourceAutoExpirePayload) ||
                          !this.IsMouseDown(g.DragDropMouseButton));
            if (is_delivered || is_elapsed)
                this.ClearDragDrop();
        }

        // Drag and Drop: Fallback for source tooltip. This is not ideal but
        // better than nothing.
        if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount)
        {
            g.DragDropWithinSourceOrTarget = true;
            this.SetTooltip("...");
            g.DragDropWithinSourceOrTarget = false;
        }

        // End frame
        g.FrameScopeActive = false;
        g.FrameCountEnded = g.FrameCount;

        // Initiate moving window + handle left-click and right-click focus
        this.updateMouseMovingWindowEndFrame();

        // zsort non-child windows, higher numbers are more in front
        this.zsortWindows();

        // Sort the window list so that all child windows are after their parent
        // We cannot do that on FocusWindow() because children may not exist yet

        g.WindowsSortBuffer.resize(0);
        for (let i = 0; i != g.Windows.length; i++)
        {
            let win = g.Windows[i];
            // if a child is active its parent will add it
            if (win.Active && (win.Flags & WindowFlags.ChildWindow))
                continue;
            this.addWindowToSortBuffer(g.WindowsSortBuffer, win);
        }

        // This usually assert if there is a mismatch between the
        // WindowFlags.ChildWindow / ParentWindow values and DC.ChildWindows[]
        // in parents, aka we've done something wrong.
        console.assert(g.Windows.length == g.WindowsSortBuffer.length);
        let tmp = g.Windows;
        g.Windows = g.WindowsSortBuffer;
        g.WindowsSortBuffer = tmp;
        g.IO.MetricsActiveWindows = g.WindowsActiveCount;

        // Unlock font atlas
        g.IO.Fonts.Locked = false;

        // Clear Input data for next frame
        g.IO.MouseWheel = g.IO.MouseWheelH = 0.;
        g.IO.ClearInputCharacters();
        g.IO.NavInputs.fill(0);
        this.guictx.EndFrame();
    }

    Render()
    {
        let g = this.guictx;
        console.assert(g.Initialized);
        if (g.FrameCountEnded != g.FrameCount)
            this.EndFrame();

        g.FrameCountRendered = g.FrameCount;

        g.IO.MetricsRenderWindows = 0;

        var w = g.canvas.getAttribute("width");
        var h = g.canvas.getAttribute("height");
        let ctx = g.canvas.getContext("2d");
        ctx.clearRect(0, 0, w, h); // clear is clear

        ctx.save();
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

        // XXX: render app background drawlist
        let frontWins = [null, null];
        if(g.NavWindowingTarget &&
            !(g.NavWindowingTarget.Flags & WindowFlags.NoBringToFrontOnFocus))
        {
            frontWins[0] = g.NavWindowingTarget.RootWindow;
        }
        if(g.NavWindowingTarget)
            frontWins[1] = g.NavWindowingList;

        for(let l=0;l<2;l++)
        {
            for (let n=0; n<g.Windows.length; n++)
            {
                let win = g.Windows[n];
                if (win.IsActiveAndVisible() &&
                   // (win.Flags & WindowFlags.ChildWindow) == 0 &&
                   // we don't combine display lists, so we draw child windows
                    win != frontWins[0] && win != frontWins[1])
                {
                    g.IO.MetricsRenderWindows++;
                    win.Render(l);
                }
                else
                {
                    // if(win.Active) console.log("hidden:" + win.Name);
                }
            }
        }

        // XXX: multi layers here too?
        for (let n = 0; n < frontWins.length; n++)
        {
            if (frontWins[n] && frontWins[n].IsWindowActiveAndVisible())
            {
                // NavWindowingTarget is always temporarily displayed as the
                // front-most window
                g.IO.MetricsRenderWindows++;
                frontWins[n].Render();
            }
        }

        // XXX: render app background drawlist

        // Draw software mouse cursor if requested

        ctx.restore();

    }

    // DemoWindow is separate object
    // AboutWindow is separate object
    // MetricsWindow is separate object
    // StyleEditor is separate object
    // StyleSelector is separate object
    // FontSelector is separate object
    // UserGuide is separate object

    GetVersion(variant="about")
    {
        switch(variant)
        {
        case "imgui-njs":
            return this.version;
        case "imgui":
            return this.version_imgui;
        case "about":
        default:
            return this.about;
        }
    }

    // Styles
    // new, recommended style (default)
    StyleColorsDark()
    {
        this.guictx.Style.SetColorScheme("DarkColors");
    }

    // classic imgui style
    StyleColorsClassic()
    {
        this.guictx.Style.SetColorScheme("ClassColors");
    }

    // best used with borders and a custom, thicker font
    StyleColorsLight()
    {
        this.guictx.Style.SetColorScheme("LightColors");
    }

    PushStyleColor(stylid, col) // stylid is a string like "WindowBg"
    {
        let g = this.guictx;
        let backup = new ColorMod(stylid, g.Style.Colors[stylid]);
        g.ColorModifiers.push(backup);
        g.Style.Colors[stylid] = col;
    }

    PopStyleColor(count=1)
    {
        let g = this.guictx;
        while (count > 0)
        {
            let backup = g.ColorModifiers.pop();
            g.Style.Colors[backup.Field] = backup.BackupValue;
            count--;
        }
    }

    GetStyleColor(stylid, alphaMult=1)
    {
        let g = this.guictx;
        let c = g.Style.Colors[stylid];
        console.assert(c, stylid);
        return c.AsRGB(alphaMult);
    }

    PushStyleVar(field, val)
    {
        let g = this.guictx;
        let backup = new StyleMod(field, g.Style[field]);
        g.StyleModifiers.push(backup);
        g.Style[field] = val;
    }

    PopStyleVar(count=1)
    {
        let g = this.guictx;
        while(count > 0)
        {
            let backup = g.StyleModifiers.pop();
            g.Style[backup.Field] = backup.Value;
            count--;
        }
    }

    // no args: get current font
    // no name: get a scaled/styled version of the current font
    // name and scale/style: get a styled variant of the named font
    GetFont(name=null, scale=1, weight=null, style=null)
    {
        if(name == null && scale == 1)
            return this.guictx.Font;
        else
        {
            if(name == null)
                name = this.guictx.Font.Family;
            let size = this.guictx.FontSize * scale;
            return this.guictx.IO.Fonts.GetFont(name, size, weight, style);
        }
    }

    SetFont(font) // generally prefer Push/PopFont
    {
        let g = this.guictx;
        g.Font = font;
        g.FontSize = font.Size;
        g.FontMidline = font.Baseline / 2;
        g.FontLineHeight = font.Size * this.GetLineHeightPct();
    }

    GetFontSize() // useful for computing horizontal positioning (aka 'em')
    {
        let g = this.guictx;
        return g.FontSize;
    }

    GetFontMidline()
    {
        let g = this.guictx;
        return g.FontMidline;
    }

    GetLineHeight() // useful for computing vertical spacing
    {
        let g = this.guictx;
        return g.FontLineHeight;
    }

    GetLineHeightPct()
    {
        let g = this.guictx;
        return g.Style.TextLineHeightPct; // usually in the range (.75-1.5)
    }

    PushFont(font)
    {
        if(typeof(font) == "string")
            font = this.guictx.Style.GetFont(font);

        if(!font)
            font = this.getDefaultFont();

        this.guictx.FontStack.push(font);
        this.SetFont(font);
        return font;
    }

    PopFont()
    {
        this.guictx.FontStack.pop();
        let font = this.guictx.FontStack[this.guictx.FontStack.length-1];
        if(!font)
            font = this.getDefaultFont();
        this.SetFont(font);
        return font;
    }

    getDefaultFont()
    {
        let g = this.guictx;
        return g.Style.GetFont("Default");
    }

    setCurrentFontName(fontnm)
    {
        let g = this.guictx;
        this.SetFont(this.GetFont(name));
    }

    // GetFontTexUVWhitePixel() { console.assert(0, "unimplemented"); }
    // GetColorU32() { console.assert(0, "unimplemented"); }

    SetNextItemWidth(item_width)
    {
        this.getCurrentWindow().DC.NextItemWidth = item_width;
    }

    GetLastItemWidth()
    {
        let w = this.getCurrentWindow();
        return w.DC.LastItemRect.Max.x - w.DC.LastItemRect.Min.x;
    }

    // Parameters stacks (current window)
    // width of items for the common item+label case, pixels. 0.0f = default
    // to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels
    // to the right of window (so -1.0f always align width to the right side)
    PushItemWidth(item_width)
    {
        let win = this.getCurrentWindow();
        win.DC.ItemWidth = (item_width == 0. ? win.ItemWidthDefault : item_width);
        win.DC.ItemWidthStack.push(win.DC.ItemWidth);
    }

    PushMultiItemsWidths(ncomp, w_full)
    {
        let win = this.getCurrentWindow();
        const style = this.guictx.Style;
        const w_item_one  = Math.max(1,
            Math.floor((w_full - (style.ItemInnerSpacing.x)*(ncomp-1))/ncomp));
        const w_item_last = Math.max(1,
            Math.floor(w_full - (w_item_one + style.ItemInnerSpacing.x) * (ncomp-1)));
        win.DC.ItemWidthStack.push_back(w_item_last);
        for (let i = 0; i < ncomp-1; i++)
            win.DC.ItemWidthStack.push_back(w_item_one);
        win.DC.ItemWidth = win.DC.ItemWidthStack.back();
    }

    PopItemWidth()
    {
        let win = this.getCurrentWindow();
        win.DC.ItemWidthStack.pop();
        win.DC.ItemWidth = win.DC.ItemWidthStack.empty() ?
                                    win.ItemWidthDefault :
                                    win.DC.ItemWidthStack.back();
    }

    // Calculate default item width given value passed to PushItemWidth()
    // or SetNextItemWidth(),
    getNextItemWidth()
    {
        let win = this.guictx.CurrentWindow;
        let w;
        if (win.DC.NextItemWidth != Number.MAX_VALUE)
        {
            w = win.DC.NextItemWidth;
            win.DC.NextItemWidth = Number.MAX_VALUE;
        }
        else
        {
            w = win.DC.ItemWidth;
        }
        if (w < 0)
        {
            let region_max_x = this.getContentRegionMaxScreen().x;
            w = Math.max(1, region_max_x - win.DC.CursorPos.x + w);
        }
        w = Math.floor(w);
        return w;
    }

    // Calculate item width *without* popping/consuming NextItemWidth if it was
    // set. (rarely used, which is why we avoid calling this from
    //  GetNextItemWidth() and instead do a backup/restore here
    CalcItemWidth()
    {
        let win = this.guictx.CurrentWindow;
        let backup_next_item_width = win.DC.NextItemWidth;
        let w = this.getNextItemWidth();
        win.DC.NextItemWidth = backup_next_item_width;
        return w;
    }

    // Calculate full item size given user provided 'size' parameter and
    // default width/height. Default width is often == getNextItemWidth().
    // Those two functions CalcItemWidth vs calcItemSize are awkwardly named
    // because they are not fully symmetrical. Note that only CalcItemWidth()
    // is publicly exposed. The 4.0f here may be changed to match
    // getNextItemWidth() and/or BeginChild() (right now we have a mismatch
    // which is harmless but undesirable)
    calcItemSize(size, default_w, default_h)
    {
        let win = this.guictx.CurrentWindow;
        let region_max;
        if (size.x < 0 || size.y < 0)
            region_max = this.getContentRegionMaxScreen();

        if (size.x == 0)
            size.x = default_w;
        else
        if (size.x < 0)
            size.x = Math.max(4, region_max.x - win.DC.CursorPos.x + size.x);

        if (size.y == 0)
            size.y = default_h;
        else
        if (size.y < 0)
            size.y = Math.max(4, region_max.y - win.DC.CursorPos.y + size.y);
        return size;
    }

    calcWrapWidthForPos(pos, wrap_pos_x)
    {
        if (wrap_pos_x < 0)
            return 0;
        let win = this.guictx.CurrentWindow;
        if (wrap_pos_x == 0)
            wrap_pos_x = this.GetContentRegionMax().x + win.Pos.x;
        else
        if (wrap_pos_x > 0)
        {
            wrap_pos_x += win.Pos.x-win.Scroll.x;
            // wrap_pos_x is provided is window local space
        }
        return Math.max(wrap_pos_x - pos.x, 1);
    }

    pushMultiItemsWidths(components, w_full=0)
    {
        let win = this.getCurrentWindow();
        let style = this.guictx.Style;
        if (w_full <= 0)
            w_full = this.CalcItemWidth();
        let w = (w_full-style.ItemInnerSpacing.x*(components-1))/components;
        let w_item_one  = Math.max(1, Math.floor(w));
        let wl = w_full - (w_item_one + style.ItemInnerSpacing.x) * (components-1);
        const w_item_last = Math.max(1, Math.floor(wl));
        win.DC.ItemWidthStack.push(w_item_last);
        for (let i = 0; i < components-1; i++)
            win.DC.ItemWidthStack.push(w_item_one);
        win.DC.ItemWidth = win.DC.ItemWidthStack[win.DC.ItemWidthStack.length-1];
    }

    PushItemFlag(flag, val)
    {
        let win = this.guictx.CurrentWindow;
        if (val)
            win.DC.ItemFlags |= flag;
        else
            win.DC.ItemFlags &= ~flag;
        win.DC.ItemFlagsStack.push(win.DC.ItemFlags);
    }

    PopItemFlag()
    {
        let win = this.guictx.CurrentWindow;
        let stack = win.DC.ItemFlagsStack;
        stack.pop();
        win.DC.ItemFlags = stack[stack.length-1]; // may be undefined
        if(win.DC.ItemFlags == undefined)
            win.DC.ItemFlags = ItemFlags.Default;
    }

    isWindowContentHoverable(win, flags)
    {
        // An active popup disable hovering on other windows (apart from its
        // own children FIXME-OPT: This could be cached/stored within the window.
        let g = this.guictx;
        if (g.NavWindow)
        {
            let froot = g.NavWindow.RootWindow;
            if (froot)
            {
                if (froot.WasActive && froot != win.RootWindow)
                {
                    // For the purpose of those flags we differentiate
                    // "standard popup" from "modal popup"
                    // NB: The order of those two tests is important because
                    // Modal windows are also Popups.
                    if (froot.Flags & WindowFlags.Modal)
                        return false;
                    if ((froot.Flags & WindowFlags.Popup) &&
                        !(flags & HoveredFlags.AllowWhenBlockedByPopup))
                        return false;
                }
            }
        }
        return true;
    }

    // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap
    // to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position
    // in window local space
    PushTextWrapPos(wrap_pos_x=0)
    {
        let win = this.guictx.CurrentWindow;
        win.DC.TextWrapPos = wrap_pos_x;
        win.DC.TextWrapPosStack.push(wrap_pos_x);
    }

    PopTextWrapPos()
    {
        let win = this.guictx.CurrentWindow;
        let stack = win.DC.TextWrapPosStack;
        stack.pop();
        win.DC.TextWrapPos = stack[stack.length-1]; // may be undefined
        if(win.DC.TextWrapPos == undefined)
            win.DC.TextWrapPos = -1.;
    }

    // allow focusing using TAB/Shift-TAB, enabled by default but you can
    // disable it for certain widgets
    PushAllowKeyboardFocus(allow_keyboard_focus)
    {
        this.PushItemFlag(ItemFlags.NoTabStop, !allow_keyboard_focus);
    }

    PopAllowKeyboardFocus()
    {
        this.PopItemFlag();
    }

    // in 'repeat' mode, Button*() functions return repeated true in a
    // typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting).
    // Note that you can call IsItemActive() after any Button() to tell if
    // the button is held in the current frame.
    PushButtonRepeat(repeat)
    {
        this.PushItemFlag(ItemFlags.ButtonRepeat, repeat);
    }

    PopButtonRepeat()
    {
        this.PopItemFlag();
    }

    // Cursor / Layout - implemented in LayoutMixin
    // - By "cursor" we mean the current output position.
    // - The typical widget behavior is to output themselves at the current
    //   cursor position, then move the cursor one line down.

    GetFrameHeight()
    {
        let g = this.guictx;
        // frames are generally built around single lines of text
        // so FontLineHeight isn't wise here. Extra space is/should-be
        // governed by a variant of margin or padding.
        return g.FontSize + 2 * g.Style.FramePadding.y;
    }

    // (distance in pixels between 2 consecutive lines of framed widgets)
    GetFrameHeightWithSpacing()
    {
        let g = this.guictx;
        return this.GetFrameHeight() + g.Style.ItemSpacing.y;
    }

    // ID stack/scopes
    // - Read the FAQ for more details about how ID are handled in dear imgui.
    //   If you are creating widgets in a loop you most likely want to push a
    //   unique identifier (e.g. object pointer, loop index) to uniquely
    //   differentiate them.
    // - The resulting ID are hashes of the entire stack.
    // - You can also use the "Label##foobar" syntax within widget label to
    //   distinguish them from each others.
    // - In this header file we use the "label"/"name" terminology to denote
    //   a string that will be displayed and used as an ID, whereas "str_id"
    //   denote a string that is only used as an ID and not normally displayed.
    // push string into the ID stack (will hash string).
    PushID(str_id)
    {
        this.guictx.CurrentWindow.PushID(str_id);
    }

    // pop from the ID stack.
    PopID()
    {
        this.guictx.CurrentWindow.PopID();
    }

    // calculate unique ID (hash of whole ID stack + given parameter). e.g.
    // if you want to query into ImGuiStorage yourself
    GetID(str_id)
    {
        return this.guictx.CurrentWindow.GetID(str_id);
    }

    // Widgets implemented via mixins
    //  Text : see widgets/text.js
    //  Selectable: see widgets/misc.js
    //  Buttons: see widgets/button.js
    //  Drags (see widgets/drag.js)
    //  Slider (see widgets/slider.js)
    //  Input with Keyboard (see widgets/input.js)
    //  Color Editor/Picker (see widgets/coloredit.js)
    //  Trees (see widgets/tree.js)
    //  List Boxes (see widgets/listbox.js)
    //  Data Plotting (see widgets/plot.js)
    //  Menus,Popups (see widgets/menu.js, imguiPopup.js)

    // Value helpers
    Value(prefix, val)
    {
        console.assert(0, "unimplemented");
    }

    // Logging/Capture ------------------------------------------
    // see logging.js

    // Settings (persistence)
    // set settings.js

    // Drag and Drop ------------------------------------------
    // see dragdrop.js

    // Clipping -------------------------------------------------
    PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect)
    {
        let win = this.getCurrentWindow();
        win.DrawList.PushClipRect(clip_rect_min, clip_rect_max,
                                    intersect_with_current_clip_rect);
        win.ClipRect = win.DrawList.GetClipRect();
    }

    PopClipRect()
    {
        let win = this.getCurrentWindow();
        win.DrawList.PopClipRect();
        win.ClipRect = win.DrawList.GetClipRect();
    }

    // Focus, Activation -------------------------------------------------
    // - Prefer using "SetItemDefaultFocus()" over
    //  "if (IsWindowAppearing()) SetScrollHereY()" when applicable
    //  to signify "this is the default item"

    // make last item the default focused item of a win.
    SetItemDefaultFocus()
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (win.Appearing) return;
        if (g.NavWindow == win.RootWindowForNav &&
            (g.NavInitRequest || g.NavInitResultId != 0) &&
            g.NavLayer == g.NavWindow.DC.NavLayerCurrent)
        {
            g.NavInitRequest = false;
            g.NavInitResultId = g.NavWindow.DC.LastItemId;
            g.NavInitResultRectRel = new Rect(
                Vec2.Subtract(g.NavWindow.DC.LastItemRect.Min, g.NavWindow.Pos),
                Vec2.Subtract(g.NavWindow.DC.LastItemRect.Max, g.NavWindow.Pos));
            this.navUpdateAnyRequestFlag();
            if (!this.IsItemVisible())
               this.SetScrollHereY();
        }

    }

    // focus keyboard on the next widget. Use positive 'offset' to access
    // sub components of a multicomponent widget. Use -1 to access previous widget.
    SetKeyboardFocusHere(offset=0)
    {
        console.assert(offset >= -1);    // -1 is allowed but not below
        let g = this.guictx;
        let win = g.CurrentWindow;
        g.FocusRequestNextWindow = win;
        g.FocusRequestNextCounterAll = win.DC.FocusCounterAll + 1 + offset;
        g.FocusRequestNextCounterTab = Number.MAX_SAFE_INTEGER;
    }

    // Item/Widgets Utilities -------------------------------------------------
    // - Most of the functions are referring to the last/previous item we submitted.
    // - See Demo Window under "Widgets->Querying Status" for an interactive
    //   visualization of most of those functions.

    // is the last item hovered? (and usable, aka not blocked by a popup, etc.).
    // See ImGuiHoveredFlags for more options.
    IsItemHovered(flags=0, delay=0)
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (g.NavDisableMouseHover && !g.NavDisableHighlight)
            return this.IsItemFocused();

        // Test for bounding box overlap, as updated as ItemAdd()
        if (!(win.DC.LastItemStatusFlags & ItemStatusFlags.HoveredRect))
            return false;
        // Flags not supported by
        console.assert((flags & (HoveredFlags.RootWindow|HoveredFlags.ChildWindows))==0);

        // Test if we are hovering the right window (our window could be behind another window)
        // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for Root
        // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has
        //if (g.HoveredWindow != window)
        //    return false;
        if (g.HoveredRootWindow != win.RootWindow &&
            !(flags & HoveredFlags.AllowWhenOverlapped))
        {
            return false;
        }

        // Test if another item is active (e.g. being dragged)
        if (!(flags & HoveredFlags.AllowWhenBlockedByActiveItem))
        {
            if (g.ActiveId != 0 && g.ActiveId != win.DC.LastItemId &&
                !g.ActiveIdAllowOverlap && g.ActiveId != win.MoveId)
            {
                return false;
            }
        }

        // Test if interactions on this window are blocked by an active popup or modal
        if (!this.isWindowContentHoverable(win, flags))
            return false;

        // Test if the item is disabled
        if ((win.DC.ItemFlags & ItemFlags.Disabled) &&
           !(flags & HoveredFlags.AllowWhenDisabled))
        {
            return false;
        }

        // Special handling for the dummy item after Begin() which represent
        // the title bar or tab. When the window is collapsed (SkipItems==true)
        // that last item will never be overwritten so we need to detect the ca
        if (win.DC.LastItemId == win.MoveId && win.WriteAccessed)
            return false;
        else
        if(delay != 0 && g.HoveredIdTimer < delay)
            return false;
        else
            return true;
    }

    // is the last item active? (e.g. button being held, text field being edited.
    // This will continuously return true while holding mouse button on an item.
    // Items that don't interact will always return false)
    IsItemActive()
    {
        let g = this.guictx;
        if (g.ActiveId)
        {
            let win = g.CurrentWindow;
            return g.ActiveId == win.DC.LastItemId;
        }
        return false;
    }

    // is the last item focused for keyboard/gamepad navigation?
    IsItemFocused()
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        if (g.NavId == 0 || g.NavDisableHighlight ||
            g.NavId != win.DC.LastItemId)
        {
            return false;
        }
        else
            return true;
    }

    // is the last item clicked? (e.g. button/node just clicked on)
    //  == IsMouseClicked(mouse_button) && IsItemHovered()
    IsItemClicked(mouse_button=0)
    {
        return this.IsMouseClicked(mouse_button) &&
                this.IsItemHovered(HoveredFlags.None);
    }

    // is the last item visible? (items may be out of sight because of
    //  clipping/scrolling)
    IsItemVisible()
    {
        let win = this.getCurrentWindowRead();
        return win.ClipRect.Overlaps(win.DC.LastItemRect);
    }

    // did the last item modify its underlying value this frame? or was
    // pressed? This is generally the same as the "bool" return value of many
    // widgets.
    IsItemEdited()
    {
        let win = this.getCurrentWindowRead();
        return (win.DC.LastItemStatusFlags & ItemStatusFlags.Edited) != 0;
    }

    // was the last item just made active (item was previously inactive).
    IsItemActivated()
    {
        let g = this.guictx;
        if (g.ActiveId)
        {
            let win = g.CurrentWindow;
            if (g.ActiveId == win.DC.LastItemId &&
                g.ActiveIdPreviousFrame != win.DC.LastItemId)
            {
                return true;
            }
        }
        return false;
    }

    // was the last item just made inactive (item was previously active).
    // Useful for Undo/Redo patterns with widgets that requires continuous editing.
    IsItemDeactivated()
    {
        let g = this.guictx;
        let win = g.CurrentWindow;
        return (g.ActiveIdPreviousFrame == win.DC.LastItemId &&
                g.ActiveIdPreviousFrame != 0 && g.ActiveId != win.DC.LastItemId);
    }

    // was the last item just made inactive and made a value change when it was
    // active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with
    // widgets that requires continuous editing. Note that you may get false
    // positives (some widgets such as Combo()/ListBox()/Selectable() will
    // return true even when clicking an already selected item).
    IsItemDeactivatedAfterEdit()
    {
        let g = this.guictx;
        return this.IsItemDeactivated() &&
            (g.ActiveIdPreviousFrameHasBeenEdited ||
                (g.ActiveId == 0 && g.ActiveIdHasBeenEdited));
    }

    // is any item hovered?
    IsAnyItemHovered()
    {
        let g = this.guictx;
        return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
    }

    // is any item active?
    IsAnyItemActive()
    {
        let g = this.guictx;
        return g.ActiveId != 0;
    }

    // is any item focused?
    IsAnyItemFocused()
    {
        let g = this.guictx;
        return g.NavId != 0 && !g.NavDisableHighlight;
    }

    // get upper-left bounding rectangle of the last item (screen space)
    GetItemRectMin()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.LastItemRect.Min;
    }

    // get lower-right bounding rectangle of the last item (screen space)
    GetItemRectMax()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.LastItemRect.Max;
    }

    // get size of last item
    GetItemRectSize()
    {
        let win = this.getCurrentWindowRead();
        return win.DC.LastItemRect.GetSize();
    }

    // allow last item to be overlapped by a subsequent item. sometimes useful
    // with invisible buttons, selectables, etc. to catch unused area.
    SetItemAllowOverlap()
    {
        let g = this.guictx;
        if (g.HoveredId == g.CurrentWindow.DC.LastItemId)
            g.HoveredIdAllowOverlap = true;
        if (g.ActiveId == g.CurrentWindow.DC.LastItemId)
            g.ActiveIdAllowOverlap = true;
    }

    // Miscellaneous Utilitiesss ----------------------------------

    IsRectVisible(a, b)
    {
        let win = this.guictx.CurrentWindow;
        if(b == undefined)
        {
            // a is assumed to be size
            // test if rectangle (of given size, starting from cursor position)
            // is visible / not clipped.
            return win.ClipRect.Overlaps(
                new Rect(win.DC.CursorPos,
                    Vec2.Add(win.DC.CursorPos, a)));
        }
        else
        {
            // a and b are min/max points
            // test if rectangle (in screen space) is visible / not clipped.
            // To perform coarse clipping on user's side.
            return win.ClipRect.Overlaps(new Rect(a, b));
        }
    }

    GetTime()
    {
        return this.guictx.Time;
    }

    // get global imgui frame count. incremented by 1 every frame.
    GetFrameCount()
    {
        return this.guictx.FrameCount;
    }

    // this draw list will be the first rendering one. Useful to quickly
    // draw shapes/text behind dear imgui contents.
    GetBackgroundDrawList()
    { return null; }

    // this draw list will be the last rendered one. Useful to quickly
    // draw shapes/text over dear imgui contents.
    GetForegroundDrawList()
    { return null; }

    GetDrawListSharedData()
    { return null; }

    // get a string corresponding to the enum value (for display, saving, etc.).
    GetStyleColorName(idx)
    {
        return idx; // here the idx is the name
    }

    // replace current window storage with our own (if you want to manipulate
    // it yourself, typically clear subsection of it)
    SetStateStorage(storage)
    {}

    GetStateStorage()
    { return null; }

    // Calculate text size. Text can be multi-line. Optionally ignore text
    // after a ## marker. CalcTextSize("") should return Vec2(0.0f, FontSize)
    CalcTextSize(text, hide_text_after_double_hash=false, wrap_width=-1)
    {
        let g = this.guictx;
        if (hide_text_after_double_hash)
            text = text.split("##")[0];
        let font = g.Font;
        if (text.length == 0)
            return new Vec2(0., g.FontLineHeight);

        let text_size = font.CalcTextSizeA(Number.MAX_VALUE, wrap_width, text,
                                            g.FontLineHeight);
        // "Round"
        text_size.x = Math.floor(text_size.x + 0.95);
        return text_size;
    }

     // Color Utilities -----------------------------------------
        // built into color object

    // Inputs Utilities -----------------------------------------

    // map Key.* values into user's key index. == io.KeyMap[key]
    GetKeyIndex(guikey)
    {
        console.assert(guikey >= 0 && guikey < Key.COUNT);
        return this.guictx.IO.KeyMap[guikey];
    }

    // is key being held. == io.KeysDown[user_key_index]. note that imgui
    // doesn't know the semantic of each entry of io.KeysDown[]. Use your
    // own indices/enums according to how your backend/engine stored them
    // into io.KeysDown[]!
    IsKeyDown(user_key_index)
    {
        if (user_key_index < 0) return false;
        console.assert(user_key_index >= 0 &&
                    user_key_index < this.guictx.IO.KeysDown.length);
        return this.guictx.IO.KeysDown[user_key_index];
    }

    // was key pressed (went from !Down to Down). if repeat=true, uses
    // io.KeyRepeatDelay / KeyRepeatRate
    IsKeyPressed(user_key_index, repeat=true)
    {
        if (user_key_index < 0)
            return false;
        let g = this.guictx;
        console.assert(user_key_index >= 0 && user_key_index < g.IO.KeysDown.length);
        const t = g.IO.KeysDownDuration[user_key_index];
        if (t == 0)
            return true;
        else
        if (repeat && t > g.IO.KeyRepeatDelay)
            return this.GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay,
                                            g.IO.KeyRepeatRate) > 0;
        else
            return false;
    }

    isKeyPressedMap(key, repeat=true)
    {
        const key_index = this.guictx.IO.KeyMap[key];
        return (key_index >= 0) ? this.IsKeyPressed(key_index, repeat) : false;
    }

    // was key released (went from Down to !Down)..
    IsKeyReleased(user_key_index)
    {
        if (user_key_index < 0) return false;
        let g = this.guictx;
        console.assert(user_key_index >= 0 &&
                        user_key_index < g.IO.KeysDown.length);
        return g.IO.KeysDownDurationPrev[user_key_index] >= 0 &&
              !g.IO.KeysDown[user_key_index];
    }

    // uses provided repeat rate/delay. return a count, most often 0 or 1
    // but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
    GetKeyPressedAmount(key_index, repeat_delay, repeat_rate)
    {
        if (key_index < 0)
            return 0;
        let g = this.guictx;
        console.assert(key_index >= 0 && key_index < g.IO.KeysDown.length);
        const t = g.IO.KeysDownDuration[key_index];
        return this.calcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime,
                    repeat_delay, repeat_rate);

    }

    IsTouchScreen()
    {
        return this.guictx.IO.ConfigFlags & ConfigFlags.IsTouchScreen;
    }

    // is mouse button held (0=left, 1=right, 2=middle)
    IsMouseDown(button)
    {
        let g = this.guictx;
        console.assert(button >= 0 && button < g.IO.MouseDown.length);
        return g.IO.MouseDown[button];
    }

    // is any mouse button held
    IsAnyMouseDown()
    {
        let g = this.guictx;
        for (let n=0; n < g.IO.MouseDown.length; n++)
        {
            if (g.IO.MouseDown[n])
                return true;
        }
        return false;
    }

    // did mouse button clicked (went from !Down to Down)
    //  (0=left, 1=right, 2=middle)
    IsMouseClicked(button, repeat=false)
    {
        let g = this.guictx;
        console.assert(button >= 0 && button < g.IO.MouseDown.length);
        const t = g.IO.MouseDownDuration[button];
        if (t == 0) return true;
        if (repeat && t > g.IO.KeyRepeatDelay)
        {
            let delay = g.IO.KeyRepeatDelay;
            let rate = g.IO.KeyRepeatRate;
            if((((t - delay)%rate) > rate*0.5) !=
               (((t - delay - g.IO.DeltaTime)%rate) > rate*0.5))
                return true;
        }
        return false;
    }

    // did mouse button double-clicked. a double-click returns false in
    // IsMouseClicked(). uses io.MouseDoubleClickTime.
    IsMouseDoubleClicked(button)
    {
        let g = this.guictx;
        console.assert(button >= 0 && button < g.IO.MouseDown.length);
        return g.IO.MouseDoubleClicked[button];
    }

    // did mouse button released (went from Down to !Down)
    IsMouseReleased(button)
    {
        let g = this.guictx;
        console.assert(button >= 0 && button < g.IO.MouseDown.length);
        return g.IO.MouseReleased[button];
    }

    // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold
    IsMouseDragging(button = 0, lock_threshold=-1)
    {
        let g = this.guictx;
        console.assert(button >= 0 && button < g.IO.MouseDown.length);
        if (!g.IO.MouseDown[button])
            return false;
        if (lock_threshold < 0)
            lock_threshold = g.IO.MouseDragThreshold;
        return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
    }

    // is mouse hovering given bounding rect (in screen space).
    // clipped by current clipping settings, but disregarding of other
    // consideration of focus/window ordering/popup-block.
    IsMouseHoveringRect(r_min, r_max, clip=true)
    {
        let g = this.guictx;
        // Clip
        let rect_clipped = new Rect(r_min, r_max);
        if (clip)
            rect_clipped.ClipWith(g.CurrentWindow.ClipRect);

        // Expand for touch input
        const rect_for_touch = new Rect(Vec2.Subtract(rect_clipped.Min,
                                                      g.Style.TouchExtraPadding),
                                        Vec2.Add(rect_clipped.Max,
                                                 g.Style.TouchExtraPadding));
        if (!rect_for_touch.Contains(g.IO.MousePos))
            return false;
        else
            return true;
    }

    IsMouseHoveringAnyWindow()
    {
        return this.IsWindowHovered(HoveredFlags.AnyWindow);
    }

    IsMouseHoveringWindow()
    {
        return this.IsWindowHovered(HoveredFlags.AllowWhenBlockedByPopup |
                                 HoveredFlags.AllowWhenBlockedByActiveItem);
    }

    // We typically use Vec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse
    // position.
    IsMousePosValid(pos=null)
    {
        const MOUSE_INVALID = -256000;
        let p = pos ? pos : this.guictx.IO.MousePos;
        return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
    }

    // shortcut to ImGui::GetIO().MousePos provided by user, to be
    // consistent with other calls
    GetMousePos()
    {
        return this.guictx.IO.MousePos;
    }

    // retrieve backup of mouse position at the time of opening popup we have
    // BeginPopup() into
    GetMousePosOnOpeningCurrentPopup()
    {
        let g = this.guictx;
        if (g.BeginPopupStack.length > 0)
            return g.OpenPopupStack[g.BeginPopupStack.length-1].OpenMousePos;
        return g.IO.MousePos;
    }

    // return the delta from the initial clicking position while the mouse
    // button is pressed or was just released. This is locked and return 0.0f
    // until the mouse moves past a distance threshold at least once. If
    // lock_threshold < -1.0f uses io.MouseDraggingThreshold.
    GetMouseDragDelta(button=0, lock_threshold=-1.)
    {
        let g = this.guictx;
        console.assert(button >= 0 && button < g.IO.MouseDown.length);
        if (lock_threshold < 0)
            lock_threshold = g.IO.MouseDragThreshold;
        if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])
        {
            if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
            {
                if (this.IsMousePosValid(g.IO.MousePos) &&
                    this.IsMousePosValid(g.IO.MouseClickedPos[button]))
                {
                    return g.IO.MousePos - g.IO.MouseClickedPos[button];
                }
            }
        }
        return Vec2.Zero();
    }

    ResetMouseDragDelta(button=0)
    {
        let g = this.guictx;
        console.assert(button >= 0 && button < g.IO.MouseDown.length);
        // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
        g.IO.MouseClickedPos[button] = g.IO.MousePos;
    }

    // get desired cursor type, reset in ImGui::NewFrame(), this is updated
    // during the frame. valid before Render(). If you use software rendering
    // by setting io.MouseDrawCursor ImGui will render those for you
    GetMouseCursor()
    {
        return this.guictx.MouseCursor;
    }

    // set desired cursor type
    SetMouseCursor(cursor_type)
    {
        this.guictx.MouseCursor = cursor_type;
    }

    // attention: misleading name! manually override io.WantCaptureKeyboard
    // flag next frame (said flag is entirely left for your application to
    // handle). e.g. force capture keyboard when your widget is being hovered.
    // This is equivalent to setting
    //  "io.WantCaptureKeyboard = want_capture_keyboard_value";
    // after the next NewFrame() call.
    CaptureKeyboardFromApp(capture=true)
    {
        this.guictx.WantCaptureKeyboardNextFrame = capture ? 1 : 0;
    }

    // attention: misleading name! manually override io.WantCaptureMouse
    // flag next frame (said flag is entirely left for your application to
    // handle). This is equivalent to setting
    //  "io.WantCaptureMouse = want_capture_mouse_value;" after the next
    // NewFrame() call.
    CaptureMouseFromApp(capture=true)
    {
        this.guictx.WantCaptureMouseNextFrame = capture ? 1 : 0;
    }

    // Clipboard Utilities -------------------------------------
    // Clipboard is async and subject to "PermissionsAPI"
    async GetClipboardText(cb)
    {
        this.appServices.clipboard.readText().then((txt) => 
        {
            if(cb)
                cb(txt);
            return txt;
        }).catch((err) => 
        {
            if(cb)
                cb(null);
            console.error("failed to read from clipboard: " + err);
            return null;
        });
    }

    SetClipboardText(tx)
    {
        this.appServices.clipboard.writeText(tx).then(
           ()=>{},
           ()=>console.warn("clipboard write error"));
    }

    // Settings/.Ini Utilities --------------------
    // see settings.js
    // Memory Allocators - (unsupported)
}


// =====================================================================================================================
// imgui.js END
// =====================================================================================================================
// =====================================================================================================================
// app/prefs.js BEGIN
// =====================================================================================================================


class Prefs extends SettingsHandler
{
    constructor(nmspace)
    {
        super();
        this.imgui = null;
        this.nmspace = nmspace;
        this.vals = {};
    }

    Begin(imgui)
    {
        this.imgui = imgui;
    }

    GetTypeName() { return "Prefs"; }

    Clear(val=null)
    {
        if(!val)
            this.vals = {};
        else
            delete this.vals[val];
    }

    Encapsulate() // @override 
    {
        return this.vals;
    }

    Instantiate(imgui, o) // @override of SettingsHandler
    {
        console.assert(this.imgui == imgui);
        this.vals = o;
    }

    SetValue(nm, value) // @override
    {
        if(!nm) 
        {
            console.assert(nm);
            return;
        }

        if(this.vals[nm] != value)
        {
            this.vals[nm] = value;
            if(this.imgui)
                this.imgui.MarkIniSettingsDirty();
        }
    }

    GetValue(nm, fallback) // @override
    {
        if(!nm) 
        {
            console.assert(nm);
            return fallback;
        }

        let ret = this.vals[nm]; // may be undefined
        if(ret === undefined)
            ret = fallback;
        return ret;
    }
}

// =====================================================================================================================
// app/prefs.js END
// =====================================================================================================================
// =====================================================================================================================
// app/filesystem.js BEGIN
// =====================================================================================================================

/* global BrowserFS */
// see:
// https://github.com/jvilk/BrowserFS
// https://jvilk.com/browserfs/2.0.0-beta/index.html
// https://en.wikipedia.org/wiki/OverlayFS
// https://www.html5rocks.com/en/tutorials/webdatabase/websql-indexeddb/
// https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
// https://stackoverflow.com/questions/1443158/binary-data-in-json-string-something-better-than-base64
// https://www.html5rocks.com/en/tutorials/file/filesystem/
// https://developer.mozilla.org/en-US/docs/Web/API/File_and_Directory_Entries_API/Introduction
//
// The simplest of filesystem shims.  Works in cahoots with a server
// and communicates over a websocket.  We currently assume all files
// are small enough to read in one go.  Permissions, etc are missing.

// currently we don't expose the node-glue apis outside this file.
class FileSystem
{
    constructor(runtime)
    {
        let self = this;
        this.runtime = runtime;
        this.isWindows = false;
        if(runtime == "browser")
        {
            if(window.BrowserFS != undefined)
            {
                console.info("Installing BrowserFS");
                this.fs = BrowserFS.BFSRequire("fs");
                this.path = BrowserFS.BFSRequire("path");
                BrowserFS.FileSystem.IndexedDB.Create(function(e, lsfs) {
                    BrowserFS.FileSystem.XmlHttpRequest.Create(function(e, http) {
                        BrowserFS.FileSystem.MountableFileSystem.Create({
                            "/home": lsfs,
                            "/net": http
                        }, function(e, mfs) {
                            BrowserFS.initialize(mfs);
                            // BFS is now ready to use!
                            self.oninit();
                        });
                    });
                });
            }
            else
                console.warn("No file-IO in browser mode");
        }
        else
        if(runtime == "electron")
        {
            // we use window.require to trick webpack for electron
            /* we don't want to use remote package since it's 
             * deprecated.
             */

            /*
            let remote = window.require("electron").remote;
            this.fs = remote.require("fs");
            this.path = window.require("path"); 
            */
            this.isWindows = navigator && 
                            (navigator.platform.indexOf("Win32") != -1);
        }
        else
        {
            this.path = require("path"); // webpack handles this?
            this.fs = null; // no filesystem here yet (eg: cordova)
        }
    }

    oninit()
    {
        console.debug("FileSystem initialized");
        // self.test();
    }

    stat(pathname, islstat, cb)
    {
        this.fs.stat(pathname, islstat, cb);
    }

    statSync(pathname, islstat)
    {
        return this.fs.statSync(pathname, islstat);
    }

    readFile(pathname, options, cb) // cb(string|Buffer)
    {
        this.fs.readFile(pathname, options, cb);
    }

    readFileSync(pathname, options=null)
    {
        return this.fs.readFileSync(pathname, options);
    }

    // mode: 0o666 is default
    writeFile(pathname, data, encoding=null, flag="w+", mode=null, cb)
    {
        this.fs.writeFile(pathname, data, encoding, flag, mode, cb);
    }

    writeFileSync(pathname, contents, encoding=null, flag)
    {
        return this.fs.writeFileSync(pathname, contents, encoding, flag);
    }

    listVolumes(cb)
    {
        if(this.isWindows)
        {
            let opts = {withFileTypes: true};
            this.filesys.readdir(this.cwd, opts, cb);
        }
        else
        {
            // spawn a cmd child process, pipe the "wmic" command to it
            // alt take: spawn wmic directly (assumes wmic is in path)
            // https://stackoverflow.com/questions/15878969/enumerate-system-drives-in-nodejs
            let cp = window.require("child_process");
            if(!cp)
            {
                console.error("listVolumes missing child_process module");
                return;
            }
            let spawn = cp.spawn;
            const list = spawn("wmic", ["logicaldisk", "get", "name"]);
            list.stdout.on("data", (data) =>
            {
                // console.log("stdout: " + String(data));
                const output = String(data);
                const out = output.split("\r\n").map(e=>e.trim()).filter(e=>e!="");
                if (out[0]==="Name")
                {
                    let ret = [];
                    // expect items 1-length to be drives
                    // for now we ignore network drives and cull
                    // redundant mounts (eclipse seems to introduce one)
                    for(let vol of out.slice(1))
                    {
                        if(vol[1] == ":")
                        {
                            let vdir = vol.slice(0, 2); // "C:"
                            if(ret.indexOf(vdir) == -1)
                                ret.push(vdir);
                        }
                    }
                    cb(0, ret);
                }
            });
            list.stderr.on("data", function (data) {
                console.error("stderr: " + data);
            });
            list.on("exit", function (code) {
                if (code !== 0)
                {
                    console.error("child process exited with code " + code);
                    cb(code, []);
                }
            });

            //  -- here's the actual command -------------------
            // list.stdin.write("wmic logicaldisk get name\n");
            // list.stdin.end();
        }
    }

    readdir(pathname, opts, cb) // cb(err, string[])
    {
        // BrowserFS doens't support opts
        this.fs.readdir(pathname, cb);
    }

    readdirSync(pathname)
    {
        return this.fs.readdirSync(pathname); // returns string[]
    }

    mkdir(pathname, opts, cb)
    {
        // opts: recursive, mode
        this.fs.mkdir(pathname, opts, cb);
    }

    mkdirSync(pathname, opts)
    {
        this.fs.mkdirSync(pathname, opts);
    }

    rmdir(pathname, cb)
    {
        this.fs.rmdir(pathname, cb);
    }

    unlink(pathname, cb)
    {
        this.fs.unlink(pathname, cb);
    }

    test()
    {
        this.mkdir("/home/dana", {recursive: true},
            (err) =>
            {
                if(err && err.code != "EEXIST")
                {
                    console.error(err);
                    return;
                }
                let fn = "/home/dana/test.txt";
                this.fs.writeFile(fn,
                    "Cool, I can do this in the browser!",
                    function(err) {
                        this.fs.readFile(fn, function(err, contents) {
                            console.log(contents.toString());
                        });
                });
            });
        this.fs.readdir("/net/examples/orca", function(err, files)
            {
                if(err)
                    console.error(err);
                console.log("/net/examples/orca: " + files);
            });
    }
}
// =====================================================================================================================
// app/filesystem.js END
// =====================================================================================================================
// =====================================================================================================================
// app/app.js BEGIN
// =====================================================================================================================



// A base Application for generic imgui applications.  Clients
// can extend this class or roll their own.

class ImguiApp
{
    constructor(appname="UntitledImguiApp", version="1.0.0", initLog=true)
    {
        console.debug("App Init " + new Date().toLocaleString());
        this.appname = appname;
        this.version = version;
        this.prefs = new Prefs(this.appname);
        this.running = true;
        this.runtime = (window.process && window.process.type) ? "electron" 
                        : (window.cordova) ? "cordova" : "browser";
        this.filesystem = new FileSystem(this.runtime);
        this.canvas = document.getElementById("AppCanvas");
        if(!this.canvas)
        {
            alert("Can't find canvas element named AppCanvas");
            return;
        }
        this.imgui = null;
        this.FileBrowser = null;
        this.Log = null;

        // appServices protocol used by imgui, navigator.clipboard doesn't
        // work in the electron environment.
        this.platform = navigator.platform;
        this.clipboard = navigator.clipboard;

        window.App = this;
    }

    IsTouchScreen()
    {
        if(this.imgui)
            return this.imgui.guictx.IO.ConfigFlags & ConfigFlags.IsTouchScreen;
        else
            return this.IsMobileDevice();
    }

    OnLogActivity(msg, level)
    {
        // overridable
    }

    IsMobileDevice()
    {
        if((typeof window.orientation !== "undefined") || 
           (navigator.userAgent.indexOf("IEMobile") !== -1))
        {
            return true;
        }
        else
            return false;
        /*
        let a = window.navigator.userAgent.toLowerCase();
        return a.indexOf("android") != -1 ||
               a.indexOf("iphone") != -1 ||
               a.indexOf("ipad") != -1;
        */
    }    

    GetRuntime() // electron, cordova, browser
    {
        return this.runtime;
    }

    GetName()
    {
        return this.appname;
    }

    OpenFile(filename, options, cb)
    {
        // options can be either string or object
        //  { encoding: "utf8", etc }
        this.filesystem.readFile(filename, options, cb); // async
    }

    SaveFile(filename, data, options, cb)
    {
        this.filesystem.writeFile(filename, data, options, cb); // async
    }

    SetPref(name, value)
    {
        this.prefs.SetValue(name, value); // calls imgui.MarkIniSettingsDirty
    }

    GetPref(name, dflt)
    {
        return this.prefs.GetValue(name, dflt);
    }

    Begin(onReady) // onReady: cuz begin takes triggers async loading
    {
        if(!this.canvas) return;
        this.imgui = new Imgui(this.canvas, this.appname, this);
        this.prefs.Begin(this.imgui);
        this.imgui.guictx.SettingsHandlers.push(this.prefs);
        this.imgui.LoadIniSettingsFromDisk();
        this.Log = new LogWindow(this);
        this.Log.Begin(this.imgui);
        this.FileBrowser = new FileBrowser(this.filesystem, this.prefs); // Begin below
        this.FileBrowser.Begin(this.imgui);

        console.debug(`${this.appname} Begin ${new Date().toLocaleString()}`);
        console.debug(`  version: ${this.version}`);
        console.debug(`  ${this.imgui.GetVersion()}`);
        onReady(0);
    }

    End() // done
    {
        this.imgui.EndFrame();
        if(this.runtime == "electron")
        {
            // used window.require to trick webpack
            const remote = window.require("electron").remote;
            remote.getCurrentWindow().close();
        }
    }

    OnLoop(time) // called e.g. 60 fps, subclass may override
    {
        if(!this.canvas) return;
        if(this.imgui.NewFrame(time))
        {
            this.ShowContextMenu(this.imgui);
            if(this.FileBrowser)
                this.FileBrowser.Show(this.imgui); // manages its own IsOpen state
            if(this.Log)
                this.Log.Show(this.imgui, "Log");
            this.OnFrame(this.imgui); // subclass hooks in here
            this.imgui.Render(); // calls EndFrame
        }
        else
            this.imgui.EndFrame();
        return this.running;
    }

    OnFrame(imgui)
    {
        // overridable method
    }

    OnLogActivity(lastMsg, lastLevel)
    {
        // overridable method
    }

    ShowContextMenu(imgui)
    {
        if(imgui.BeginPopupContextVoid("ContextMenu", 1))
        {
            if(this.Log)
            {
                if(imgui.MenuItem("Log", null, this.Log.IsShowing.get()))
                {
                    this.Log.IsShowing.toggle();
                }
            }

            this.AppendContextMenu(imgui);

            if(this.runtime === "electron")
            {
                if(imgui.MenuItem("Quit"))
                {
                    // before closing, need to check dirty state
                    this.running = false;
                }
            }
            imgui.EndPopup();
        }
    }

    AppendContextMenu(imgui)
    {
        // no-op, child-class can override
    }

    ShowModalDialog(cfg, cb)
    {
        // config.type: question, entry
        // config.buttons ["one", "two", "three"]
        // config.title
        // message: "txt"
        // icon: url
        // iconSize: Vec2
        let id = cfg.id ? cfg.id : "Modal?";
        if(this.imgui.BeginPopupModal(id, null, WindowFlags.AlwaysAutoResize))
        {
            if(cfg.icon)
            {
                let imgSz = cfg.iconSize ? cfg.iconSize : new Vec2(200, 100);
                this.imgui.Image(cfg.icon, imgSz, null, null, null, Colors.black);
                this.imgui.SameLine();
            }
            this.imgui.Text(cfg.msg);
            this.imgui.Separator();
            if(cfg.type == "entry")
            {
                if(!this.editText)
                    this.editText = new MutableString("");
                else
                    this.editText.Set("");

                this.imgui.TextEntry(this.editText);
            }
            for(let i=0;i<cfg.buttons.length;i++)
            {
                if(this.imgui.Button(cfg.buttons[i]))
                {
                    if(cb)
                    {
                        let extra = null;
                        if(cfg.type == "entry")
                            extra = this.editText.Get();
                        cb(i, extra);
                    }
                    this.imgui.CloseCurrentPopup();
                }
            }
            this.imgui.EndPopup();
        }
    }

    ShowOpenDialog(prompt, cb, extensions=[], closeOnSelect=true, zIndex=-1)
    {
        let mcb = function(err, path)
        {
            if(closeOnSelect)
                this.FileBrowser.IsOpen.set(false);
            cb(err, [path]);
        }.bind(this);
        this.FileBrowser.SetClient(prompt, mcb, "PickFile", extensions, true, zIndex);
    }

    ShowSaveDialog(prompt, cb, extensions=[], closeOnSelect=true, zIndex=-1)
    {
        let mcb = function(err, path)
        {
            if(closeOnSelect)
                this.FileBrowser.IsOpen.set(false);
            cb(err, path);
        }.bind(this);
        this.FileBrowser.SetClient(prompt, mcb, "SaveFile", extensions, true, zIndex);
    }
}


// =====================================================================================================================
// app/app.js END
// =====================================================================================================================
